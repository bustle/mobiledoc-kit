var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var jquery = createCommonjsModule(function (module) {
/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	{

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : commonjsGlobal, function( window, noGlobal ) {

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );
});

var qunit = createCommonjsModule(function (module, exports) {
/*!
 * QUnit 2.9.3
 * https://qunitjs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-10-08T15:49Z
 */
(function (global$1) {

  global$1 = global$1 && global$1.hasOwnProperty('default') ? global$1['default'] : global$1;

  var window$1 = global$1.window;
  var self$1 = global$1.self;
  var console = global$1.console;
  var setTimeout$1 = global$1.setTimeout;
  var clearTimeout = global$1.clearTimeout;

  var document$1 = window$1 && window$1.document;
  var navigator = window$1 && window$1.navigator;

  var localSessionStorage = function () {
  	var x = "qunit-test-string";
  	try {
  		global$1.sessionStorage.setItem(x, x);
  		global$1.sessionStorage.removeItem(x);
  		return global$1.sessionStorage;
  	} catch (e) {
  		return undefined;
  	}
  }();

  /**
   * Returns a function that proxies to the given method name on the globals
   * console object. The proxy will also detect if the console doesn't exist and
   * will appropriately no-op. This allows support for IE9, which doesn't have a
   * console if the developer tools are not open.
   */
  function consoleProxy(method) {
  	return function () {
  		if (console) {
  			console[method].apply(console, arguments);
  		}
  	};
  }

  var Logger = {
  	warn: consoleProxy("warn")
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };











  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();









































  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var toString = Object.prototype.toString;
  var hasOwn = Object.prototype.hasOwnProperty;
  var now = Date.now || function () {
  	return new Date().getTime();
  };

  var hasPerformanceApi = detectPerformanceApi();
  var performance = hasPerformanceApi ? window$1.performance : undefined;
  var performanceNow = hasPerformanceApi ? performance.now.bind(performance) : now;

  function detectPerformanceApi() {
  	return window$1 && typeof window$1.performance !== "undefined" && typeof window$1.performance.mark === "function" && typeof window$1.performance.measure === "function";
  }

  function measure(comment, startMark, endMark) {

  	// `performance.measure` may fail if the mark could not be found.
  	// reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`
  	try {
  		performance.measure(comment, startMark, endMark);
  	} catch (ex) {
  		Logger.warn("performance.measure could not be executed because of ", ex.message);
  	}
  }

  var defined = {
  	document: window$1 && window$1.document !== undefined,
  	setTimeout: setTimeout$1 !== undefined
  };

  // Returns a new Array with the elements that are in a but not in b
  function diff(a, b) {
  	var i,
  	    j,
  	    result = a.slice();

  	for (i = 0; i < result.length; i++) {
  		for (j = 0; j < b.length; j++) {
  			if (result[i] === b[j]) {
  				result.splice(i, 1);
  				i--;
  				break;
  			}
  		}
  	}
  	return result;
  }

  /**
   * Determines whether an element exists in a given array or not.
   *
   * @method inArray
   * @param {Any} elem
   * @param {Array} array
   * @return {Boolean}
   */
  function inArray(elem, array) {
  	return array.indexOf(elem) !== -1;
  }

  /**
   * Makes a clone of an object using only Array or Object as base,
   * and copies over the own enumerable properties.
   *
   * @param {Object} obj
   * @return {Object} New object with only the own properties (recursively).
   */
  function objectValues(obj) {
  	var key,
  	    val,
  	    vals = is("array", obj) ? [] : {};
  	for (key in obj) {
  		if (hasOwn.call(obj, key)) {
  			val = obj[key];
  			vals[key] = val === Object(val) ? objectValues(val) : val;
  		}
  	}
  	return vals;
  }

  function extend(a, b, undefOnly) {
  	for (var prop in b) {
  		if (hasOwn.call(b, prop)) {
  			if (b[prop] === undefined) {
  				delete a[prop];
  			} else if (!(undefOnly && typeof a[prop] !== "undefined")) {
  				a[prop] = b[prop];
  			}
  		}
  	}

  	return a;
  }

  function objectType(obj) {
  	if (typeof obj === "undefined") {
  		return "undefined";
  	}

  	// Consider: typeof null === object
  	if (obj === null) {
  		return "null";
  	}

  	var match = toString.call(obj).match(/^\[object\s(.*)\]$/),
  	    type = match && match[1];

  	switch (type) {
  		case "Number":
  			if (isNaN(obj)) {
  				return "nan";
  			}
  			return "number";
  		case "String":
  		case "Boolean":
  		case "Array":
  		case "Set":
  		case "Map":
  		case "Date":
  		case "RegExp":
  		case "Function":
  		case "Symbol":
  			return type.toLowerCase();
  		default:
  			return typeof obj === "undefined" ? "undefined" : _typeof(obj);
  	}
  }

  // Safe object type checking
  function is(type, obj) {
  	return objectType(obj) === type;
  }

  // Based on Java's String.hashCode, a simple but not
  // rigorously collision resistant hashing function
  function generateHash(module, testName) {
  	var str = module + "\x1C" + testName;
  	var hash = 0;

  	for (var i = 0; i < str.length; i++) {
  		hash = (hash << 5) - hash + str.charCodeAt(i);
  		hash |= 0;
  	}

  	// Convert the possibly negative integer hash code into an 8 character hex string, which isn't
  	// strictly necessary but increases user understanding that the id is a SHA-like hash
  	var hex = (0x100000000 + hash).toString(16);
  	if (hex.length < 8) {
  		hex = "0000000" + hex;
  	}

  	return hex.slice(-8);
  }

  // Test for equality any JavaScript type.
  // Authors: Philippe Rath <prathe@gmail.com>, David Chan <david@troi.org>
  var equiv = (function () {

  	// Value pairs queued for comparison. Used for breadth-first processing order, recursion
  	// detection and avoiding repeated comparison (see below for details).
  	// Elements are { a: val, b: val }.
  	var pairs = [];

  	var getProto = Object.getPrototypeOf || function (obj) {
  		return obj.__proto__;
  	};

  	function useStrictEquality(a, b) {

  		// This only gets called if a and b are not strict equal, and is used to compare on
  		// the primitive values inside object wrappers. For example:
  		// `var i = 1;`
  		// `var j = new Number(1);`
  		// Neither a nor b can be null, as a !== b and they have the same type.
  		if ((typeof a === "undefined" ? "undefined" : _typeof(a)) === "object") {
  			a = a.valueOf();
  		}
  		if ((typeof b === "undefined" ? "undefined" : _typeof(b)) === "object") {
  			b = b.valueOf();
  		}

  		return a === b;
  	}

  	function compareConstructors(a, b) {
  		var protoA = getProto(a);
  		var protoB = getProto(b);

  		// Comparing constructors is more strict than using `instanceof`
  		if (a.constructor === b.constructor) {
  			return true;
  		}

  		// Ref #851
  		// If the obj prototype descends from a null constructor, treat it
  		// as a null prototype.
  		if (protoA && protoA.constructor === null) {
  			protoA = null;
  		}
  		if (protoB && protoB.constructor === null) {
  			protoB = null;
  		}

  		// Allow objects with no prototype to be equivalent to
  		// objects with Object as their constructor.
  		if (protoA === null && protoB === Object.prototype || protoB === null && protoA === Object.prototype) {
  			return true;
  		}

  		return false;
  	}

  	function getRegExpFlags(regexp) {
  		return "flags" in regexp ? regexp.flags : regexp.toString().match(/[gimuy]*$/)[0];
  	}

  	function isContainer(val) {
  		return ["object", "array", "map", "set"].indexOf(objectType(val)) !== -1;
  	}

  	function breadthFirstCompareChild(a, b) {

  		// If a is a container not reference-equal to b, postpone the comparison to the
  		// end of the pairs queue -- unless (a, b) has been seen before, in which case skip
  		// over the pair.
  		if (a === b) {
  			return true;
  		}
  		if (!isContainer(a)) {
  			return typeEquiv(a, b);
  		}
  		if (pairs.every(function (pair) {
  			return pair.a !== a || pair.b !== b;
  		})) {

  			// Not yet started comparing this pair
  			pairs.push({ a: a, b: b });
  		}
  		return true;
  	}

  	var callbacks = {
  		"string": useStrictEquality,
  		"boolean": useStrictEquality,
  		"number": useStrictEquality,
  		"null": useStrictEquality,
  		"undefined": useStrictEquality,
  		"symbol": useStrictEquality,
  		"date": useStrictEquality,

  		"nan": function nan() {
  			return true;
  		},

  		"regexp": function regexp(a, b) {
  			return a.source === b.source &&

  			// Include flags in the comparison
  			getRegExpFlags(a) === getRegExpFlags(b);
  		},

  		// abort (identical references / instance methods were skipped earlier)
  		"function": function _function() {
  			return false;
  		},

  		"array": function array(a, b) {
  			var i, len;

  			len = a.length;
  			if (len !== b.length) {

  				// Safe and faster
  				return false;
  			}

  			for (i = 0; i < len; i++) {

  				// Compare non-containers; queue non-reference-equal containers
  				if (!breadthFirstCompareChild(a[i], b[i])) {
  					return false;
  				}
  			}
  			return true;
  		},

  		// Define sets a and b to be equivalent if for each element aVal in a, there
  		// is some element bVal in b such that aVal and bVal are equivalent. Element
  		// repetitions are not counted, so these are equivalent:
  		// a = new Set( [ {}, [], [] ] );
  		// b = new Set( [ {}, {}, [] ] );
  		"set": function set$$1(a, b) {
  			var innerEq,
  			    outerEq = true;

  			if (a.size !== b.size) {

  				// This optimization has certain quirks because of the lack of
  				// repetition counting. For instance, adding the same
  				// (reference-identical) element to two equivalent sets can
  				// make them non-equivalent.
  				return false;
  			}

  			a.forEach(function (aVal) {

  				// Short-circuit if the result is already known. (Using for...of
  				// with a break clause would be cleaner here, but it would cause
  				// a syntax error on older Javascript implementations even if
  				// Set is unused)
  				if (!outerEq) {
  					return;
  				}

  				innerEq = false;

  				b.forEach(function (bVal) {
  					var parentPairs;

  					// Likewise, short-circuit if the result is already known
  					if (innerEq) {
  						return;
  					}

  					// Swap out the global pairs list, as the nested call to
  					// innerEquiv will clobber its contents
  					parentPairs = pairs;
  					if (innerEquiv(bVal, aVal)) {
  						innerEq = true;
  					}

  					// Replace the global pairs list
  					pairs = parentPairs;
  				});

  				if (!innerEq) {
  					outerEq = false;
  				}
  			});

  			return outerEq;
  		},

  		// Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)
  		// in a, there is some key-value pair (bKey, bVal) in b such that
  		// [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not
  		// counted, so these are equivalent:
  		// a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );
  		// b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );
  		"map": function map(a, b) {
  			var innerEq,
  			    outerEq = true;

  			if (a.size !== b.size) {

  				// This optimization has certain quirks because of the lack of
  				// repetition counting. For instance, adding the same
  				// (reference-identical) key-value pair to two equivalent maps
  				// can make them non-equivalent.
  				return false;
  			}

  			a.forEach(function (aVal, aKey) {

  				// Short-circuit if the result is already known. (Using for...of
  				// with a break clause would be cleaner here, but it would cause
  				// a syntax error on older Javascript implementations even if
  				// Map is unused)
  				if (!outerEq) {
  					return;
  				}

  				innerEq = false;

  				b.forEach(function (bVal, bKey) {
  					var parentPairs;

  					// Likewise, short-circuit if the result is already known
  					if (innerEq) {
  						return;
  					}

  					// Swap out the global pairs list, as the nested call to
  					// innerEquiv will clobber its contents
  					parentPairs = pairs;
  					if (innerEquiv([bVal, bKey], [aVal, aKey])) {
  						innerEq = true;
  					}

  					// Replace the global pairs list
  					pairs = parentPairs;
  				});

  				if (!innerEq) {
  					outerEq = false;
  				}
  			});

  			return outerEq;
  		},

  		"object": function object(a, b) {
  			var i,
  			    aProperties = [],
  			    bProperties = [];

  			if (compareConstructors(a, b) === false) {
  				return false;
  			}

  			// Be strict: don't ensure hasOwnProperty and go deep
  			for (i in a) {

  				// Collect a's properties
  				aProperties.push(i);

  				// Skip OOP methods that look the same
  				if (a.constructor !== Object && typeof a.constructor !== "undefined" && typeof a[i] === "function" && typeof b[i] === "function" && a[i].toString() === b[i].toString()) {
  					continue;
  				}

  				// Compare non-containers; queue non-reference-equal containers
  				if (!breadthFirstCompareChild(a[i], b[i])) {
  					return false;
  				}
  			}

  			for (i in b) {

  				// Collect b's properties
  				bProperties.push(i);
  			}

  			// Ensures identical properties name
  			return typeEquiv(aProperties.sort(), bProperties.sort());
  		}
  	};

  	function typeEquiv(a, b) {
  		var type = objectType(a);

  		// Callbacks for containers will append to the pairs queue to achieve breadth-first
  		// search order. The pairs queue is also used to avoid reprocessing any pair of
  		// containers that are reference-equal to a previously visited pair (a special case
  		// this being recursion detection).
  		//
  		// Because of this approach, once typeEquiv returns a false value, it should not be
  		// called again without clearing the pair queue else it may wrongly report a visited
  		// pair as being equivalent.
  		return objectType(b) === type && callbacks[type](a, b);
  	}

  	function innerEquiv(a, b) {
  		var i, pair;

  		// We're done when there's nothing more to compare
  		if (arguments.length < 2) {
  			return true;
  		}

  		// Clear the global pair queue and add the top-level values being compared
  		pairs = [{ a: a, b: b }];

  		for (i = 0; i < pairs.length; i++) {
  			pair = pairs[i];

  			// Perform type-specific comparison on any pairs that are not strictly
  			// equal. For container types, that comparison will postpone comparison
  			// of any sub-container pair to the end of the pair queue. This gives
  			// breadth-first search order. It also avoids the reprocessing of
  			// reference-equal siblings, cousins etc, which can have a significant speed
  			// impact when comparing a container of small objects each of which has a
  			// reference to the same (singleton) large object.
  			if (pair.a !== pair.b && !typeEquiv(pair.a, pair.b)) {
  				return false;
  			}
  		}

  		// ...across all consecutive argument pairs
  		return arguments.length === 2 || innerEquiv.apply(this, [].slice.call(arguments, 1));
  	}

  	return function () {
  		var result = innerEquiv.apply(undefined, arguments);

  		// Release any retained objects
  		pairs.length = 0;
  		return result;
  	};
  })();

  /**
   * Config object: Maintain internal state
   * Later exposed as QUnit.config
   * `config` initialized at top of scope
   */
  var config = {

  	// The queue of tests to run
  	queue: [],

  	// Block until document ready
  	blocking: true,

  	// By default, run previously failed tests first
  	// very useful in combination with "Hide passed tests" checked
  	reorder: true,

  	// By default, modify document.title when suite is done
  	altertitle: true,

  	// HTML Reporter: collapse every test except the first failing test
  	// If false, all failing tests will be expanded
  	collapse: true,

  	// By default, scroll to top of the page when suite is done
  	scrolltop: true,

  	// Depth up-to which object will be dumped
  	maxDepth: 5,

  	// When enabled, all tests must call expect()
  	requireExpects: false,

  	// Placeholder for user-configurable form-exposed URL parameters
  	urlConfig: [],

  	// Set of all modules.
  	modules: [],

  	// The first unnamed module
  	currentModule: {
  		name: "",
  		tests: [],
  		childModules: [],
  		testsRun: 0,
  		unskippedTestsRun: 0,
  		hooks: {
  			before: [],
  			beforeEach: [],
  			afterEach: [],
  			after: []
  		}
  	},

  	callbacks: {},

  	// The storage module to use for reordering tests
  	storage: localSessionStorage
  };

  // take a predefined QUnit.config and extend the defaults
  var globalConfig = window$1 && window$1.QUnit && window$1.QUnit.config;

  // only extend the global config if there is no QUnit overload
  if (window$1 && window$1.QUnit && !window$1.QUnit.version) {
  	extend(config, globalConfig);
  }

  // Push a loose unnamed module to the modules collection
  config.modules.push(config.currentModule);

  // Based on jsDump by Ariel Flesler
  // http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html
  var dump = (function () {
  	function quote(str) {
  		return "\"" + str.toString().replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"";
  	}
  	function literal(o) {
  		return o + "";
  	}
  	function join(pre, arr, post) {
  		var s = dump.separator(),
  		    base = dump.indent(),
  		    inner = dump.indent(1);
  		if (arr.join) {
  			arr = arr.join("," + s + inner);
  		}
  		if (!arr) {
  			return pre + post;
  		}
  		return [pre, inner + arr, base + post].join(s);
  	}
  	function array(arr, stack) {
  		var i = arr.length,
  		    ret = new Array(i);

  		if (dump.maxDepth && dump.depth > dump.maxDepth) {
  			return "[object Array]";
  		}

  		this.up();
  		while (i--) {
  			ret[i] = this.parse(arr[i], undefined, stack);
  		}
  		this.down();
  		return join("[", ret, "]");
  	}

  	function isArray(obj) {
  		return (

  			//Native Arrays
  			toString.call(obj) === "[object Array]" ||

  			// NodeList objects
  			typeof obj.length === "number" && obj.item !== undefined && (obj.length ? obj.item(0) === obj[0] : obj.item(0) === null && obj[0] === undefined)
  		);
  	}

  	var reName = /^function (\w+)/,
  	    dump = {

  		// The objType is used mostly internally, you can fix a (custom) type in advance
  		parse: function parse(obj, objType, stack) {
  			stack = stack || [];
  			var res,
  			    parser,
  			    parserType,
  			    objIndex = stack.indexOf(obj);

  			if (objIndex !== -1) {
  				return "recursion(" + (objIndex - stack.length) + ")";
  			}

  			objType = objType || this.typeOf(obj);
  			parser = this.parsers[objType];
  			parserType = typeof parser === "undefined" ? "undefined" : _typeof(parser);

  			if (parserType === "function") {
  				stack.push(obj);
  				res = parser.call(this, obj, stack);
  				stack.pop();
  				return res;
  			}
  			return parserType === "string" ? parser : this.parsers.error;
  		},
  		typeOf: function typeOf(obj) {
  			var type;

  			if (obj === null) {
  				type = "null";
  			} else if (typeof obj === "undefined") {
  				type = "undefined";
  			} else if (is("regexp", obj)) {
  				type = "regexp";
  			} else if (is("date", obj)) {
  				type = "date";
  			} else if (is("function", obj)) {
  				type = "function";
  			} else if (obj.setInterval !== undefined && obj.document !== undefined && obj.nodeType === undefined) {
  				type = "window";
  			} else if (obj.nodeType === 9) {
  				type = "document";
  			} else if (obj.nodeType) {
  				type = "node";
  			} else if (isArray(obj)) {
  				type = "array";
  			} else if (obj.constructor === Error.prototype.constructor) {
  				type = "error";
  			} else {
  				type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
  			}
  			return type;
  		},

  		separator: function separator() {
  			if (this.multiline) {
  				return this.HTML ? "<br />" : "\n";
  			} else {
  				return this.HTML ? "&#160;" : " ";
  			}
  		},

  		// Extra can be a number, shortcut for increasing-calling-decreasing
  		indent: function indent(extra) {
  			if (!this.multiline) {
  				return "";
  			}
  			var chr = this.indentChar;
  			if (this.HTML) {
  				chr = chr.replace(/\t/g, "   ").replace(/ /g, "&#160;");
  			}
  			return new Array(this.depth + (extra || 0)).join(chr);
  		},
  		up: function up(a) {
  			this.depth += a || 1;
  		},
  		down: function down(a) {
  			this.depth -= a || 1;
  		},
  		setParser: function setParser(name, parser) {
  			this.parsers[name] = parser;
  		},

  		// The next 3 are exposed so you can use them
  		quote: quote,
  		literal: literal,
  		join: join,
  		depth: 1,
  		maxDepth: config.maxDepth,

  		// This is the list of parsers, to modify them, use dump.setParser
  		parsers: {
  			window: "[Window]",
  			document: "[Document]",
  			error: function error(_error) {
  				return "Error(\"" + _error.message + "\")";
  			},
  			unknown: "[Unknown]",
  			"null": "null",
  			"undefined": "undefined",
  			"function": function _function(fn) {
  				var ret = "function",


  				// Functions never have name in IE
  				name = "name" in fn ? fn.name : (reName.exec(fn) || [])[1];

  				if (name) {
  					ret += " " + name;
  				}
  				ret += "(";

  				ret = [ret, dump.parse(fn, "functionArgs"), "){"].join("");
  				return join(ret, dump.parse(fn, "functionCode"), "}");
  			},
  			array: array,
  			nodelist: array,
  			"arguments": array,
  			object: function object(map, stack) {
  				var keys,
  				    key,
  				    val,
  				    i,
  				    nonEnumerableProperties,
  				    ret = [];

  				if (dump.maxDepth && dump.depth > dump.maxDepth) {
  					return "[object Object]";
  				}

  				dump.up();
  				keys = [];
  				for (key in map) {
  					keys.push(key);
  				}

  				// Some properties are not always enumerable on Error objects.
  				nonEnumerableProperties = ["message", "name"];
  				for (i in nonEnumerableProperties) {
  					key = nonEnumerableProperties[i];
  					if (key in map && !inArray(key, keys)) {
  						keys.push(key);
  					}
  				}
  				keys.sort();
  				for (i = 0; i < keys.length; i++) {
  					key = keys[i];
  					val = map[key];
  					ret.push(dump.parse(key, "key") + ": " + dump.parse(val, undefined, stack));
  				}
  				dump.down();
  				return join("{", ret, "}");
  			},
  			node: function node(_node) {
  				var len,
  				    i,
  				    val,
  				    open = dump.HTML ? "&lt;" : "<",
  				    close = dump.HTML ? "&gt;" : ">",
  				    tag = _node.nodeName.toLowerCase(),
  				    ret = open + tag,
  				    attrs = _node.attributes;

  				if (attrs) {
  					for (i = 0, len = attrs.length; i < len; i++) {
  						val = attrs[i].nodeValue;

  						// IE6 includes all attributes in .attributes, even ones not explicitly
  						// set. Those have values like undefined, null, 0, false, "" or
  						// "inherit".
  						if (val && val !== "inherit") {
  							ret += " " + attrs[i].nodeName + "=" + dump.parse(val, "attribute");
  						}
  					}
  				}
  				ret += close;

  				// Show content of TextNode or CDATASection
  				if (_node.nodeType === 3 || _node.nodeType === 4) {
  					ret += _node.nodeValue;
  				}

  				return ret + open + "/" + tag + close;
  			},

  			// Function calls it internally, it's the arguments part of the function
  			functionArgs: function functionArgs(fn) {
  				var args,
  				    l = fn.length;

  				if (!l) {
  					return "";
  				}

  				args = new Array(l);
  				while (l--) {

  					// 97 is 'a'
  					args[l] = String.fromCharCode(97 + l);
  				}
  				return " " + args.join(", ") + " ";
  			},

  			// Object calls it internally, the key part of an item in a map
  			key: quote,

  			// Function calls it internally, it's the content of the function
  			functionCode: "[code]",

  			// Node calls it internally, it's a html attribute value
  			attribute: quote,
  			string: quote,
  			date: quote,
  			regexp: literal,
  			number: literal,
  			"boolean": literal,
  			symbol: function symbol(sym) {
  				return sym.toString();
  			}
  		},

  		// If true, entities are escaped ( <, >, \t, space and \n )
  		HTML: false,

  		// Indentation unit
  		indentChar: "  ",

  		// If true, items in a collection, are separated by a \n, else just a space.
  		multiline: true
  	};

  	return dump;
  })();

  var SuiteReport = function () {
  	function SuiteReport(name, parentSuite) {
  		classCallCheck(this, SuiteReport);

  		this.name = name;
  		this.fullName = parentSuite ? parentSuite.fullName.concat(name) : [];

  		this.tests = [];
  		this.childSuites = [];

  		if (parentSuite) {
  			parentSuite.pushChildSuite(this);
  		}
  	}

  	createClass(SuiteReport, [{
  		key: "start",
  		value: function start(recordTime) {
  			if (recordTime) {
  				this._startTime = performanceNow();

  				if (performance) {
  					var suiteLevel = this.fullName.length;
  					performance.mark("qunit_suite_" + suiteLevel + "_start");
  				}
  			}

  			return {
  				name: this.name,
  				fullName: this.fullName.slice(),
  				tests: this.tests.map(function (test) {
  					return test.start();
  				}),
  				childSuites: this.childSuites.map(function (suite) {
  					return suite.start();
  				}),
  				testCounts: {
  					total: this.getTestCounts().total
  				}
  			};
  		}
  	}, {
  		key: "end",
  		value: function end(recordTime) {
  			if (recordTime) {
  				this._endTime = performanceNow();

  				if (performance) {
  					var suiteLevel = this.fullName.length;
  					performance.mark("qunit_suite_" + suiteLevel + "_end");

  					var suiteName = this.fullName.join("  ");

  					measure(suiteLevel === 0 ? "QUnit Test Run" : "QUnit Test Suite: " + suiteName, "qunit_suite_" + suiteLevel + "_start", "qunit_suite_" + suiteLevel + "_end");
  				}
  			}

  			return {
  				name: this.name,
  				fullName: this.fullName.slice(),
  				tests: this.tests.map(function (test) {
  					return test.end();
  				}),
  				childSuites: this.childSuites.map(function (suite) {
  					return suite.end();
  				}),
  				testCounts: this.getTestCounts(),
  				runtime: this.getRuntime(),
  				status: this.getStatus()
  			};
  		}
  	}, {
  		key: "pushChildSuite",
  		value: function pushChildSuite(suite) {
  			this.childSuites.push(suite);
  		}
  	}, {
  		key: "pushTest",
  		value: function pushTest(test) {
  			this.tests.push(test);
  		}
  	}, {
  		key: "getRuntime",
  		value: function getRuntime() {
  			return this._endTime - this._startTime;
  		}
  	}, {
  		key: "getTestCounts",
  		value: function getTestCounts() {
  			var counts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { passed: 0, failed: 0, skipped: 0, todo: 0, total: 0 };

  			counts = this.tests.reduce(function (counts, test) {
  				if (test.valid) {
  					counts[test.getStatus()]++;
  					counts.total++;
  				}

  				return counts;
  			}, counts);

  			return this.childSuites.reduce(function (counts, suite) {
  				return suite.getTestCounts(counts);
  			}, counts);
  		}
  	}, {
  		key: "getStatus",
  		value: function getStatus() {
  			var _getTestCounts = this.getTestCounts(),
  			    total = _getTestCounts.total,
  			    failed = _getTestCounts.failed,
  			    skipped = _getTestCounts.skipped,
  			    todo = _getTestCounts.todo;

  			if (failed) {
  				return "failed";
  			} else {
  				if (skipped === total) {
  					return "skipped";
  				} else if (todo === total) {
  					return "todo";
  				} else {
  					return "passed";
  				}
  			}
  		}
  	}]);
  	return SuiteReport;
  }();

  var focused = false;

  var moduleStack = [];

  function createModule(name, testEnvironment, modifiers) {
  	var parentModule = moduleStack.length ? moduleStack.slice(-1)[0] : null;
  	var moduleName = parentModule !== null ? [parentModule.name, name].join(" > ") : name;
  	var parentSuite = parentModule ? parentModule.suiteReport : globalSuite;

  	var skip = parentModule !== null && parentModule.skip || modifiers.skip;
  	var todo = parentModule !== null && parentModule.todo || modifiers.todo;

  	var module = {
  		name: moduleName,
  		parentModule: parentModule,
  		tests: [],
  		moduleId: generateHash(moduleName),
  		testsRun: 0,
  		unskippedTestsRun: 0,
  		childModules: [],
  		suiteReport: new SuiteReport(name, parentSuite),

  		// Pass along `skip` and `todo` properties from parent module, in case
  		// there is one, to childs. And use own otherwise.
  		// This property will be used to mark own tests and tests of child suites
  		// as either `skipped` or `todo`.
  		skip: skip,
  		todo: skip ? false : todo
  	};

  	var env = {};
  	if (parentModule) {
  		parentModule.childModules.push(module);
  		extend(env, parentModule.testEnvironment);
  	}
  	extend(env, testEnvironment);
  	module.testEnvironment = env;

  	config.modules.push(module);
  	return module;
  }

  function processModule(name, options, executeNow) {
  	var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  	if (objectType(options) === "function") {
  		executeNow = options;
  		options = undefined;
  	}

  	var module = createModule(name, options, modifiers);

  	// Move any hooks to a 'hooks' object
  	var testEnvironment = module.testEnvironment;
  	var hooks = module.hooks = {};

  	setHookFromEnvironment(hooks, testEnvironment, "before");
  	setHookFromEnvironment(hooks, testEnvironment, "beforeEach");
  	setHookFromEnvironment(hooks, testEnvironment, "afterEach");
  	setHookFromEnvironment(hooks, testEnvironment, "after");

  	var moduleFns = {
  		before: setHookFunction(module, "before"),
  		beforeEach: setHookFunction(module, "beforeEach"),
  		afterEach: setHookFunction(module, "afterEach"),
  		after: setHookFunction(module, "after")
  	};

  	var currentModule = config.currentModule;
  	if (objectType(executeNow) === "function") {
  		moduleStack.push(module);
  		config.currentModule = module;
  		executeNow.call(module.testEnvironment, moduleFns);
  		moduleStack.pop();
  		module = module.parentModule || currentModule;
  	}

  	config.currentModule = module;

  	function setHookFromEnvironment(hooks, environment, name) {
  		var potentialHook = environment[name];
  		hooks[name] = typeof potentialHook === "function" ? [potentialHook] : [];
  		delete environment[name];
  	}

  	function setHookFunction(module, hookName) {
  		return function setHook(callback) {
  			module.hooks[hookName].push(callback);
  		};
  	}
  }

  function module$1(name, options, executeNow) {
  	if (focused) {
  		return;
  	}

  	processModule(name, options, executeNow);
  }

  module$1.only = function () {
  	if (focused) {
  		return;
  	}

  	config.modules.length = 0;
  	config.queue.length = 0;

  	module$1.apply(undefined, arguments);

  	focused = true;
  };

  module$1.skip = function (name, options, executeNow) {
  	if (focused) {
  		return;
  	}

  	processModule(name, options, executeNow, { skip: true });
  };

  module$1.todo = function (name, options, executeNow) {
  	if (focused) {
  		return;
  	}

  	processModule(name, options, executeNow, { todo: true });
  };

  var LISTENERS = Object.create(null);
  var SUPPORTED_EVENTS = ["runStart", "suiteStart", "testStart", "assertion", "testEnd", "suiteEnd", "runEnd"];

  /**
   * Emits an event with the specified data to all currently registered listeners.
   * Callbacks will fire in the order in which they are registered (FIFO). This
   * function is not exposed publicly; it is used by QUnit internals to emit
   * logging events.
   *
   * @private
   * @method emit
   * @param {String} eventName
   * @param {Object} data
   * @return {Void}
   */
  function emit(eventName, data) {
  	if (objectType(eventName) !== "string") {
  		throw new TypeError("eventName must be a string when emitting an event");
  	}

  	// Clone the callbacks in case one of them registers a new callback
  	var originalCallbacks = LISTENERS[eventName];
  	var callbacks = originalCallbacks ? [].concat(toConsumableArray(originalCallbacks)) : [];

  	for (var i = 0; i < callbacks.length; i++) {
  		callbacks[i](data);
  	}
  }

  /**
   * Registers a callback as a listener to the specified event.
   *
   * @public
   * @method on
   * @param {String} eventName
   * @param {Function} callback
   * @return {Void}
   */
  function on(eventName, callback) {
  	if (objectType(eventName) !== "string") {
  		throw new TypeError("eventName must be a string when registering a listener");
  	} else if (!inArray(eventName, SUPPORTED_EVENTS)) {
  		var events = SUPPORTED_EVENTS.join(", ");
  		throw new Error("\"" + eventName + "\" is not a valid event; must be one of: " + events + ".");
  	} else if (objectType(callback) !== "function") {
  		throw new TypeError("callback must be a function when registering a listener");
  	}

  	if (!LISTENERS[eventName]) {
  		LISTENERS[eventName] = [];
  	}

  	// Don't register the same callback more than once
  	if (!inArray(callback, LISTENERS[eventName])) {
  		LISTENERS[eventName].push(callback);
  	}
  }

  function objectOrFunction(x) {
    var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);
    return x !== null && (type === 'object' || type === 'function');
  }

  function isFunction(x) {
    return typeof x === 'function';
  }



  var _isArray = void 0;
  if (Array.isArray) {
    _isArray = Array.isArray;
  } else {
    _isArray = function _isArray(x) {
      return Object.prototype.toString.call(x) === '[object Array]';
    };
  }

  var isArray = _isArray;

  var len = 0;
  var vertxNext = void 0;
  var customSchedulerFn = void 0;

  var asap = function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      // If len is 2, that means that we need to schedule an async flush.
      // If additional callbacks are queued before the queue is flushed, they
      // will be processed by this flush that we are scheduling.
      if (customSchedulerFn) {
        customSchedulerFn(flush);
      } else {
        scheduleFlush();
      }
    }
  };

  function setScheduler(scheduleFn) {
    customSchedulerFn = scheduleFn;
  }

  function setAsap(asapFn) {
    asap = asapFn;
  }

  var browserWindow = typeof window !== 'undefined' ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

  // test for web worker but not in IE10
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

  // node
  function useNextTick() {
    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
    // see https://github.com/cujojs/when/issues/410 for details
    return function () {
      return process.nextTick(flush);
    };
  }

  // vertx
  function useVertxTimer() {
    if (typeof vertxNext !== 'undefined') {
      return function () {
        vertxNext(flush);
      };
    }

    return useSetTimeout();
  }

  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, { characterData: true });

    return function () {
      node.data = iterations = ++iterations % 2;
    };
  }

  // web worker
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function () {
      return channel.port2.postMessage(0);
    };
  }

  function useSetTimeout() {
    // Store setTimeout reference so es6-promise will be unaffected by
    // other code modifying setTimeout (like sinon.useFakeTimers())
    var globalSetTimeout = setTimeout;
    return function () {
      return globalSetTimeout(flush, 1);
    };
  }

  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];

      callback(arg);

      queue[i] = undefined;
      queue[i + 1] = undefined;
    }

    len = 0;
  }

  function attemptVertx() {
    try {
      var vertx = Function('return this')().require('vertx');
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }

  var scheduleFlush = void 0;
  // Decide what async method to use to triggering processing of queued callbacks:
  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && typeof commonjsRequire === 'function') {
    scheduleFlush = attemptVertx();
  } else {
    scheduleFlush = useSetTimeout();
  }

  function then(onFulfillment, onRejection) {
    var parent = this;

    var child = new this.constructor(noop);

    if (child[PROMISE_ID] === undefined) {
      makePromise(child);
    }

    var _state = parent._state;


    if (_state) {
      var callback = arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    } else {
      subscribe(parent, child, onFulfillment, onRejection);
    }

    return child;
  }

  /**
    `Promise.resolve` returns a promise that will become resolved with the
    passed `value`. It is shorthand for the following:

    ```javascript
    let promise = new Promise(function(resolve, reject){
      resolve(1);
    });

    promise.then(function(value){
      // value === 1
    });
    ```

    Instead of writing the above, your code now simply becomes the following:

    ```javascript
    let promise = Promise.resolve(1);

    promise.then(function(value){
      // value === 1
    });
    ```

    @method resolve
    @static
    @param {Any} value value that the returned promise will be resolved with
    Useful for tooling.
    @return {Promise} a promise that will become fulfilled with the given
    `value`
  */
  function resolve$1(object) {
    /*jshint validthis:true */
    var Constructor = this;

    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
      return object;
    }

    var promise = new Constructor(noop);
    resolve(promise, object);
    return promise;
  }

  var PROMISE_ID = Math.random().toString(36).substring(2);

  function noop() {}

  var PENDING = void 0;
  var FULFILLED = 1;
  var REJECTED = 2;

  function selfFulfillment() {
    return new TypeError("You cannot resolve a promise with itself");
  }

  function cannotReturnOwn() {
    return new TypeError('A promises callback cannot return that same promise.');
  }

  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
    try {
      then$$1.call(value, fulfillmentHandler, rejectionHandler);
    } catch (e) {
      return e;
    }
  }

  function handleForeignThenable(promise, thenable, then$$1) {
    asap(function (promise) {
      var sealed = false;
      var error = tryThen(then$$1, thenable, function (value) {
        if (sealed) {
          return;
        }
        sealed = true;
        if (thenable !== value) {
          resolve(promise, value);
        } else {
          fulfill(promise, value);
        }
      }, function (reason) {
        if (sealed) {
          return;
        }
        sealed = true;

        reject(promise, reason);
      }, 'Settle: ' + (promise._label || ' unknown promise'));

      if (!sealed && error) {
        sealed = true;
        reject(promise, error);
      }
    }, promise);
  }

  function handleOwnThenable(promise, thenable) {
    if (thenable._state === FULFILLED) {
      fulfill(promise, thenable._result);
    } else if (thenable._state === REJECTED) {
      reject(promise, thenable._result);
    } else {
      subscribe(thenable, undefined, function (value) {
        return resolve(promise, value);
      }, function (reason) {
        return reject(promise, reason);
      });
    }
  }

  function handleMaybeThenable(promise, maybeThenable, then$$1) {
    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
      handleOwnThenable(promise, maybeThenable);
    } else {
      if (then$$1 === undefined) {
        fulfill(promise, maybeThenable);
      } else if (isFunction(then$$1)) {
        handleForeignThenable(promise, maybeThenable, then$$1);
      } else {
        fulfill(promise, maybeThenable);
      }
    }
  }

  function resolve(promise, value) {
    if (promise === value) {
      reject(promise, selfFulfillment());
    } else if (objectOrFunction(value)) {
      var then$$1 = void 0;
      try {
        then$$1 = value.then;
      } catch (error) {
        reject(promise, error);
        return;
      }
      handleMaybeThenable(promise, value, then$$1);
    } else {
      fulfill(promise, value);
    }
  }

  function publishRejection(promise) {
    if (promise._onerror) {
      promise._onerror(promise._result);
    }

    publish(promise);
  }

  function fulfill(promise, value) {
    if (promise._state !== PENDING) {
      return;
    }

    promise._result = value;
    promise._state = FULFILLED;

    if (promise._subscribers.length !== 0) {
      asap(publish, promise);
    }
  }

  function reject(promise, reason) {
    if (promise._state !== PENDING) {
      return;
    }
    promise._state = REJECTED;
    promise._result = reason;

    asap(publishRejection, promise);
  }

  function subscribe(parent, child, onFulfillment, onRejection) {
    var _subscribers = parent._subscribers;
    var length = _subscribers.length;


    parent._onerror = null;

    _subscribers[length] = child;
    _subscribers[length + FULFILLED] = onFulfillment;
    _subscribers[length + REJECTED] = onRejection;

    if (length === 0 && parent._state) {
      asap(publish, parent);
    }
  }

  function publish(promise) {
    var subscribers = promise._subscribers;
    var settled = promise._state;

    if (subscribers.length === 0) {
      return;
    }

    var child = void 0,
        callback = void 0,
        detail = promise._result;

    for (var i = 0; i < subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];

      if (child) {
        invokeCallback(settled, child, callback, detail);
      } else {
        callback(detail);
      }
    }

    promise._subscribers.length = 0;
  }

  function invokeCallback(settled, promise, callback, detail) {
    var hasCallback = isFunction(callback),
        value = void 0,
        error = void 0,
        succeeded = true;

    if (hasCallback) {
      try {
        value = callback(detail);
      } catch (e) {
        succeeded = false;
        error = e;
      }

      if (promise === value) {
        reject(promise, cannotReturnOwn());
        return;
      }
    } else {
      value = detail;
    }

    if (promise._state !== PENDING) ; else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (succeeded === false) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
  }

  function initializePromise(promise, resolver) {
    try {
      resolver(function resolvePromise(value) {
        resolve(promise, value);
      }, function rejectPromise(reason) {
        reject(promise, reason);
      });
    } catch (e) {
      reject(promise, e);
    }
  }

  var id = 0;
  function nextId() {
    return id++;
  }

  function makePromise(promise) {
    promise[PROMISE_ID] = id++;
    promise._state = undefined;
    promise._result = undefined;
    promise._subscribers = [];
  }

  function validationError() {
    return new Error('Array Methods must be provided an Array');
  }

  var Enumerator = function () {
    function Enumerator(Constructor, input) {
      classCallCheck(this, Enumerator);

      this._instanceConstructor = Constructor;
      this.promise = new Constructor(noop);

      if (!this.promise[PROMISE_ID]) {
        makePromise(this.promise);
      }

      if (isArray(input)) {
        this.length = input.length;
        this._remaining = input.length;

        this._result = new Array(this.length);

        if (this.length === 0) {
          fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate(input);
          if (this._remaining === 0) {
            fulfill(this.promise, this._result);
          }
        }
      } else {
        reject(this.promise, validationError());
      }
    }

    createClass(Enumerator, [{
      key: '_enumerate',
      value: function _enumerate(input) {
        for (var i = 0; this._state === PENDING && i < input.length; i++) {
          this._eachEntry(input[i], i);
        }
      }
    }, {
      key: '_eachEntry',
      value: function _eachEntry(entry, i) {
        var c = this._instanceConstructor;
        var resolve$$1 = c.resolve;


        if (resolve$$1 === resolve$1) {
          var _then = void 0;
          var error = void 0;
          var didError = false;
          try {
            _then = entry.then;
          } catch (e) {
            didError = true;
            error = e;
          }

          if (_then === then && entry._state !== PENDING) {
            this._settledAt(entry._state, i, entry._result);
          } else if (typeof _then !== 'function') {
            this._remaining--;
            this._result[i] = entry;
          } else if (c === Promise$2) {
            var promise = new c(noop);
            if (didError) {
              reject(promise, error);
            } else {
              handleMaybeThenable(promise, entry, _then);
            }
            this._willSettleAt(promise, i);
          } else {
            this._willSettleAt(new c(function (resolve$$1) {
              return resolve$$1(entry);
            }), i);
          }
        } else {
          this._willSettleAt(resolve$$1(entry), i);
        }
      }
    }, {
      key: '_settledAt',
      value: function _settledAt(state, i, value) {
        var promise = this.promise;


        if (promise._state === PENDING) {
          this._remaining--;

          if (state === REJECTED) {
            reject(promise, value);
          } else {
            this._result[i] = value;
          }
        }

        if (this._remaining === 0) {
          fulfill(promise, this._result);
        }
      }
    }, {
      key: '_willSettleAt',
      value: function _willSettleAt(promise, i) {
        var enumerator = this;

        subscribe(promise, undefined, function (value) {
          return enumerator._settledAt(FULFILLED, i, value);
        }, function (reason) {
          return enumerator._settledAt(REJECTED, i, reason);
        });
      }
    }]);
    return Enumerator;
  }();

  /**
    `Promise.all` accepts an array of promises, and returns a new promise which
    is fulfilled with an array of fulfillment values for the passed promises, or
    rejected with the reason of the first passed promise to be rejected. It casts all
    elements of the passed iterable to promises as it runs this algorithm.

    Example:

    ```javascript
    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);
    let promises = [ promise1, promise2, promise3 ];

    Promise.all(promises).then(function(array){
      // The array here would be [ 1, 2, 3 ];
    });
    ```

    If any of the `promises` given to `all` are rejected, the first promise
    that is rejected will be given as an argument to the returned promises's
    rejection handler. For example:

    Example:

    ```javascript
    let promise1 = resolve(1);
    let promise2 = reject(new Error("2"));
    let promise3 = reject(new Error("3"));
    let promises = [ promise1, promise2, promise3 ];

    Promise.all(promises).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(error) {
      // error.message === "2"
    });
    ```

    @method all
    @static
    @param {Array} entries array of promises
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when all `promises` have been
    fulfilled, or rejected if any of them become rejected.
    @static
  */
  function all(entries) {
    return new Enumerator(this, entries).promise;
  }

  /**
    `Promise.race` returns a new promise which is settled in the same way as the
    first passed promise to settle.

    Example:

    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });

    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 2');
      }, 100);
    });

    Promise.race([promise1, promise2]).then(function(result){
      // result === 'promise 2' because it was resolved before promise1
      // was resolved.
    });
    ```

    `Promise.race` is deterministic in that only the state of the first
    settled promise matters. For example, even if other promises given to the
    `promises` array argument are resolved, but the first settled promise has
    become rejected before the other promises became fulfilled, the returned
    promise will become rejected:

    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });

    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        reject(new Error('promise 2'));
      }, 100);
    });

    Promise.race([promise1, promise2]).then(function(result){
      // Code here never runs
    }, function(reason){
      // reason.message === 'promise 2' because promise 2 became rejected before
      // promise 1 became fulfilled
    });
    ```

    An example real-world use case is implementing timeouts:

    ```javascript
    Promise.race([ajax('foo.json'), timeout(5000)])
    ```

    @method race
    @static
    @param {Array} promises array of promises to observe
    Useful for tooling.
    @return {Promise} a promise which settles in the same way as the first passed
    promise to settle.
  */
  function race(entries) {
    /*jshint validthis:true */
    var Constructor = this;

    if (!isArray(entries)) {
      return new Constructor(function (_, reject) {
        return reject(new TypeError('You must pass an array to race.'));
      });
    } else {
      return new Constructor(function (resolve, reject) {
        var length = entries.length;
        for (var i = 0; i < length; i++) {
          Constructor.resolve(entries[i]).then(resolve, reject);
        }
      });
    }
  }

  /**
    `Promise.reject` returns a promise rejected with the passed `reason`.
    It is shorthand for the following:

    ```javascript
    let promise = new Promise(function(resolve, reject){
      reject(new Error('WHOOPS'));
    });

    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```

    Instead of writing the above, your code now simply becomes the following:

    ```javascript
    let promise = Promise.reject(new Error('WHOOPS'));

    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```

    @method reject
    @static
    @param {Any} reason value that the returned promise will be rejected with.
    Useful for tooling.
    @return {Promise} a promise rejected with the given `reason`.
  */
  function reject$1(reason) {
    /*jshint validthis:true */
    var Constructor = this;
    var promise = new Constructor(noop);
    reject(promise, reason);
    return promise;
  }

  function needsResolver() {
    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
  }

  function needsNew() {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }

  /**
    Promise objects represent the eventual result of an asynchronous operation. The
    primary way of interacting with a promise is through its `then` method, which
    registers callbacks to receive either a promise's eventual value or the reason
    why the promise cannot be fulfilled.

    Terminology
    -----------

    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
    - `thenable` is an object or function that defines a `then` method.
    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
    - `exception` is a value that is thrown using the throw statement.
    - `reason` is a value that indicates why a promise was rejected.
    - `settled` the final resting state of a promise, fulfilled or rejected.

    A promise can be in one of three states: pending, fulfilled, or rejected.

    Promises that are fulfilled have a fulfillment value and are in the fulfilled
    state.  Promises that are rejected have a rejection reason and are in the
    rejected state.  A fulfillment value is never a thenable.

    Promises can also be said to *resolve* a value.  If this value is also a
    promise, then the original promise's settled state will match the value's
    settled state.  So a promise that *resolves* a promise that rejects will
    itself reject, and a promise that *resolves* a promise that fulfills will
    itself fulfill.


    Basic Usage:
    ------------

    ```js
    let promise = new Promise(function(resolve, reject) {
      // on success
      resolve(value);

      // on failure
      reject(reason);
    });

    promise.then(function(value) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```

    Advanced Usage:
    ---------------

    Promises shine when abstracting away asynchronous interactions such as
    `XMLHttpRequest`s.

    ```js
    function getJSON(url) {
      return new Promise(function(resolve, reject){
        let xhr = new XMLHttpRequest();

        xhr.open('GET', url);
        xhr.onreadystatechange = handler;
        xhr.responseType = 'json';
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.send();

        function handler() {
          if (this.readyState === this.DONE) {
            if (this.status === 200) {
              resolve(this.response);
            } else {
              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
            }
          }
        };
      });
    }

    getJSON('/posts.json').then(function(json) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```

    Unlike callbacks, promises are great composable primitives.

    ```js
    Promise.all([
      getJSON('/posts'),
      getJSON('/comments')
    ]).then(function(values){
      values[0] // => postsJSON
      values[1] // => commentsJSON

      return values;
    });
    ```

    @class Promise
    @param {Function} resolver
    Useful for tooling.
    @constructor
  */

  var Promise$2 = function () {
    function Promise(resolver) {
      classCallCheck(this, Promise);

      this[PROMISE_ID] = nextId();
      this._result = this._state = undefined;
      this._subscribers = [];

      if (noop !== resolver) {
        typeof resolver !== 'function' && needsResolver();
        this instanceof Promise ? initializePromise(this, resolver) : needsNew();
      }
    }

    /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
     ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
     Chaining
    --------
     The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
     ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
     findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
     ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
     Assimilation
    ------------
     Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
     ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
     If the assimliated promise rejects, then the downstream promise will also reject.
     ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
     Simple Example
    --------------
     Synchronous Example
     ```javascript
    let result;
     try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
     Errback Example
     ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
     Promise Example;
     ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
     Advanced Example
    --------------
     Synchronous Example
     ```javascript
    let author, books;
     try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
     Errback Example
     ```js
     function foundBooks(books) {
     }
     function failure(reason) {
     }
     findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
     Promise Example;
     ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
     @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
    */

    /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
    ```js
    function findAuthor(){
    throw new Error('couldn't find that author');
    }
    // synchronous
    try {
    findAuthor();
    } catch(reason) {
    // something went wrong
    }
    // async with promises
    findAuthor().catch(function(reason){
    // something went wrong
    });
    ```
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
    */


    createClass(Promise, [{
      key: 'catch',
      value: function _catch(onRejection) {
        return this.then(null, onRejection);
      }

      /**
        `finally` will be invoked regardless of the promise's fate just as native
        try/catch/finally behaves
      
        Synchronous example:
      
        ```js
        findAuthor() {
          if (Math.random() > 0.5) {
            throw new Error();
          }
          return new Author();
        }
      
        try {
          return findAuthor(); // succeed or fail
        } catch(error) {
          return findOtherAuther();
        } finally {
          // always runs
          // doesn't affect the return value
        }
        ```
      
        Asynchronous example:
      
        ```js
        findAuthor().catch(function(reason){
          return findOtherAuther();
        }).finally(function(){
          // author was either found, or not
        });
        ```
      
        @method finally
        @param {Function} callback
        @return {Promise}
      */

    }, {
      key: 'finally',
      value: function _finally(callback) {
        var promise = this;
        var constructor = promise.constructor;

        if (isFunction(callback)) {
          return promise.then(function (value) {
            return constructor.resolve(callback()).then(function () {
              return value;
            });
          }, function (reason) {
            return constructor.resolve(callback()).then(function () {
              throw reason;
            });
          });
        }

        return promise.then(callback, callback);
      }
    }]);
    return Promise;
  }();

  Promise$2.prototype.then = then;
  Promise$2.all = all;
  Promise$2.race = race;
  Promise$2.resolve = resolve$1;
  Promise$2.reject = reject$1;
  Promise$2._setScheduler = setScheduler;
  Promise$2._setAsap = setAsap;
  Promise$2._asap = asap;

  /*global self*/
  function polyfill() {
    var local = void 0;

    if (typeof commonjsGlobal !== 'undefined') {
      local = commonjsGlobal;
    } else if (typeof self !== 'undefined') {
      local = self;
    } else {
      try {
        local = Function('return this')();
      } catch (e) {
        throw new Error('polyfill failed because global object is unavailable in this environment');
      }
    }

    var P = local.Promise;

    if (P) {
      var promiseToString = null;
      try {
        promiseToString = Object.prototype.toString.call(P.resolve());
      } catch (e) {
        // silently ignored
      }

      if (promiseToString === '[object Promise]' && !P.cast) {
        return;
      }
    }

    local.Promise = Promise$2;
  }

  // Strange compat..
  Promise$2.polyfill = polyfill;
  Promise$2.Promise = Promise$2;

  var Promise$1 = typeof Promise !== "undefined" ? Promise : Promise$2;

  // Register logging callbacks
  function registerLoggingCallbacks(obj) {
  	var i,
  	    l,
  	    key,
  	    callbackNames = ["begin", "done", "log", "testStart", "testDone", "moduleStart", "moduleDone"];

  	function registerLoggingCallback(key) {
  		var loggingCallback = function loggingCallback(callback) {
  			if (objectType(callback) !== "function") {
  				throw new Error("QUnit logging methods require a callback function as their first parameters.");
  			}

  			config.callbacks[key].push(callback);
  		};

  		return loggingCallback;
  	}

  	for (i = 0, l = callbackNames.length; i < l; i++) {
  		key = callbackNames[i];

  		// Initialize key collection of logging callback
  		if (objectType(config.callbacks[key]) === "undefined") {
  			config.callbacks[key] = [];
  		}

  		obj[key] = registerLoggingCallback(key);
  	}
  }

  function runLoggingCallbacks(key, args) {
  	var callbacks = config.callbacks[key];

  	// Handling 'log' callbacks separately. Unlike the other callbacks,
  	// the log callback is not controlled by the processing queue,
  	// but rather used by asserts. Hence to promisfy the 'log' callback
  	// would mean promisfying each step of a test
  	if (key === "log") {
  		callbacks.map(function (callback) {
  			return callback(args);
  		});
  		return;
  	}

  	// ensure that each callback is executed serially
  	return callbacks.reduce(function (promiseChain, callback) {
  		return promiseChain.then(function () {
  			return Promise$1.resolve(callback(args));
  		});
  	}, Promise$1.resolve([]));
  }

  // Doesn't support IE9, it will return undefined on these browsers
  // See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack
  var fileName = (sourceFromStacktrace(0) || "").replace(/(:\d+)+\)?/, "").replace(/.+\//, "");

  function extractStacktrace(e, offset) {
  	offset = offset === undefined ? 4 : offset;

  	var stack, include, i;

  	if (e && e.stack) {
  		stack = e.stack.split("\n");
  		if (/^error$/i.test(stack[0])) {
  			stack.shift();
  		}
  		if (fileName) {
  			include = [];
  			for (i = offset; i < stack.length; i++) {
  				if (stack[i].indexOf(fileName) !== -1) {
  					break;
  				}
  				include.push(stack[i]);
  			}
  			if (include.length) {
  				return include.join("\n");
  			}
  		}
  		return stack[offset];
  	}
  }

  function sourceFromStacktrace(offset) {
  	var error = new Error();

  	// Support: Safari <=7 only, IE <=10 - 11 only
  	// Not all browsers generate the `stack` property for `new Error()`, see also #636
  	if (!error.stack) {
  		try {
  			throw error;
  		} catch (err) {
  			error = err;
  		}
  	}

  	return extractStacktrace(error, offset);
  }

  var priorityCount = 0;
  var unitSampler = void 0;

  // This is a queue of functions that are tasks within a single test.
  // After tests are dequeued from config.queue they are expanded into
  // a set of tasks in this queue.
  var taskQueue = [];

  /**
   * Advances the taskQueue to the next task. If the taskQueue is empty,
   * process the testQueue
   */
  function advance() {
  	advanceTaskQueue();

  	if (!taskQueue.length && !config.blocking && !config.current) {
  		advanceTestQueue();
  	}
  }

  /**
   * Advances the taskQueue with an increased depth
   */
  function advanceTaskQueue() {
  	var start = now();
  	config.depth = (config.depth || 0) + 1;

  	processTaskQueue(start);

  	config.depth--;
  }

  /**
   * Process the first task on the taskQueue as a promise.
   * Each task is a function returned by https://github.com/qunitjs/qunit/blob/master/src/test.js#L381
   */
  function processTaskQueue(start) {
  	if (taskQueue.length && !config.blocking) {
  		var elapsedTime = now() - start;

  		if (!defined.setTimeout || config.updateRate <= 0 || elapsedTime < config.updateRate) {
  			var task = taskQueue.shift();
  			Promise$1.resolve(task()).then(function () {
  				if (!taskQueue.length) {
  					advance();
  				} else {
  					processTaskQueue(start);
  				}
  			});
  		} else {
  			setTimeout$1(advance);
  		}
  	}
  }

  /**
   * Advance the testQueue to the next test to process. Call done() if testQueue completes.
   */
  function advanceTestQueue() {
  	if (!config.blocking && !config.queue.length && config.depth === 0) {
  		done();
  		return;
  	}

  	var testTasks = config.queue.shift();
  	addToTaskQueue(testTasks());

  	if (priorityCount > 0) {
  		priorityCount--;
  	}

  	advance();
  }

  /**
   * Enqueue the tasks for a test into the task queue.
   * @param {Array} tasksArray
   */
  function addToTaskQueue(tasksArray) {
  	taskQueue.push.apply(taskQueue, toConsumableArray(tasksArray));
  }

  /**
   * Return the number of tasks remaining in the task queue to be processed.
   * @return {Number}
   */
  function taskQueueLength() {
  	return taskQueue.length;
  }

  /**
   * Adds a test to the TestQueue for execution.
   * @param {Function} testTasksFunc
   * @param {Boolean} prioritize
   * @param {String} seed
   */
  function addToTestQueue(testTasksFunc, prioritize, seed) {
  	if (prioritize) {
  		config.queue.splice(priorityCount++, 0, testTasksFunc);
  	} else if (seed) {
  		if (!unitSampler) {
  			unitSampler = unitSamplerGenerator(seed);
  		}

  		// Insert into a random position after all prioritized items
  		var index = Math.floor(unitSampler() * (config.queue.length - priorityCount + 1));
  		config.queue.splice(priorityCount + index, 0, testTasksFunc);
  	} else {
  		config.queue.push(testTasksFunc);
  	}
  }

  /**
   * Creates a seeded "sample" generator which is used for randomizing tests.
   */
  function unitSamplerGenerator(seed) {

  	// 32-bit xorshift, requires only a nonzero seed
  	// http://excamera.com/sphinx/article-xorshift.html
  	var sample = parseInt(generateHash(seed), 16) || -1;
  	return function () {
  		sample ^= sample << 13;
  		sample ^= sample >>> 17;
  		sample ^= sample << 5;

  		// ECMAScript has no unsigned number type
  		if (sample < 0) {
  			sample += 0x100000000;
  		}

  		return sample / 0x100000000;
  	};
  }

  /**
   * This function is called when the ProcessingQueue is done processing all
   * items. It handles emitting the final run events.
   */
  function done() {
  	var storage = config.storage;

  	ProcessingQueue.finished = true;

  	var runtime = now() - config.started;
  	var passed = config.stats.all - config.stats.bad;

  	if (config.stats.all === 0) {

  		if (config.filter && config.filter.length) {
  			throw new Error("No tests matched the filter \"" + config.filter + "\".");
  		}

  		if (config.module && config.module.length) {
  			throw new Error("No tests matched the module \"" + config.module + "\".");
  		}

  		if (config.moduleId && config.moduleId.length) {
  			throw new Error("No tests matched the moduleId \"" + config.moduleId + "\".");
  		}

  		if (config.testId && config.testId.length) {
  			throw new Error("No tests matched the testId \"" + config.testId + "\".");
  		}

  		throw new Error("No tests were run.");
  	}

  	emit("runEnd", globalSuite.end(true));
  	runLoggingCallbacks("done", {
  		passed: passed,
  		failed: config.stats.bad,
  		total: config.stats.all,
  		runtime: runtime
  	}).then(function () {

  		// Clear own storage items if all tests passed
  		if (storage && config.stats.bad === 0) {
  			for (var i = storage.length - 1; i >= 0; i--) {
  				var key = storage.key(i);

  				if (key.indexOf("qunit-test-") === 0) {
  					storage.removeItem(key);
  				}
  			}
  		}
  	});
  }

  var ProcessingQueue = {
  	finished: false,
  	add: addToTestQueue,
  	advance: advance,
  	taskCount: taskQueueLength
  };

  var TestReport = function () {
  	function TestReport(name, suite, options) {
  		classCallCheck(this, TestReport);

  		this.name = name;
  		this.suiteName = suite.name;
  		this.fullName = suite.fullName.concat(name);
  		this.runtime = 0;
  		this.assertions = [];

  		this.skipped = !!options.skip;
  		this.todo = !!options.todo;

  		this.valid = options.valid;

  		this._startTime = 0;
  		this._endTime = 0;

  		suite.pushTest(this);
  	}

  	createClass(TestReport, [{
  		key: "start",
  		value: function start(recordTime) {
  			if (recordTime) {
  				this._startTime = performanceNow();
  				if (performance) {
  					performance.mark("qunit_test_start");
  				}
  			}

  			return {
  				name: this.name,
  				suiteName: this.suiteName,
  				fullName: this.fullName.slice()
  			};
  		}
  	}, {
  		key: "end",
  		value: function end(recordTime) {
  			if (recordTime) {
  				this._endTime = performanceNow();
  				if (performance) {
  					performance.mark("qunit_test_end");

  					var testName = this.fullName.join("  ");

  					measure("QUnit Test: " + testName, "qunit_test_start", "qunit_test_end");
  				}
  			}

  			return extend(this.start(), {
  				runtime: this.getRuntime(),
  				status: this.getStatus(),
  				errors: this.getFailedAssertions(),
  				assertions: this.getAssertions()
  			});
  		}
  	}, {
  		key: "pushAssertion",
  		value: function pushAssertion(assertion) {
  			this.assertions.push(assertion);
  		}
  	}, {
  		key: "getRuntime",
  		value: function getRuntime() {
  			return this._endTime - this._startTime;
  		}
  	}, {
  		key: "getStatus",
  		value: function getStatus() {
  			if (this.skipped) {
  				return "skipped";
  			}

  			var testPassed = this.getFailedAssertions().length > 0 ? this.todo : !this.todo;

  			if (!testPassed) {
  				return "failed";
  			} else if (this.todo) {
  				return "todo";
  			} else {
  				return "passed";
  			}
  		}
  	}, {
  		key: "getFailedAssertions",
  		value: function getFailedAssertions() {
  			return this.assertions.filter(function (assertion) {
  				return !assertion.passed;
  			});
  		}
  	}, {
  		key: "getAssertions",
  		value: function getAssertions() {
  			return this.assertions.slice();
  		}

  		// Remove actual and expected values from assertions. This is to prevent
  		// leaking memory throughout a test suite.

  	}, {
  		key: "slimAssertions",
  		value: function slimAssertions() {
  			this.assertions = this.assertions.map(function (assertion) {
  				delete assertion.actual;
  				delete assertion.expected;
  				return assertion;
  			});
  		}
  	}]);
  	return TestReport;
  }();

  var focused$1 = false;

  function Test(settings) {
  	var i, l;

  	++Test.count;

  	this.expected = null;
  	this.assertions = [];
  	this.semaphore = 0;
  	this.module = config.currentModule;
  	this.steps = [];
  	this.timeout = undefined;
  	this.errorForStack = new Error();

  	// If a module is skipped, all its tests and the tests of the child suites
  	// should be treated as skipped even if they are defined as `only` or `todo`.
  	// As for `todo` module, all its tests will be treated as `todo` except for
  	// tests defined as `skip` which will be left intact.
  	//
  	// So, if a test is defined as `todo` and is inside a skipped module, we should
  	// then treat that test as if was defined as `skip`.
  	if (this.module.skip) {
  		settings.skip = true;
  		settings.todo = false;

  		// Skipped tests should be left intact
  	} else if (this.module.todo && !settings.skip) {
  		settings.todo = true;
  	}

  	extend(this, settings);

  	this.testReport = new TestReport(settings.testName, this.module.suiteReport, {
  		todo: settings.todo,
  		skip: settings.skip,
  		valid: this.valid()
  	});

  	// Register unique strings
  	for (i = 0, l = this.module.tests; i < l.length; i++) {
  		if (this.module.tests[i].name === this.testName) {
  			this.testName += " ";
  		}
  	}

  	this.testId = generateHash(this.module.name, this.testName);

  	this.module.tests.push({
  		name: this.testName,
  		testId: this.testId,
  		skip: !!settings.skip
  	});

  	if (settings.skip) {

  		// Skipped tests will fully ignore any sent callback
  		this.callback = function () {};
  		this.async = false;
  		this.expected = 0;
  	} else {
  		if (typeof this.callback !== "function") {
  			var method = this.todo ? "todo" : "test";

  			// eslint-disable-next-line max-len
  			throw new TypeError("You must provide a function as a test callback to QUnit." + method + "(\"" + settings.testName + "\")");
  		}

  		this.assert = new Assert(this);
  	}
  }

  Test.count = 0;

  function getNotStartedModules(startModule) {
  	var module = startModule,
  	    modules = [];

  	while (module && module.testsRun === 0) {
  		modules.push(module);
  		module = module.parentModule;
  	}

  	// The above push modules from the child to the parent
  	// return a reversed order with the top being the top most parent module
  	return modules.reverse();
  }

  Test.prototype = {

  	// generating a stack trace can be expensive, so using a getter defers this until we need it
  	get stack() {
  		return extractStacktrace(this.errorForStack, 2);
  	},

  	before: function before() {
  		var _this = this;

  		var module = this.module,
  		    notStartedModules = getNotStartedModules(module);

  		// ensure the callbacks are executed serially for each module
  		var callbackPromises = notStartedModules.reduce(function (promiseChain, startModule) {
  			return promiseChain.then(function () {
  				startModule.stats = { all: 0, bad: 0, started: now() };
  				emit("suiteStart", startModule.suiteReport.start(true));
  				return runLoggingCallbacks("moduleStart", {
  					name: startModule.name,
  					tests: startModule.tests
  				});
  			});
  		}, Promise$1.resolve([]));

  		return callbackPromises.then(function () {
  			config.current = _this;

  			_this.testEnvironment = extend({}, module.testEnvironment);

  			_this.started = now();
  			emit("testStart", _this.testReport.start(true));
  			return runLoggingCallbacks("testStart", {
  				name: _this.testName,
  				module: module.name,
  				testId: _this.testId,
  				previousFailure: _this.previousFailure
  			}).then(function () {
  				if (!config.pollution) {
  					saveGlobal();
  				}
  			});
  		});
  	},

  	run: function run() {
  		var promise;

  		config.current = this;

  		this.callbackStarted = now();

  		if (config.notrycatch) {
  			runTest(this);
  			return;
  		}

  		try {
  			runTest(this);
  		} catch (e) {
  			this.pushFailure("Died on test #" + (this.assertions.length + 1) + " " + this.stack + ": " + (e.message || e), extractStacktrace(e, 0));

  			// Else next test will carry the responsibility
  			saveGlobal();

  			// Restart the tests if they're blocking
  			if (config.blocking) {
  				internalRecover(this);
  			}
  		}

  		function runTest(test) {
  			promise = test.callback.call(test.testEnvironment, test.assert);
  			test.resolvePromise(promise);

  			// If the test has a "lock" on it, but the timeout is 0, then we push a
  			// failure as the test should be synchronous.
  			if (test.timeout === 0 && test.semaphore !== 0) {
  				pushFailure("Test did not finish synchronously even though assert.timeout( 0 ) was used.", sourceFromStacktrace(2));
  			}
  		}
  	},

  	after: function after() {
  		checkPollution();
  	},

  	queueHook: function queueHook(hook, hookName, hookOwner) {
  		var _this2 = this;

  		var callHook = function callHook() {
  			var promise = hook.call(_this2.testEnvironment, _this2.assert);
  			_this2.resolvePromise(promise, hookName);
  		};

  		var runHook = function runHook() {
  			if (hookName === "before") {
  				if (hookOwner.unskippedTestsRun !== 0) {
  					return;
  				}

  				_this2.preserveEnvironment = true;
  			}

  			// The 'after' hook should only execute when there are not tests left and
  			// when the 'after' and 'finish' tasks are the only tasks left to process
  			if (hookName === "after" && hookOwner.unskippedTestsRun !== numberOfUnskippedTests(hookOwner) - 1 && (config.queue.length > 0 || ProcessingQueue.taskCount() > 2)) {
  				return;
  			}

  			config.current = _this2;
  			if (config.notrycatch) {
  				callHook();
  				return;
  			}
  			try {
  				callHook();
  			} catch (error) {
  				_this2.pushFailure(hookName + " failed on " + _this2.testName + ": " + (error.message || error), extractStacktrace(error, 0));
  			}
  		};

  		return runHook;
  	},


  	// Currently only used for module level hooks, can be used to add global level ones
  	hooks: function hooks(handler) {
  		var hooks = [];

  		function processHooks(test, module) {
  			if (module.parentModule) {
  				processHooks(test, module.parentModule);
  			}

  			if (module.hooks[handler].length) {
  				for (var i = 0; i < module.hooks[handler].length; i++) {
  					hooks.push(test.queueHook(module.hooks[handler][i], handler, module));
  				}
  			}
  		}

  		// Hooks are ignored on skipped tests
  		if (!this.skip) {
  			processHooks(this, this.module);
  		}

  		return hooks;
  	},


  	finish: function finish() {
  		config.current = this;

  		// Release the test callback to ensure that anything referenced has been
  		// released to be garbage collected.
  		this.callback = undefined;

  		if (this.steps.length) {
  			var stepsList = this.steps.join(", ");
  			this.pushFailure("Expected assert.verifySteps() to be called before end of test " + ("after using assert.step(). Unverified steps: " + stepsList), this.stack);
  		}

  		if (config.requireExpects && this.expected === null) {
  			this.pushFailure("Expected number of assertions to be defined, but expect() was " + "not called.", this.stack);
  		} else if (this.expected !== null && this.expected !== this.assertions.length) {
  			this.pushFailure("Expected " + this.expected + " assertions, but " + this.assertions.length + " were run", this.stack);
  		} else if (this.expected === null && !this.assertions.length) {
  			this.pushFailure("Expected at least one assertion, but none were run - call " + "expect(0) to accept zero assertions.", this.stack);
  		}

  		var i,
  		    module = this.module,
  		    moduleName = module.name,
  		    testName = this.testName,
  		    skipped = !!this.skip,
  		    todo = !!this.todo,
  		    bad = 0,
  		    storage = config.storage;

  		this.runtime = now() - this.started;

  		config.stats.all += this.assertions.length;
  		module.stats.all += this.assertions.length;

  		for (i = 0; i < this.assertions.length; i++) {
  			if (!this.assertions[i].result) {
  				bad++;
  				config.stats.bad++;
  				module.stats.bad++;
  			}
  		}

  		notifyTestsRan(module, skipped);

  		// Store result when possible
  		if (storage) {
  			if (bad) {
  				storage.setItem("qunit-test-" + moduleName + "-" + testName, bad);
  			} else {
  				storage.removeItem("qunit-test-" + moduleName + "-" + testName);
  			}
  		}

  		// After emitting the js-reporters event we cleanup the assertion data to
  		// avoid leaking it. It is not used by the legacy testDone callbacks.
  		emit("testEnd", this.testReport.end(true));
  		this.testReport.slimAssertions();
  		var test = this;

  		return runLoggingCallbacks("testDone", {
  			name: testName,
  			module: moduleName,
  			skipped: skipped,
  			todo: todo,
  			failed: bad,
  			passed: this.assertions.length - bad,
  			total: this.assertions.length,
  			runtime: skipped ? 0 : this.runtime,

  			// HTML Reporter use
  			assertions: this.assertions,
  			testId: this.testId,

  			// Source of Test
  			// generating stack trace is expensive, so using a getter will help defer this until we need it
  			get source() {
  				return test.stack;
  			}
  		}).then(function () {
  			if (module.testsRun === numberOfTests(module)) {
  				var completedModules = [module];

  				// Check if the parent modules, iteratively, are done. If that the case,
  				// we emit the `suiteEnd` event and trigger `moduleDone` callback.
  				var parent = module.parentModule;
  				while (parent && parent.testsRun === numberOfTests(parent)) {
  					completedModules.push(parent);
  					parent = parent.parentModule;
  				}

  				return completedModules.reduce(function (promiseChain, completedModule) {
  					return promiseChain.then(function () {
  						return logSuiteEnd(completedModule);
  					});
  				}, Promise$1.resolve([]));
  			}
  		}).then(function () {
  			config.current = undefined;
  		});

  		function logSuiteEnd(module) {

  			// Reset `module.hooks` to ensure that anything referenced in these hooks
  			// has been released to be garbage collected.
  			module.hooks = {};

  			emit("suiteEnd", module.suiteReport.end(true));
  			return runLoggingCallbacks("moduleDone", {
  				name: module.name,
  				tests: module.tests,
  				failed: module.stats.bad,
  				passed: module.stats.all - module.stats.bad,
  				total: module.stats.all,
  				runtime: now() - module.stats.started
  			});
  		}
  	},

  	preserveTestEnvironment: function preserveTestEnvironment() {
  		if (this.preserveEnvironment) {
  			this.module.testEnvironment = this.testEnvironment;
  			this.testEnvironment = extend({}, this.module.testEnvironment);
  		}
  	},

  	queue: function queue() {
  		var test = this;

  		if (!this.valid()) {
  			return;
  		}

  		function runTest() {
  			return [function () {
  				return test.before();
  			}].concat(toConsumableArray(test.hooks("before")), [function () {
  				test.preserveTestEnvironment();
  			}], toConsumableArray(test.hooks("beforeEach")), [function () {
  				test.run();
  			}], toConsumableArray(test.hooks("afterEach").reverse()), toConsumableArray(test.hooks("after").reverse()), [function () {
  				test.after();
  			}, function () {
  				return test.finish();
  			}]);
  		}

  		var previousFailCount = config.storage && +config.storage.getItem("qunit-test-" + this.module.name + "-" + this.testName);

  		// Prioritize previously failed tests, detected from storage
  		var prioritize = config.reorder && !!previousFailCount;

  		this.previousFailure = !!previousFailCount;

  		ProcessingQueue.add(runTest, prioritize, config.seed);

  		// If the queue has already finished, we manually process the new test
  		if (ProcessingQueue.finished) {
  			ProcessingQueue.advance();
  		}
  	},


  	pushResult: function pushResult(resultInfo) {
  		if (this !== config.current) {
  			throw new Error("Assertion occurred after test had finished.");
  		}

  		// Destructure of resultInfo = { result, actual, expected, message, negative }
  		var source,
  		    details = {
  			module: this.module.name,
  			name: this.testName,
  			result: resultInfo.result,
  			message: resultInfo.message,
  			actual: resultInfo.actual,
  			testId: this.testId,
  			negative: resultInfo.negative || false,
  			runtime: now() - this.started,
  			todo: !!this.todo
  		};

  		if (hasOwn.call(resultInfo, "expected")) {
  			details.expected = resultInfo.expected;
  		}

  		if (!resultInfo.result) {
  			source = resultInfo.source || sourceFromStacktrace();

  			if (source) {
  				details.source = source;
  			}
  		}

  		this.logAssertion(details);

  		this.assertions.push({
  			result: !!resultInfo.result,
  			message: resultInfo.message
  		});
  	},

  	pushFailure: function pushFailure(message, source, actual) {
  		if (!(this instanceof Test)) {
  			throw new Error("pushFailure() assertion outside test context, was " + sourceFromStacktrace(2));
  		}

  		this.pushResult({
  			result: false,
  			message: message || "error",
  			actual: actual || null,
  			source: source
  		});
  	},

  	/**
    * Log assertion details using both the old QUnit.log interface and
    * QUnit.on( "assertion" ) interface.
    *
    * @private
    */
  	logAssertion: function logAssertion(details) {
  		runLoggingCallbacks("log", details);

  		var assertion = {
  			passed: details.result,
  			actual: details.actual,
  			expected: details.expected,
  			message: details.message,
  			stack: details.source,
  			todo: details.todo
  		};
  		this.testReport.pushAssertion(assertion);
  		emit("assertion", assertion);
  	},


  	resolvePromise: function resolvePromise(promise, phase) {
  		var then,
  		    resume,
  		    message,
  		    test = this;
  		if (promise != null) {
  			then = promise.then;
  			if (objectType(then) === "function") {
  				resume = internalStop(test);
  				if (config.notrycatch) {
  					then.call(promise, function () {
  						resume();
  					});
  				} else {
  					then.call(promise, function () {
  						resume();
  					}, function (error) {
  						message = "Promise rejected " + (!phase ? "during" : phase.replace(/Each$/, "")) + " \"" + test.testName + "\": " + (error && error.message || error);
  						test.pushFailure(message, extractStacktrace(error, 0));

  						// Else next test will carry the responsibility
  						saveGlobal();

  						// Unblock
  						internalRecover(test);
  					});
  				}
  			}
  		}
  	},

  	valid: function valid() {
  		var filter = config.filter,
  		    regexFilter = /^(!?)\/([\w\W]*)\/(i?$)/.exec(filter),
  		    module = config.module && config.module.toLowerCase(),
  		    fullName = this.module.name + ": " + this.testName;

  		function moduleChainNameMatch(testModule) {
  			var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;
  			if (testModuleName === module) {
  				return true;
  			} else if (testModule.parentModule) {
  				return moduleChainNameMatch(testModule.parentModule);
  			} else {
  				return false;
  			}
  		}

  		function moduleChainIdMatch(testModule) {
  			return inArray(testModule.moduleId, config.moduleId) || testModule.parentModule && moduleChainIdMatch(testModule.parentModule);
  		}

  		// Internally-generated tests are always valid
  		if (this.callback && this.callback.validTest) {
  			return true;
  		}

  		if (config.moduleId && config.moduleId.length > 0 && !moduleChainIdMatch(this.module)) {

  			return false;
  		}

  		if (config.testId && config.testId.length > 0 && !inArray(this.testId, config.testId)) {

  			return false;
  		}

  		if (module && !moduleChainNameMatch(this.module)) {
  			return false;
  		}

  		if (!filter) {
  			return true;
  		}

  		return regexFilter ? this.regexFilter(!!regexFilter[1], regexFilter[2], regexFilter[3], fullName) : this.stringFilter(filter, fullName);
  	},

  	regexFilter: function regexFilter(exclude, pattern, flags, fullName) {
  		var regex = new RegExp(pattern, flags);
  		var match = regex.test(fullName);

  		return match !== exclude;
  	},

  	stringFilter: function stringFilter(filter, fullName) {
  		filter = filter.toLowerCase();
  		fullName = fullName.toLowerCase();

  		var include = filter.charAt(0) !== "!";
  		if (!include) {
  			filter = filter.slice(1);
  		}

  		// If the filter matches, we need to honour include
  		if (fullName.indexOf(filter) !== -1) {
  			return include;
  		}

  		// Otherwise, do the opposite
  		return !include;
  	}
  };

  function pushFailure() {
  	if (!config.current) {
  		throw new Error("pushFailure() assertion outside test context, in " + sourceFromStacktrace(2));
  	}

  	// Gets current test obj
  	var currentTest = config.current;

  	return currentTest.pushFailure.apply(currentTest, arguments);
  }

  function saveGlobal() {
  	config.pollution = [];

  	if (config.noglobals) {
  		for (var key in global$1) {
  			if (hasOwn.call(global$1, key)) {

  				// In Opera sometimes DOM element ids show up here, ignore them
  				if (/^qunit-test-output/.test(key)) {
  					continue;
  				}
  				config.pollution.push(key);
  			}
  		}
  	}
  }

  function checkPollution() {
  	var newGlobals,
  	    deletedGlobals,
  	    old = config.pollution;

  	saveGlobal();

  	newGlobals = diff(config.pollution, old);
  	if (newGlobals.length > 0) {
  		pushFailure("Introduced global variable(s): " + newGlobals.join(", "));
  	}

  	deletedGlobals = diff(old, config.pollution);
  	if (deletedGlobals.length > 0) {
  		pushFailure("Deleted global variable(s): " + deletedGlobals.join(", "));
  	}
  }

  // Will be exposed as QUnit.test
  function test(testName, callback) {
  	if (focused$1) {
  		return;
  	}

  	var newTest = new Test({
  		testName: testName,
  		callback: callback
  	});

  	newTest.queue();
  }

  function todo(testName, callback) {
  	if (focused$1) {
  		return;
  	}

  	var newTest = new Test({
  		testName: testName,
  		callback: callback,
  		todo: true
  	});

  	newTest.queue();
  }

  // Will be exposed as QUnit.skip
  function skip(testName) {
  	if (focused$1) {
  		return;
  	}

  	var test = new Test({
  		testName: testName,
  		skip: true
  	});

  	test.queue();
  }

  // Will be exposed as QUnit.only
  function only(testName, callback) {
  	if (focused$1) {
  		return;
  	}

  	config.queue.length = 0;
  	focused$1 = true;

  	var newTest = new Test({
  		testName: testName,
  		callback: callback
  	});

  	newTest.queue();
  }

  // Resets config.timeout with a new timeout duration.
  function resetTestTimeout(timeoutDuration) {
  	clearTimeout(config.timeout);
  	config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);
  }

  // Put a hold on processing and return a function that will release it.
  function internalStop(test) {
  	var released = false;
  	test.semaphore += 1;
  	config.blocking = true;

  	// Set a recovery timeout, if so configured.
  	if (defined.setTimeout) {
  		var timeoutDuration = void 0;

  		if (typeof test.timeout === "number") {
  			timeoutDuration = test.timeout;
  		} else if (typeof config.testTimeout === "number") {
  			timeoutDuration = config.testTimeout;
  		}

  		if (typeof timeoutDuration === "number" && timeoutDuration > 0) {
  			clearTimeout(config.timeout);
  			config.timeoutHandler = function (timeout) {
  				return function () {
  					pushFailure("Test took longer than " + timeout + "ms; test timed out.", sourceFromStacktrace(2));
  					released = true;
  					internalRecover(test);
  				};
  			};
  			config.timeout = setTimeout$1(config.timeoutHandler(timeoutDuration), timeoutDuration);
  		}
  	}

  	return function resume() {
  		if (released) {
  			return;
  		}

  		released = true;
  		test.semaphore -= 1;
  		internalStart(test);
  	};
  }

  // Forcefully release all processing holds.
  function internalRecover(test) {
  	test.semaphore = 0;
  	internalStart(test);
  }

  // Release a processing hold, scheduling a resumption attempt if no holds remain.
  function internalStart(test) {

  	// If semaphore is non-numeric, throw error
  	if (isNaN(test.semaphore)) {
  		test.semaphore = 0;

  		pushFailure("Invalid value on test.semaphore", sourceFromStacktrace(2));
  		return;
  	}

  	// Don't start until equal number of stop-calls
  	if (test.semaphore > 0) {
  		return;
  	}

  	// Throw an Error if start is called more often than stop
  	if (test.semaphore < 0) {
  		test.semaphore = 0;

  		pushFailure("Tried to restart test while already started (test's semaphore was 0 already)", sourceFromStacktrace(2));
  		return;
  	}

  	// Add a slight delay to allow more assertions etc.
  	if (defined.setTimeout) {
  		if (config.timeout) {
  			clearTimeout(config.timeout);
  		}
  		config.timeout = setTimeout$1(function () {
  			if (test.semaphore > 0) {
  				return;
  			}

  			if (config.timeout) {
  				clearTimeout(config.timeout);
  			}

  			begin();
  		});
  	} else {
  		begin();
  	}
  }

  function collectTests(module) {
  	var tests = [].concat(module.tests);
  	var modules = [].concat(toConsumableArray(module.childModules));

  	// Do a breadth-first traversal of the child modules
  	while (modules.length) {
  		var nextModule = modules.shift();
  		tests.push.apply(tests, nextModule.tests);
  		modules.push.apply(modules, toConsumableArray(nextModule.childModules));
  	}

  	return tests;
  }

  function numberOfTests(module) {
  	return collectTests(module).length;
  }

  function numberOfUnskippedTests(module) {
  	return collectTests(module).filter(function (test) {
  		return !test.skip;
  	}).length;
  }

  function notifyTestsRan(module, skipped) {
  	module.testsRun++;
  	if (!skipped) {
  		module.unskippedTestsRun++;
  	}
  	while (module = module.parentModule) {
  		module.testsRun++;
  		if (!skipped) {
  			module.unskippedTestsRun++;
  		}
  	}
  }

  var Assert = function () {
  	function Assert(testContext) {
  		classCallCheck(this, Assert);

  		this.test = testContext;
  	}

  	// Assert helpers

  	createClass(Assert, [{
  		key: "timeout",
  		value: function timeout(duration) {
  			if (typeof duration !== "number") {
  				throw new Error("You must pass a number as the duration to assert.timeout");
  			}

  			this.test.timeout = duration;

  			// If a timeout has been set, clear it and reset with the new duration
  			if (config.timeout) {
  				clearTimeout(config.timeout);

  				if (config.timeoutHandler && this.test.timeout > 0) {
  					resetTestTimeout(this.test.timeout);
  				}
  			}
  		}

  		// Documents a "step", which is a string value, in a test as a passing assertion

  	}, {
  		key: "step",
  		value: function step(message) {
  			var assertionMessage = message;
  			var result = !!message;

  			this.test.steps.push(message);

  			if (objectType(message) === "undefined" || message === "") {
  				assertionMessage = "You must provide a message to assert.step";
  			} else if (objectType(message) !== "string") {
  				assertionMessage = "You must provide a string value to assert.step";
  				result = false;
  			}

  			this.pushResult({
  				result: result,
  				message: assertionMessage
  			});
  		}

  		// Verifies the steps in a test match a given array of string values

  	}, {
  		key: "verifySteps",
  		value: function verifySteps(steps, message) {

  			// Since the steps array is just string values, we can clone with slice
  			var actualStepsClone = this.test.steps.slice();
  			this.deepEqual(actualStepsClone, steps, message);
  			this.test.steps.length = 0;
  		}

  		// Specify the number of expected assertions to guarantee that failed test
  		// (no assertions are run at all) don't slip through.

  	}, {
  		key: "expect",
  		value: function expect(asserts) {
  			if (arguments.length === 1) {
  				this.test.expected = asserts;
  			} else {
  				return this.test.expected;
  			}
  		}

  		// Put a hold on processing and return a function that will release it a maximum of once.

  	}, {
  		key: "async",
  		value: function async(count) {
  			var test$$1 = this.test;

  			var popped = false,
  			    acceptCallCount = count;

  			if (typeof acceptCallCount === "undefined") {
  				acceptCallCount = 1;
  			}

  			var resume = internalStop(test$$1);

  			return function done() {
  				if (config.current !== test$$1) {
  					throw Error("assert.async callback called after test finished.");
  				}

  				if (popped) {
  					test$$1.pushFailure("Too many calls to the `assert.async` callback", sourceFromStacktrace(2));
  					return;
  				}

  				acceptCallCount -= 1;
  				if (acceptCallCount > 0) {
  					return;
  				}

  				popped = true;
  				resume();
  			};
  		}

  		// Exports test.push() to the user API
  		// Alias of pushResult.

  	}, {
  		key: "push",
  		value: function push(result, actual, expected, message, negative) {
  			Logger.warn("assert.push is deprecated and will be removed in QUnit 3.0." + " Please use assert.pushResult instead (https://api.qunitjs.com/assert/pushResult).");

  			var currentAssert = this instanceof Assert ? this : config.current.assert;
  			return currentAssert.pushResult({
  				result: result,
  				actual: actual,
  				expected: expected,
  				message: message,
  				negative: negative
  			});
  		}
  	}, {
  		key: "pushResult",
  		value: function pushResult(resultInfo) {

  			// Destructure of resultInfo = { result, actual, expected, message, negative }
  			var assert = this;
  			var currentTest = assert instanceof Assert && assert.test || config.current;

  			// Backwards compatibility fix.
  			// Allows the direct use of global exported assertions and QUnit.assert.*
  			// Although, it's use is not recommended as it can leak assertions
  			// to other tests from async tests, because we only get a reference to the current test,
  			// not exactly the test where assertion were intended to be called.
  			if (!currentTest) {
  				throw new Error("assertion outside test context, in " + sourceFromStacktrace(2));
  			}

  			if (!(assert instanceof Assert)) {
  				assert = currentTest.assert;
  			}

  			return assert.test.pushResult(resultInfo);
  		}
  	}, {
  		key: "ok",
  		value: function ok(result, message) {
  			if (!message) {
  				message = result ? "okay" : "failed, expected argument to be truthy, was: " + dump.parse(result);
  			}

  			this.pushResult({
  				result: !!result,
  				actual: result,
  				expected: true,
  				message: message
  			});
  		}
  	}, {
  		key: "notOk",
  		value: function notOk(result, message) {
  			if (!message) {
  				message = !result ? "okay" : "failed, expected argument to be falsy, was: " + dump.parse(result);
  			}

  			this.pushResult({
  				result: !result,
  				actual: result,
  				expected: false,
  				message: message
  			});
  		}
  	}, {
  		key: "equal",
  		value: function equal(actual, expected, message) {

  			// eslint-disable-next-line eqeqeq
  			var result = expected == actual;

  			this.pushResult({
  				result: result,
  				actual: actual,
  				expected: expected,
  				message: message
  			});
  		}
  	}, {
  		key: "notEqual",
  		value: function notEqual(actual, expected, message) {

  			// eslint-disable-next-line eqeqeq
  			var result = expected != actual;

  			this.pushResult({
  				result: result,
  				actual: actual,
  				expected: expected,
  				message: message,
  				negative: true
  			});
  		}
  	}, {
  		key: "propEqual",
  		value: function propEqual(actual, expected, message) {
  			actual = objectValues(actual);
  			expected = objectValues(expected);

  			this.pushResult({
  				result: equiv(actual, expected),
  				actual: actual,
  				expected: expected,
  				message: message
  			});
  		}
  	}, {
  		key: "notPropEqual",
  		value: function notPropEqual(actual, expected, message) {
  			actual = objectValues(actual);
  			expected = objectValues(expected);

  			this.pushResult({
  				result: !equiv(actual, expected),
  				actual: actual,
  				expected: expected,
  				message: message,
  				negative: true
  			});
  		}
  	}, {
  		key: "deepEqual",
  		value: function deepEqual(actual, expected, message) {
  			this.pushResult({
  				result: equiv(actual, expected),
  				actual: actual,
  				expected: expected,
  				message: message
  			});
  		}
  	}, {
  		key: "notDeepEqual",
  		value: function notDeepEqual(actual, expected, message) {
  			this.pushResult({
  				result: !equiv(actual, expected),
  				actual: actual,
  				expected: expected,
  				message: message,
  				negative: true
  			});
  		}
  	}, {
  		key: "strictEqual",
  		value: function strictEqual(actual, expected, message) {
  			this.pushResult({
  				result: expected === actual,
  				actual: actual,
  				expected: expected,
  				message: message
  			});
  		}
  	}, {
  		key: "notStrictEqual",
  		value: function notStrictEqual(actual, expected, message) {
  			this.pushResult({
  				result: expected !== actual,
  				actual: actual,
  				expected: expected,
  				message: message,
  				negative: true
  			});
  		}
  	}, {
  		key: "throws",
  		value: function throws(block, expected, message) {
  			var actual = void 0,
  			    result = false;

  			var currentTest = this instanceof Assert && this.test || config.current;

  			// 'expected' is optional unless doing string comparison
  			if (objectType(expected) === "string") {
  				if (message == null) {
  					message = expected;
  					expected = null;
  				} else {
  					throw new Error("throws/raises does not accept a string value for the expected argument.\n" + "Use a non-string object value (e.g. regExp) instead if it's necessary.");
  				}
  			}

  			currentTest.ignoreGlobalErrors = true;
  			try {
  				block.call(currentTest.testEnvironment);
  			} catch (e) {
  				actual = e;
  			}
  			currentTest.ignoreGlobalErrors = false;

  			if (actual) {
  				var expectedType = objectType(expected);

  				// We don't want to validate thrown error
  				if (!expected) {
  					result = true;

  					// Expected is a regexp
  				} else if (expectedType === "regexp") {
  					result = expected.test(errorString(actual));

  					// Log the string form of the regexp
  					expected = String(expected);

  					// Expected is a constructor, maybe an Error constructor
  				} else if (expectedType === "function" && actual instanceof expected) {
  					result = true;

  					// Expected is an Error object
  				} else if (expectedType === "object") {
  					result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;

  					// Log the string form of the Error object
  					expected = errorString(expected);

  					// Expected is a validation function which returns true if validation passed
  				} else if (expectedType === "function" && expected.call({}, actual) === true) {
  					expected = null;
  					result = true;
  				}
  			}

  			currentTest.assert.pushResult({
  				result: result,

  				// undefined if it didn't throw
  				actual: actual && errorString(actual),
  				expected: expected,
  				message: message
  			});
  		}
  	}, {
  		key: "rejects",
  		value: function rejects(promise, expected, message) {
  			var result = false;

  			var currentTest = this instanceof Assert && this.test || config.current;

  			// 'expected' is optional unless doing string comparison
  			if (objectType(expected) === "string") {
  				if (message === undefined) {
  					message = expected;
  					expected = undefined;
  				} else {
  					message = "assert.rejects does not accept a string value for the expected " + "argument.\nUse a non-string object value (e.g. validator function) instead " + "if necessary.";

  					currentTest.assert.pushResult({
  						result: false,
  						message: message
  					});

  					return;
  				}
  			}

  			var then = promise && promise.then;
  			if (objectType(then) !== "function") {
  				var _message = "The value provided to `assert.rejects` in " + "\"" + currentTest.testName + "\" was not a promise.";

  				currentTest.assert.pushResult({
  					result: false,
  					message: _message,
  					actual: promise
  				});

  				return;
  			}

  			var done = this.async();

  			return then.call(promise, function handleFulfillment() {
  				var message = "The promise returned by the `assert.rejects` callback in " + "\"" + currentTest.testName + "\" did not reject.";

  				currentTest.assert.pushResult({
  					result: false,
  					message: message,
  					actual: promise
  				});

  				done();
  			}, function handleRejection(actual) {
  				var expectedType = objectType(expected);

  				// We don't want to validate
  				if (expected === undefined) {
  					result = true;

  					// Expected is a regexp
  				} else if (expectedType === "regexp") {
  					result = expected.test(errorString(actual));

  					// Log the string form of the regexp
  					expected = String(expected);

  					// Expected is a constructor, maybe an Error constructor
  				} else if (expectedType === "function" && actual instanceof expected) {
  					result = true;

  					// Expected is an Error object
  				} else if (expectedType === "object") {
  					result = actual instanceof expected.constructor && actual.name === expected.name && actual.message === expected.message;

  					// Log the string form of the Error object
  					expected = errorString(expected);

  					// Expected is a validation function which returns true if validation passed
  				} else {
  					if (expectedType === "function") {
  						result = expected.call({}, actual) === true;
  						expected = null;

  						// Expected is some other invalid type
  					} else {
  						result = false;
  						message = "invalid expected value provided to `assert.rejects` " + "callback in \"" + currentTest.testName + "\": " + expectedType + ".";
  					}
  				}

  				currentTest.assert.pushResult({
  					result: result,

  					// leave rejection value of undefined as-is
  					actual: actual && errorString(actual),
  					expected: expected,
  					message: message
  				});

  				done();
  			});
  		}
  	}]);
  	return Assert;
  }();

  // Provide an alternative to assert.throws(), for environments that consider throws a reserved word
  // Known to us are: Closure Compiler, Narwhal
  // eslint-disable-next-line dot-notation


  Assert.prototype.raises = Assert.prototype["throws"];

  /**
   * Converts an error into a simple string for comparisons.
   *
   * @param {Error|Object} error
   * @return {String}
   */
  function errorString(error) {
  	var resultErrorString = error.toString();

  	// If the error wasn't a subclass of Error but something like
  	// an object literal with name and message properties...
  	if (resultErrorString.substring(0, 7) === "[object") {
  		var name = error.name ? error.name.toString() : "Error";
  		var message = error.message ? error.message.toString() : "";

  		if (name && message) {
  			return name + ": " + message;
  		} else if (name) {
  			return name;
  		} else if (message) {
  			return message;
  		} else {
  			return "Error";
  		}
  	} else {
  		return resultErrorString;
  	}
  }

  /* global module, exports, define */
  function exportQUnit(QUnit) {

  	if (defined.document) {

  		// QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.
  		if (window$1.QUnit && window$1.QUnit.version) {
  			throw new Error("QUnit has already been defined.");
  		}

  		window$1.QUnit = QUnit;
  	}

  	// For nodejs
  	if ( module && module.exports) {
  		module.exports = QUnit;

  		// For consistency with CommonJS environments' exports
  		module.exports.QUnit = QUnit;
  	}

  	// For CommonJS with exports, but without module.exports, like Rhino
  	if ( exports) {
  		exports.QUnit = QUnit;
  	}

  	// For Web/Service Workers
  	if (self$1 && self$1.WorkerGlobalScope && self$1 instanceof self$1.WorkerGlobalScope) {
  		self$1.QUnit = QUnit;
  	}
  }

  // Handle an unhandled exception. By convention, returns true if further
  // error handling should be suppressed and false otherwise.
  // In this case, we will only suppress further error handling if the
  // "ignoreGlobalErrors" configuration option is enabled.
  function onError(error) {
  	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  		args[_key - 1] = arguments[_key];
  	}

  	if (config.current) {
  		if (config.current.ignoreGlobalErrors) {
  			return true;
  		}
  		pushFailure.apply(undefined, [error.message, error.stacktrace || error.fileName + ":" + error.lineNumber].concat(args));
  	} else {
  		test("global failure", extend(function () {
  			pushFailure.apply(undefined, [error.message, error.stacktrace || error.fileName + ":" + error.lineNumber].concat(args));
  		}, { validTest: true }));
  	}

  	return false;
  }

  // Handle an unhandled rejection
  function onUnhandledRejection(reason) {
  	var resultInfo = {
  		result: false,
  		message: reason.message || "error",
  		actual: reason,
  		source: reason.stack || sourceFromStacktrace(3)
  	};

  	var currentTest = config.current;
  	if (currentTest) {
  		currentTest.assert.pushResult(resultInfo);
  	} else {
  		test("global failure", extend(function (assert) {
  			assert.pushResult(resultInfo);
  		}, { validTest: true }));
  	}
  }

  var QUnit = {};
  var globalSuite = new SuiteReport();

  // The initial "currentModule" represents the global (or top-level) module that
  // is not explicitly defined by the user, therefore we add the "globalSuite" to
  // it since each module has a suiteReport associated with it.
  config.currentModule.suiteReport = globalSuite;

  var globalStartCalled = false;
  var runStarted = false;

  // Figure out if we're running the tests from a server or not
  QUnit.isLocal = !(defined.document && window$1.location.protocol !== "file:");

  // Expose the current QUnit version
  QUnit.version = "2.9.3";

  extend(QUnit, {
  	on: on,

  	module: module$1,

  	test: test,

  	todo: todo,

  	skip: skip,

  	only: only,

  	start: function start(count) {
  		var globalStartAlreadyCalled = globalStartCalled;

  		if (!config.current) {
  			globalStartCalled = true;

  			if (runStarted) {
  				throw new Error("Called start() while test already started running");
  			} else if (globalStartAlreadyCalled || count > 1) {
  				throw new Error("Called start() outside of a test context too many times");
  			} else if (config.autostart) {
  				throw new Error("Called start() outside of a test context when " + "QUnit.config.autostart was true");
  			} else if (!config.pageLoaded) {

  				// The page isn't completely loaded yet, so we set autostart and then
  				// load if we're in Node or wait for the browser's load event.
  				config.autostart = true;

  				// Starts from Node even if .load was not previously called. We still return
  				// early otherwise we'll wind up "beginning" twice.
  				if (!defined.document) {
  					QUnit.load();
  				}

  				return;
  			}
  		} else {
  			throw new Error("QUnit.start cannot be called inside a test context.");
  		}

  		scheduleBegin();
  	},

  	config: config,

  	is: is,

  	objectType: objectType,

  	extend: extend,

  	load: function load() {
  		config.pageLoaded = true;

  		// Initialize the configuration options
  		extend(config, {
  			stats: { all: 0, bad: 0 },
  			started: 0,
  			updateRate: 1000,
  			autostart: true,
  			filter: ""
  		}, true);

  		if (!runStarted) {
  			config.blocking = false;

  			if (config.autostart) {
  				scheduleBegin();
  			}
  		}
  	},

  	stack: function stack(offset) {
  		offset = (offset || 0) + 2;
  		return sourceFromStacktrace(offset);
  	},

  	onError: onError,

  	onUnhandledRejection: onUnhandledRejection
  });

  QUnit.pushFailure = pushFailure;
  QUnit.assert = Assert.prototype;
  QUnit.equiv = equiv;
  QUnit.dump = dump;

  registerLoggingCallbacks(QUnit);

  function scheduleBegin() {

  	runStarted = true;

  	// Add a slight delay to allow definition of more modules and tests.
  	if (defined.setTimeout) {
  		setTimeout$1(function () {
  			begin();
  		});
  	} else {
  		begin();
  	}
  }

  function unblockAndAdvanceQueue() {
  	config.blocking = false;
  	ProcessingQueue.advance();
  }

  function begin() {
  	var i,
  	    l,
  	    modulesLog = [];

  	// If the test run hasn't officially begun yet
  	if (!config.started) {

  		// Record the time of the test run's beginning
  		config.started = now();

  		// Delete the loose unnamed module if unused.
  		if (config.modules[0].name === "" && config.modules[0].tests.length === 0) {
  			config.modules.shift();
  		}

  		// Avoid unnecessary information by not logging modules' test environments
  		for (i = 0, l = config.modules.length; i < l; i++) {
  			modulesLog.push({
  				name: config.modules[i].name,
  				tests: config.modules[i].tests
  			});
  		}

  		// The test run is officially beginning now
  		emit("runStart", globalSuite.start(true));
  		runLoggingCallbacks("begin", {
  			totalTests: Test.count,
  			modules: modulesLog
  		}).then(unblockAndAdvanceQueue);
  	} else {
  		unblockAndAdvanceQueue();
  	}
  }

  exportQUnit(QUnit);

  (function () {

  	if (typeof window$1 === "undefined" || typeof document$1 === "undefined") {
  		return;
  	}

  	var config = QUnit.config,
  	    hasOwn = Object.prototype.hasOwnProperty;

  	// Stores fixture HTML for resetting later
  	function storeFixture() {

  		// Avoid overwriting user-defined values
  		if (hasOwn.call(config, "fixture")) {
  			return;
  		}

  		var fixture = document$1.getElementById("qunit-fixture");
  		if (fixture) {
  			config.fixture = fixture.cloneNode(true);
  		}
  	}

  	QUnit.begin(storeFixture);

  	// Resets the fixture DOM element if available.
  	function resetFixture() {
  		if (config.fixture == null) {
  			return;
  		}

  		var fixture = document$1.getElementById("qunit-fixture");
  		var resetFixtureType = _typeof(config.fixture);
  		if (resetFixtureType === "string") {

  			// support user defined values for `config.fixture`
  			var newFixture = document$1.createElement("div");
  			newFixture.setAttribute("id", "qunit-fixture");
  			newFixture.innerHTML = config.fixture;
  			fixture.parentNode.replaceChild(newFixture, fixture);
  		} else {
  			var clonedFixture = config.fixture.cloneNode(true);
  			fixture.parentNode.replaceChild(clonedFixture, fixture);
  		}
  	}

  	QUnit.testStart(resetFixture);
  })();

  (function () {

  	// Only interact with URLs via window.location
  	var location = typeof window$1 !== "undefined" && window$1.location;
  	if (!location) {
  		return;
  	}

  	var urlParams = getUrlParams();

  	QUnit.urlParams = urlParams;

  	// Match module/test by inclusion in an array
  	QUnit.config.moduleId = [].concat(urlParams.moduleId || []);
  	QUnit.config.testId = [].concat(urlParams.testId || []);

  	// Exact case-insensitive match of the module name
  	QUnit.config.module = urlParams.module;

  	// Regular expression or case-insenstive substring match against "moduleName: testName"
  	QUnit.config.filter = urlParams.filter;

  	// Test order randomization
  	if (urlParams.seed === true) {

  		// Generate a random seed if the option is specified without a value
  		QUnit.config.seed = Math.random().toString(36).slice(2);
  	} else if (urlParams.seed) {
  		QUnit.config.seed = urlParams.seed;
  	}

  	// Add URL-parameter-mapped config values with UI form rendering data
  	QUnit.config.urlConfig.push({
  		id: "hidepassed",
  		label: "Hide passed tests",
  		tooltip: "Only show tests and assertions that fail. Stored as query-strings."
  	}, {
  		id: "noglobals",
  		label: "Check for Globals",
  		tooltip: "Enabling this will test if any test introduces new properties on the " + "global object (`window` in Browsers). Stored as query-strings."
  	}, {
  		id: "notrycatch",
  		label: "No try-catch",
  		tooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging " + "exceptions in IE reasonable. Stored as query-strings."
  	});

  	QUnit.begin(function () {
  		var i,
  		    option,
  		    urlConfig = QUnit.config.urlConfig;

  		for (i = 0; i < urlConfig.length; i++) {

  			// Options can be either strings or objects with nonempty "id" properties
  			option = QUnit.config.urlConfig[i];
  			if (typeof option !== "string") {
  				option = option.id;
  			}

  			if (QUnit.config[option] === undefined) {
  				QUnit.config[option] = urlParams[option];
  			}
  		}
  	});

  	function getUrlParams() {
  		var i, param, name, value;
  		var urlParams = Object.create(null);
  		var params = location.search.slice(1).split("&");
  		var length = params.length;

  		for (i = 0; i < length; i++) {
  			if (params[i]) {
  				param = params[i].split("=");
  				name = decodeQueryParam(param[0]);

  				// Allow just a key to turn on a flag, e.g., test.html?noglobals
  				value = param.length === 1 || decodeQueryParam(param.slice(1).join("="));
  				if (name in urlParams) {
  					urlParams[name] = [].concat(urlParams[name], value);
  				} else {
  					urlParams[name] = value;
  				}
  			}
  		}

  		return urlParams;
  	}

  	function decodeQueryParam(param) {
  		return decodeURIComponent(param.replace(/\+/g, "%20"));
  	}
  })();

  var stats = {
  	passedTests: 0,
  	failedTests: 0,
  	skippedTests: 0,
  	todoTests: 0
  };

  // Escape text for attribute or text content.
  function escapeText(s) {
  	if (!s) {
  		return "";
  	}
  	s = s + "";

  	// Both single quotes and double quotes (for attributes)
  	return s.replace(/['"<>&]/g, function (s) {
  		switch (s) {
  			case "'":
  				return "&#039;";
  			case "\"":
  				return "&quot;";
  			case "<":
  				return "&lt;";
  			case ">":
  				return "&gt;";
  			case "&":
  				return "&amp;";
  		}
  	});
  }

  (function () {

  	// Don't load the HTML Reporter on non-browser environments
  	if (typeof window$1 === "undefined" || !window$1.document) {
  		return;
  	}

  	var config = QUnit.config,
  	    hiddenTests = [],
  	    document = window$1.document,
  	    collapseNext = false,
  	    hasOwn$$1 = Object.prototype.hasOwnProperty,
  	    unfilteredUrl = setUrl({ filter: undefined, module: undefined,
  		moduleId: undefined, testId: undefined }),
  	    modulesList = [];

  	function addEvent(elem, type, fn) {
  		elem.addEventListener(type, fn, false);
  	}

  	function removeEvent(elem, type, fn) {
  		elem.removeEventListener(type, fn, false);
  	}

  	function addEvents(elems, type, fn) {
  		var i = elems.length;
  		while (i--) {
  			addEvent(elems[i], type, fn);
  		}
  	}

  	function hasClass(elem, name) {
  		return (" " + elem.className + " ").indexOf(" " + name + " ") >= 0;
  	}

  	function addClass(elem, name) {
  		if (!hasClass(elem, name)) {
  			elem.className += (elem.className ? " " : "") + name;
  		}
  	}

  	function toggleClass(elem, name, force) {
  		if (force || typeof force === "undefined" && !hasClass(elem, name)) {
  			addClass(elem, name);
  		} else {
  			removeClass(elem, name);
  		}
  	}

  	function removeClass(elem, name) {
  		var set = " " + elem.className + " ";

  		// Class name may appear multiple times
  		while (set.indexOf(" " + name + " ") >= 0) {
  			set = set.replace(" " + name + " ", " ");
  		}

  		// Trim for prettiness
  		elem.className = typeof set.trim === "function" ? set.trim() : set.replace(/^\s+|\s+$/g, "");
  	}

  	function id(name) {
  		return document.getElementById && document.getElementById(name);
  	}

  	function abortTests() {
  		var abortButton = id("qunit-abort-tests-button");
  		if (abortButton) {
  			abortButton.disabled = true;
  			abortButton.innerHTML = "Aborting...";
  		}
  		QUnit.config.queue.length = 0;
  		return false;
  	}

  	function interceptNavigation(ev) {
  		applyUrlParams();

  		if (ev && ev.preventDefault) {
  			ev.preventDefault();
  		}

  		return false;
  	}

  	function getUrlConfigHtml() {
  		var i,
  		    j,
  		    val,
  		    escaped,
  		    escapedTooltip,
  		    selection = false,
  		    urlConfig = config.urlConfig,
  		    urlConfigHtml = "";

  		for (i = 0; i < urlConfig.length; i++) {

  			// Options can be either strings or objects with nonempty "id" properties
  			val = config.urlConfig[i];
  			if (typeof val === "string") {
  				val = {
  					id: val,
  					label: val
  				};
  			}

  			escaped = escapeText(val.id);
  			escapedTooltip = escapeText(val.tooltip);

  			if (!val.value || typeof val.value === "string") {
  				urlConfigHtml += "<label for='qunit-urlconfig-" + escaped + "' title='" + escapedTooltip + "'><input id='qunit-urlconfig-" + escaped + "' name='" + escaped + "' type='checkbox'" + (val.value ? " value='" + escapeText(val.value) + "'" : "") + (config[val.id] ? " checked='checked'" : "") + " title='" + escapedTooltip + "' />" + escapeText(val.label) + "</label>";
  			} else {
  				urlConfigHtml += "<label for='qunit-urlconfig-" + escaped + "' title='" + escapedTooltip + "'>" + val.label + ": </label><select id='qunit-urlconfig-" + escaped + "' name='" + escaped + "' title='" + escapedTooltip + "'><option></option>";

  				if (QUnit.is("array", val.value)) {
  					for (j = 0; j < val.value.length; j++) {
  						escaped = escapeText(val.value[j]);
  						urlConfigHtml += "<option value='" + escaped + "'" + (config[val.id] === val.value[j] ? (selection = true) && " selected='selected'" : "") + ">" + escaped + "</option>";
  					}
  				} else {
  					for (j in val.value) {
  						if (hasOwn$$1.call(val.value, j)) {
  							urlConfigHtml += "<option value='" + escapeText(j) + "'" + (config[val.id] === j ? (selection = true) && " selected='selected'" : "") + ">" + escapeText(val.value[j]) + "</option>";
  						}
  					}
  				}
  				if (config[val.id] && !selection) {
  					escaped = escapeText(config[val.id]);
  					urlConfigHtml += "<option value='" + escaped + "' selected='selected' disabled='disabled'>" + escaped + "</option>";
  				}
  				urlConfigHtml += "</select>";
  			}
  		}

  		return urlConfigHtml;
  	}

  	// Handle "click" events on toolbar checkboxes and "change" for select menus.
  	// Updates the URL with the new state of `config.urlConfig` values.
  	function toolbarChanged() {
  		var updatedUrl,
  		    value,
  		    tests,
  		    field = this,
  		    params = {};

  		// Detect if field is a select menu or a checkbox
  		if ("selectedIndex" in field) {
  			value = field.options[field.selectedIndex].value || undefined;
  		} else {
  			value = field.checked ? field.defaultValue || true : undefined;
  		}

  		params[field.name] = value;
  		updatedUrl = setUrl(params);

  		// Check if we can apply the change without a page refresh
  		if ("hidepassed" === field.name && "replaceState" in window$1.history) {
  			QUnit.urlParams[field.name] = value;
  			config[field.name] = value || false;
  			tests = id("qunit-tests");
  			if (tests) {
  				var length = tests.children.length;
  				var children = tests.children;

  				if (field.checked) {
  					for (var i = 0; i < length; i++) {
  						var test$$1 = children[i];

  						if (test$$1 && test$$1.className.indexOf("pass") > -1) {
  							hiddenTests.push(test$$1);
  						}
  					}

  					var _iteratorNormalCompletion = true;
  					var _didIteratorError = false;
  					var _iteratorError = undefined;

  					try {
  						for (var _iterator = hiddenTests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
  							var hiddenTest = _step.value;

  							tests.removeChild(hiddenTest);
  						}
  					} catch (err) {
  						_didIteratorError = true;
  						_iteratorError = err;
  					} finally {
  						try {
  							if (!_iteratorNormalCompletion && _iterator.return) {
  								_iterator.return();
  							}
  						} finally {
  							if (_didIteratorError) {
  								throw _iteratorError;
  							}
  						}
  					}
  				} else {
  					while ((test$$1 = hiddenTests.pop()) != null) {
  						tests.appendChild(test$$1);
  					}
  				}
  			}
  			window$1.history.replaceState(null, "", updatedUrl);
  		} else {
  			window$1.location = updatedUrl;
  		}
  	}

  	function setUrl(params) {
  		var key,
  		    arrValue,
  		    i,
  		    querystring = "?",
  		    location = window$1.location;

  		params = QUnit.extend(QUnit.extend({}, QUnit.urlParams), params);

  		for (key in params) {

  			// Skip inherited or undefined properties
  			if (hasOwn$$1.call(params, key) && params[key] !== undefined) {

  				// Output a parameter for each value of this key
  				// (but usually just one)
  				arrValue = [].concat(params[key]);
  				for (i = 0; i < arrValue.length; i++) {
  					querystring += encodeURIComponent(key);
  					if (arrValue[i] !== true) {
  						querystring += "=" + encodeURIComponent(arrValue[i]);
  					}
  					querystring += "&";
  				}
  			}
  		}
  		return location.protocol + "//" + location.host + location.pathname + querystring.slice(0, -1);
  	}

  	function applyUrlParams() {
  		var i,
  		    selectedModules = [],
  		    modulesList = id("qunit-modulefilter-dropdown-list").getElementsByTagName("input"),
  		    filter = id("qunit-filter-input").value;

  		for (i = 0; i < modulesList.length; i++) {
  			if (modulesList[i].checked) {
  				selectedModules.push(modulesList[i].value);
  			}
  		}

  		window$1.location = setUrl({
  			filter: filter === "" ? undefined : filter,
  			moduleId: selectedModules.length === 0 ? undefined : selectedModules,

  			// Remove module and testId filter
  			module: undefined,
  			testId: undefined
  		});
  	}

  	function toolbarUrlConfigContainer() {
  		var urlConfigContainer = document.createElement("span");

  		urlConfigContainer.innerHTML = getUrlConfigHtml();
  		addClass(urlConfigContainer, "qunit-url-config");

  		addEvents(urlConfigContainer.getElementsByTagName("input"), "change", toolbarChanged);
  		addEvents(urlConfigContainer.getElementsByTagName("select"), "change", toolbarChanged);

  		return urlConfigContainer;
  	}

  	function abortTestsButton() {
  		var button = document.createElement("button");
  		button.id = "qunit-abort-tests-button";
  		button.innerHTML = "Abort";
  		addEvent(button, "click", abortTests);
  		return button;
  	}

  	function toolbarLooseFilter() {
  		var filter = document.createElement("form"),
  		    label = document.createElement("label"),
  		    input = document.createElement("input"),
  		    button = document.createElement("button");

  		addClass(filter, "qunit-filter");

  		label.innerHTML = "Filter: ";

  		input.type = "text";
  		input.value = config.filter || "";
  		input.name = "filter";
  		input.id = "qunit-filter-input";

  		button.innerHTML = "Go";

  		label.appendChild(input);

  		filter.appendChild(label);
  		filter.appendChild(document.createTextNode(" "));
  		filter.appendChild(button);
  		addEvent(filter, "submit", interceptNavigation);

  		return filter;
  	}

  	function moduleListHtml() {
  		var i,
  		    checked,
  		    html = "";

  		for (i = 0; i < config.modules.length; i++) {
  			if (config.modules[i].name !== "") {
  				checked = config.moduleId.indexOf(config.modules[i].moduleId) > -1;
  				html += "<li><label class='clickable" + (checked ? " checked" : "") + "'><input type='checkbox' " + "value='" + config.modules[i].moduleId + "'" + (checked ? " checked='checked'" : "") + " />" + escapeText(config.modules[i].name) + "</label></li>";
  			}
  		}

  		return html;
  	}

  	function toolbarModuleFilter() {
  		var commit,
  		    reset,
  		    moduleFilter = document.createElement("form"),
  		    label = document.createElement("label"),
  		    moduleSearch = document.createElement("input"),
  		    dropDown = document.createElement("div"),
  		    actions = document.createElement("span"),
  		    applyButton = document.createElement("button"),
  		    resetButton = document.createElement("button"),
  		    allModulesLabel = document.createElement("label"),
  		    allCheckbox = document.createElement("input"),
  		    dropDownList = document.createElement("ul"),
  		    dirty = false;

  		moduleSearch.id = "qunit-modulefilter-search";
  		moduleSearch.autocomplete = "off";
  		addEvent(moduleSearch, "input", searchInput);
  		addEvent(moduleSearch, "input", searchFocus);
  		addEvent(moduleSearch, "focus", searchFocus);
  		addEvent(moduleSearch, "click", searchFocus);

  		label.id = "qunit-modulefilter-search-container";
  		label.innerHTML = "Module: ";
  		label.appendChild(moduleSearch);

  		applyButton.textContent = "Apply";
  		applyButton.style.display = "none";

  		resetButton.textContent = "Reset";
  		resetButton.type = "reset";
  		resetButton.style.display = "none";

  		allCheckbox.type = "checkbox";
  		allCheckbox.checked = config.moduleId.length === 0;

  		allModulesLabel.className = "clickable";
  		if (config.moduleId.length) {
  			allModulesLabel.className = "checked";
  		}
  		allModulesLabel.appendChild(allCheckbox);
  		allModulesLabel.appendChild(document.createTextNode("All modules"));

  		actions.id = "qunit-modulefilter-actions";
  		actions.appendChild(applyButton);
  		actions.appendChild(resetButton);
  		actions.appendChild(allModulesLabel);
  		commit = actions.firstChild;
  		reset = commit.nextSibling;
  		addEvent(commit, "click", applyUrlParams);

  		dropDownList.id = "qunit-modulefilter-dropdown-list";
  		dropDownList.innerHTML = moduleListHtml();

  		dropDown.id = "qunit-modulefilter-dropdown";
  		dropDown.style.display = "none";
  		dropDown.appendChild(actions);
  		dropDown.appendChild(dropDownList);
  		addEvent(dropDown, "change", selectionChange);
  		selectionChange();

  		moduleFilter.id = "qunit-modulefilter";
  		moduleFilter.appendChild(label);
  		moduleFilter.appendChild(dropDown);
  		addEvent(moduleFilter, "submit", interceptNavigation);
  		addEvent(moduleFilter, "reset", function () {

  			// Let the reset happen, then update styles
  			window$1.setTimeout(selectionChange);
  		});

  		// Enables show/hide for the dropdown
  		function searchFocus() {
  			if (dropDown.style.display !== "none") {
  				return;
  			}

  			dropDown.style.display = "block";
  			addEvent(document, "click", hideHandler);
  			addEvent(document, "keydown", hideHandler);

  			// Hide on Escape keydown or outside-container click
  			function hideHandler(e) {
  				var inContainer = moduleFilter.contains(e.target);

  				if (e.keyCode === 27 || !inContainer) {
  					if (e.keyCode === 27 && inContainer) {
  						moduleSearch.focus();
  					}
  					dropDown.style.display = "none";
  					removeEvent(document, "click", hideHandler);
  					removeEvent(document, "keydown", hideHandler);
  					moduleSearch.value = "";
  					searchInput();
  				}
  			}
  		}

  		// Processes module search box input
  		function searchInput() {
  			var i,
  			    item,
  			    searchText = moduleSearch.value.toLowerCase(),
  			    listItems = dropDownList.children;

  			for (i = 0; i < listItems.length; i++) {
  				item = listItems[i];
  				if (!searchText || item.textContent.toLowerCase().indexOf(searchText) > -1) {
  					item.style.display = "";
  				} else {
  					item.style.display = "none";
  				}
  			}
  		}

  		// Processes selection changes
  		function selectionChange(evt) {
  			var i,
  			    item,
  			    checkbox = evt && evt.target || allCheckbox,
  			    modulesList = dropDownList.getElementsByTagName("input"),
  			    selectedNames = [];

  			toggleClass(checkbox.parentNode, "checked", checkbox.checked);

  			dirty = false;
  			if (checkbox.checked && checkbox !== allCheckbox) {
  				allCheckbox.checked = false;
  				removeClass(allCheckbox.parentNode, "checked");
  			}
  			for (i = 0; i < modulesList.length; i++) {
  				item = modulesList[i];
  				if (!evt) {
  					toggleClass(item.parentNode, "checked", item.checked);
  				} else if (checkbox === allCheckbox && checkbox.checked) {
  					item.checked = false;
  					removeClass(item.parentNode, "checked");
  				}
  				dirty = dirty || item.checked !== item.defaultChecked;
  				if (item.checked) {
  					selectedNames.push(item.parentNode.textContent);
  				}
  			}

  			commit.style.display = reset.style.display = dirty ? "" : "none";
  			moduleSearch.placeholder = selectedNames.join(", ") || allCheckbox.parentNode.textContent;
  			moduleSearch.title = "Type to filter list. Current selection:\n" + (selectedNames.join("\n") || allCheckbox.parentNode.textContent);
  		}

  		return moduleFilter;
  	}

  	function appendToolbar() {
  		var toolbar = id("qunit-testrunner-toolbar");

  		if (toolbar) {
  			toolbar.appendChild(toolbarUrlConfigContainer());
  			toolbar.appendChild(toolbarModuleFilter());
  			toolbar.appendChild(toolbarLooseFilter());
  			toolbar.appendChild(document.createElement("div")).className = "clearfix";
  		}
  	}

  	function appendHeader() {
  		var header = id("qunit-header");

  		if (header) {
  			header.innerHTML = "<a href='" + escapeText(unfilteredUrl) + "'>" + header.innerHTML + "</a> ";
  		}
  	}

  	function appendBanner() {
  		var banner = id("qunit-banner");

  		if (banner) {
  			banner.className = "";
  		}
  	}

  	function appendTestResults() {
  		var tests = id("qunit-tests"),
  		    result = id("qunit-testresult"),
  		    controls;

  		if (result) {
  			result.parentNode.removeChild(result);
  		}

  		if (tests) {
  			tests.innerHTML = "";
  			result = document.createElement("p");
  			result.id = "qunit-testresult";
  			result.className = "result";
  			tests.parentNode.insertBefore(result, tests);
  			result.innerHTML = "<div id=\"qunit-testresult-display\">Running...<br />&#160;</div>" + "<div id=\"qunit-testresult-controls\"></div>" + "<div class=\"clearfix\"></div>";
  			controls = id("qunit-testresult-controls");
  		}

  		if (controls) {
  			controls.appendChild(abortTestsButton());
  		}
  	}

  	function appendFilteredTest() {
  		var testId = QUnit.config.testId;
  		if (!testId || testId.length <= 0) {
  			return "";
  		}
  		return "<div id='qunit-filteredTest'>Rerunning selected tests: " + escapeText(testId.join(", ")) + " <a id='qunit-clearFilter' href='" + escapeText(unfilteredUrl) + "'>Run all tests</a></div>";
  	}

  	function appendUserAgent() {
  		var userAgent = id("qunit-userAgent");

  		if (userAgent) {
  			userAgent.innerHTML = "";
  			userAgent.appendChild(document.createTextNode("QUnit " + QUnit.version + "; " + navigator.userAgent));
  		}
  	}

  	function appendInterface() {
  		var qunit = id("qunit");

  		if (qunit) {
  			qunit.innerHTML = "<h1 id='qunit-header'>" + escapeText(document.title) + "</h1>" + "<h2 id='qunit-banner'></h2>" + "<div id='qunit-testrunner-toolbar'></div>" + appendFilteredTest() + "<h2 id='qunit-userAgent'></h2>" + "<ol id='qunit-tests'></ol>";
  		}

  		appendHeader();
  		appendBanner();
  		appendTestResults();
  		appendUserAgent();
  		appendToolbar();
  	}

  	function appendTest(name, testId, moduleName) {
  		var title,
  		    rerunTrigger,
  		    testBlock,
  		    assertList,
  		    tests = id("qunit-tests");

  		if (!tests) {
  			return;
  		}

  		title = document.createElement("strong");
  		title.innerHTML = getNameHtml(name, moduleName);

  		rerunTrigger = document.createElement("a");
  		rerunTrigger.innerHTML = "Rerun";
  		rerunTrigger.href = setUrl({ testId: testId });

  		testBlock = document.createElement("li");
  		testBlock.appendChild(title);
  		testBlock.appendChild(rerunTrigger);
  		testBlock.id = "qunit-test-output-" + testId;

  		assertList = document.createElement("ol");
  		assertList.className = "qunit-assert-list";

  		testBlock.appendChild(assertList);

  		tests.appendChild(testBlock);
  	}

  	// HTML Reporter initialization and load
  	QUnit.begin(function (details) {
  		var i, moduleObj;

  		// Sort modules by name for the picker
  		for (i = 0; i < details.modules.length; i++) {
  			moduleObj = details.modules[i];
  			if (moduleObj.name) {
  				modulesList.push(moduleObj.name);
  			}
  		}
  		modulesList.sort(function (a, b) {
  			return a.localeCompare(b);
  		});

  		// Initialize QUnit elements
  		appendInterface();
  	});

  	QUnit.done(function (details) {
  		var banner = id("qunit-banner"),
  		    tests = id("qunit-tests"),
  		    abortButton = id("qunit-abort-tests-button"),
  		    totalTests = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests,
  		    html = [totalTests, " tests completed in ", details.runtime, " milliseconds, with ", stats.failedTests, " failed, ", stats.skippedTests, " skipped, and ", stats.todoTests, " todo.<br />", "<span class='passed'>", details.passed, "</span> assertions of <span class='total'>", details.total, "</span> passed, <span class='failed'>", details.failed, "</span> failed."].join(""),
  		    test$$1,
  		    assertLi,
  		    assertList;

  		// Update remaining tests to aborted
  		if (abortButton && abortButton.disabled) {
  			html = "Tests aborted after " + details.runtime + " milliseconds.";

  			for (var i = 0; i < tests.children.length; i++) {
  				test$$1 = tests.children[i];
  				if (test$$1.className === "" || test$$1.className === "running") {
  					test$$1.className = "aborted";
  					assertList = test$$1.getElementsByTagName("ol")[0];
  					assertLi = document.createElement("li");
  					assertLi.className = "fail";
  					assertLi.innerHTML = "Test aborted.";
  					assertList.appendChild(assertLi);
  				}
  			}
  		}

  		if (banner && (!abortButton || abortButton.disabled === false)) {
  			banner.className = stats.failedTests ? "qunit-fail" : "qunit-pass";
  		}

  		if (abortButton) {
  			abortButton.parentNode.removeChild(abortButton);
  		}

  		if (tests) {
  			id("qunit-testresult-display").innerHTML = html;
  		}

  		if (config.altertitle && document.title) {

  			// Show  for good,  for bad suite result in title
  			// use escape sequences in case file gets loaded with non-utf-8
  			// charset
  			document.title = [stats.failedTests ? "\u2716" : "\u2714", document.title.replace(/^[\u2714\u2716] /i, "")].join(" ");
  		}

  		// Scroll back to top to show results
  		if (config.scrolltop && window$1.scrollTo) {
  			window$1.scrollTo(0, 0);
  		}
  	});

  	function getNameHtml(name, module) {
  		var nameHtml = "";

  		if (module) {
  			nameHtml = "<span class='module-name'>" + escapeText(module) + "</span>: ";
  		}

  		nameHtml += "<span class='test-name'>" + escapeText(name) + "</span>";

  		return nameHtml;
  	}

  	function getProgressHtml(runtime, stats, total) {
  		var completed = stats.passedTests + stats.skippedTests + stats.todoTests + stats.failedTests;

  		return ["<br />", completed, " / ", total, " tests completed in ", runtime, " milliseconds, with ", stats.failedTests, " failed, ", stats.skippedTests, " skipped, and ", stats.todoTests, " todo."].join("");
  	}

  	QUnit.testStart(function (details) {
  		var running, bad;

  		appendTest(details.name, details.testId, details.module);

  		running = id("qunit-testresult-display");

  		if (running) {
  			addClass(running, "running");

  			bad = QUnit.config.reorder && details.previousFailure;

  			running.innerHTML = [bad ? "Rerunning previously failed test: <br />" : "Running: <br />", getNameHtml(details.name, details.module), getProgressHtml(now() - config.started, stats, Test.count)].join("");
  		}
  	});

  	function stripHtml(string) {

  		// Strip tags, html entity and whitespaces
  		return string.replace(/<\/?[^>]+(>|$)/g, "").replace(/&quot;/g, "").replace(/\s+/g, "");
  	}

  	QUnit.log(function (details) {
  		var assertList,
  		    assertLi,
  		    message,
  		    expected,
  		    actual,
  		    diff$$1,
  		    showDiff = false,
  		    testItem = id("qunit-test-output-" + details.testId);

  		if (!testItem) {
  			return;
  		}

  		message = escapeText(details.message) || (details.result ? "okay" : "failed");
  		message = "<span class='test-message'>" + message + "</span>";
  		message += "<span class='runtime'>@ " + details.runtime + " ms</span>";

  		// The pushFailure doesn't provide details.expected
  		// when it calls, it's implicit to also not show expected and diff stuff
  		// Also, we need to check details.expected existence, as it can exist and be undefined
  		if (!details.result && hasOwn$$1.call(details, "expected")) {
  			if (details.negative) {
  				expected = "NOT " + QUnit.dump.parse(details.expected);
  			} else {
  				expected = QUnit.dump.parse(details.expected);
  			}

  			actual = QUnit.dump.parse(details.actual);
  			message += "<table><tr class='test-expected'><th>Expected: </th><td><pre>" + escapeText(expected) + "</pre></td></tr>";

  			if (actual !== expected) {

  				message += "<tr class='test-actual'><th>Result: </th><td><pre>" + escapeText(actual) + "</pre></td></tr>";

  				if (typeof details.actual === "number" && typeof details.expected === "number") {
  					if (!isNaN(details.actual) && !isNaN(details.expected)) {
  						showDiff = true;
  						diff$$1 = details.actual - details.expected;
  						diff$$1 = (diff$$1 > 0 ? "+" : "") + diff$$1;
  					}
  				} else if (typeof details.actual !== "boolean" && typeof details.expected !== "boolean") {
  					diff$$1 = QUnit.diff(expected, actual);

  					// don't show diff if there is zero overlap
  					showDiff = stripHtml(diff$$1).length !== stripHtml(expected).length + stripHtml(actual).length;
  				}

  				if (showDiff) {
  					message += "<tr class='test-diff'><th>Diff: </th><td><pre>" + diff$$1 + "</pre></td></tr>";
  				}
  			} else if (expected.indexOf("[object Array]") !== -1 || expected.indexOf("[object Object]") !== -1) {
  				message += "<tr class='test-message'><th>Message: </th><td>" + "Diff suppressed as the depth of object is more than current max depth (" + QUnit.config.maxDepth + ").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to " + " run with a higher max depth or <a href='" + escapeText(setUrl({ maxDepth: -1 })) + "'>" + "Rerun</a> without max depth.</p></td></tr>";
  			} else {
  				message += "<tr class='test-message'><th>Message: </th><td>" + "Diff suppressed as the expected and actual results have an equivalent" + " serialization</td></tr>";
  			}

  			if (details.source) {
  				message += "<tr class='test-source'><th>Source: </th><td><pre>" + escapeText(details.source) + "</pre></td></tr>";
  			}

  			message += "</table>";

  			// This occurs when pushFailure is set and we have an extracted stack trace
  		} else if (!details.result && details.source) {
  			message += "<table>" + "<tr class='test-source'><th>Source: </th><td><pre>" + escapeText(details.source) + "</pre></td></tr>" + "</table>";
  		}

  		assertList = testItem.getElementsByTagName("ol")[0];

  		assertLi = document.createElement("li");
  		assertLi.className = details.result ? "pass" : "fail";
  		assertLi.innerHTML = message;
  		assertList.appendChild(assertLi);
  	});

  	QUnit.testDone(function (details) {
  		var testTitle,
  		    time,
  		    testItem,
  		    assertList,
  		    status,
  		    good,
  		    bad,
  		    testCounts,
  		    skipped,
  		    sourceName,
  		    tests = id("qunit-tests");

  		if (!tests) {
  			return;
  		}

  		testItem = id("qunit-test-output-" + details.testId);

  		removeClass(testItem, "running");

  		if (details.failed > 0) {
  			status = "failed";
  		} else if (details.todo) {
  			status = "todo";
  		} else {
  			status = details.skipped ? "skipped" : "passed";
  		}

  		assertList = testItem.getElementsByTagName("ol")[0];

  		good = details.passed;
  		bad = details.failed;

  		// This test passed if it has no unexpected failed assertions
  		var testPassed = details.failed > 0 ? details.todo : !details.todo;

  		if (testPassed) {

  			// Collapse the passing tests
  			addClass(assertList, "qunit-collapsed");
  		} else if (config.collapse) {
  			if (!collapseNext) {

  				// Skip collapsing the first failing test
  				collapseNext = true;
  			} else {

  				// Collapse remaining tests
  				addClass(assertList, "qunit-collapsed");
  			}
  		}

  		// The testItem.firstChild is the test name
  		testTitle = testItem.firstChild;

  		testCounts = bad ? "<b class='failed'>" + bad + "</b>, " + "<b class='passed'>" + good + "</b>, " : "";

  		testTitle.innerHTML += " <b class='counts'>(" + testCounts + details.assertions.length + ")</b>";

  		if (details.skipped) {
  			stats.skippedTests++;

  			testItem.className = "skipped";
  			skipped = document.createElement("em");
  			skipped.className = "qunit-skipped-label";
  			skipped.innerHTML = "skipped";
  			testItem.insertBefore(skipped, testTitle);
  		} else {
  			addEvent(testTitle, "click", function () {
  				toggleClass(assertList, "qunit-collapsed");
  			});

  			testItem.className = testPassed ? "pass" : "fail";

  			if (details.todo) {
  				var todoLabel = document.createElement("em");
  				todoLabel.className = "qunit-todo-label";
  				todoLabel.innerHTML = "todo";
  				testItem.className += " todo";
  				testItem.insertBefore(todoLabel, testTitle);
  			}

  			time = document.createElement("span");
  			time.className = "runtime";
  			time.innerHTML = details.runtime + " ms";
  			testItem.insertBefore(time, assertList);

  			if (!testPassed) {
  				stats.failedTests++;
  			} else if (details.todo) {
  				stats.todoTests++;
  			} else {
  				stats.passedTests++;
  			}
  		}

  		// Show the source of the test when showing assertions
  		if (details.source) {
  			sourceName = document.createElement("p");
  			sourceName.innerHTML = "<strong>Source: </strong>" + escapeText(details.source);
  			addClass(sourceName, "qunit-source");
  			if (testPassed) {
  				addClass(sourceName, "qunit-collapsed");
  			}
  			addEvent(testTitle, "click", function () {
  				toggleClass(sourceName, "qunit-collapsed");
  			});
  			testItem.appendChild(sourceName);
  		}

  		if (config.hidepassed && status === "passed") {

  			// use removeChild instead of remove because of support
  			hiddenTests.push(testItem);

  			tests.removeChild(testItem);
  		}
  	});

  	// Avoid readyState issue with phantomjs
  	// Ref: #818
  	var notPhantom = function (p) {
  		return !(p && p.version && p.version.major > 0);
  	}(window$1.phantom);

  	if (notPhantom && document.readyState === "complete") {
  		QUnit.load();
  	} else {
  		addEvent(window$1, "load", QUnit.load);
  	}

  	// Wrap window.onerror. We will call the original window.onerror to see if
  	// the existing handler fully handles the error; if not, we will call the
  	// QUnit.onError function.
  	var originalWindowOnError = window$1.onerror;

  	// Cover uncaught exceptions
  	// Returning true will suppress the default browser handler,
  	// returning false will let it run.
  	window$1.onerror = function (message, fileName, lineNumber, columnNumber, errorObj) {
  		var ret = false;
  		if (originalWindowOnError) {
  			for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
  				args[_key - 5] = arguments[_key];
  			}

  			ret = originalWindowOnError.call.apply(originalWindowOnError, [this, message, fileName, lineNumber, columnNumber, errorObj].concat(args));
  		}

  		// Treat return value as window.onerror itself does,
  		// Only do our handling if not suppressed.
  		if (ret !== true) {
  			var error = {
  				message: message,
  				fileName: fileName,
  				lineNumber: lineNumber
  			};

  			// According to
  			// https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,
  			// most modern browsers support an errorObj argument; use that to
  			// get a full stack trace if it's available.
  			if (errorObj && errorObj.stack) {
  				error.stacktrace = extractStacktrace(errorObj, 0);
  			}

  			ret = QUnit.onError(error);
  		}

  		return ret;
  	};

  	// Listen for unhandled rejections, and call QUnit.onUnhandledRejection
  	window$1.addEventListener("unhandledrejection", function (event) {
  		QUnit.onUnhandledRejection(event.reason);
  	});
  })();

  /*
   * This file is a modified version of google-diff-match-patch's JavaScript implementation
   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),
   * modifications are licensed as more fully set forth in LICENSE.txt.
   *
   * The original source of google-diff-match-patch is attributable and licensed as follows:
   *
   * Copyright 2006 Google Inc.
   * https://code.google.com/p/google-diff-match-patch/
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * https://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * More Info:
   *  https://code.google.com/p/google-diff-match-patch/
   *
   * Usage: QUnit.diff(expected, actual)
   *
   */
  QUnit.diff = function () {
  	function DiffMatchPatch() {}

  	//  DIFF FUNCTIONS

  	/**
    * The data structure representing a diff is an array of tuples:
    * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
    * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
    */
  	var DIFF_DELETE = -1,
  	    DIFF_INSERT = 1,
  	    DIFF_EQUAL = 0;

  	/**
    * Find the differences between two texts.  Simplifies the problem by stripping
    * any common prefix or suffix off the texts before diffing.
    * @param {string} text1 Old string to be diffed.
    * @param {string} text2 New string to be diffed.
    * @param {boolean=} optChecklines Optional speedup flag. If present and false,
    *     then don't run a line-level diff first to identify the changed areas.
    *     Defaults to true, which does a faster, slightly less optimal diff.
    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
    */
  	DiffMatchPatch.prototype.DiffMain = function (text1, text2, optChecklines) {
  		var deadline, checklines, commonlength, commonprefix, commonsuffix, diffs;

  		// The diff must be complete in up to 1 second.
  		deadline = new Date().getTime() + 1000;

  		// Check for null inputs.
  		if (text1 === null || text2 === null) {
  			throw new Error("Null input. (DiffMain)");
  		}

  		// Check for equality (speedup).
  		if (text1 === text2) {
  			if (text1) {
  				return [[DIFF_EQUAL, text1]];
  			}
  			return [];
  		}

  		if (typeof optChecklines === "undefined") {
  			optChecklines = true;
  		}

  		checklines = optChecklines;

  		// Trim off common prefix (speedup).
  		commonlength = this.diffCommonPrefix(text1, text2);
  		commonprefix = text1.substring(0, commonlength);
  		text1 = text1.substring(commonlength);
  		text2 = text2.substring(commonlength);

  		// Trim off common suffix (speedup).
  		commonlength = this.diffCommonSuffix(text1, text2);
  		commonsuffix = text1.substring(text1.length - commonlength);
  		text1 = text1.substring(0, text1.length - commonlength);
  		text2 = text2.substring(0, text2.length - commonlength);

  		// Compute the diff on the middle block.
  		diffs = this.diffCompute(text1, text2, checklines, deadline);

  		// Restore the prefix and suffix.
  		if (commonprefix) {
  			diffs.unshift([DIFF_EQUAL, commonprefix]);
  		}
  		if (commonsuffix) {
  			diffs.push([DIFF_EQUAL, commonsuffix]);
  		}
  		this.diffCleanupMerge(diffs);
  		return diffs;
  	};

  	/**
    * Reduce the number of edits by eliminating operationally trivial equalities.
    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
    */
  	DiffMatchPatch.prototype.diffCleanupEfficiency = function (diffs) {
  		var changes, equalities, equalitiesLength, lastequality, pointer, preIns, preDel, postIns, postDel;
  		changes = false;
  		equalities = []; // Stack of indices where equalities are found.
  		equalitiesLength = 0; // Keeping our own length var is faster in JS.
  		/** @type {?string} */
  		lastequality = null;

  		// Always equal to diffs[equalities[equalitiesLength - 1]][1]
  		pointer = 0; // Index of current position.

  		// Is there an insertion operation before the last equality.
  		preIns = false;

  		// Is there a deletion operation before the last equality.
  		preDel = false;

  		// Is there an insertion operation after the last equality.
  		postIns = false;

  		// Is there a deletion operation after the last equality.
  		postDel = false;
  		while (pointer < diffs.length) {

  			// Equality found.
  			if (diffs[pointer][0] === DIFF_EQUAL) {
  				if (diffs[pointer][1].length < 4 && (postIns || postDel)) {

  					// Candidate found.
  					equalities[equalitiesLength++] = pointer;
  					preIns = postIns;
  					preDel = postDel;
  					lastequality = diffs[pointer][1];
  				} else {

  					// Not a candidate, and can never become one.
  					equalitiesLength = 0;
  					lastequality = null;
  				}
  				postIns = postDel = false;

  				// An insertion or deletion.
  			} else {

  				if (diffs[pointer][0] === DIFF_DELETE) {
  					postDel = true;
  				} else {
  					postIns = true;
  				}

  				/*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
  				if (lastequality && (preIns && preDel && postIns && postDel || lastequality.length < 2 && preIns + preDel + postIns + postDel === 3)) {

  					// Duplicate record.
  					diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);

  					// Change second copy to insert.
  					diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
  					equalitiesLength--; // Throw away the equality we just deleted;
  					lastequality = null;
  					if (preIns && preDel) {

  						// No changes made which could affect previous entry, keep going.
  						postIns = postDel = true;
  						equalitiesLength = 0;
  					} else {
  						equalitiesLength--; // Throw away the previous equality.
  						pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
  						postIns = postDel = false;
  					}
  					changes = true;
  				}
  			}
  			pointer++;
  		}

  		if (changes) {
  			this.diffCleanupMerge(diffs);
  		}
  	};

  	/**
    * Convert a diff array into a pretty HTML report.
    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
    * @param {integer} string to be beautified.
    * @return {string} HTML representation.
    */
  	DiffMatchPatch.prototype.diffPrettyHtml = function (diffs) {
  		var op,
  		    data,
  		    x,
  		    html = [];
  		for (x = 0; x < diffs.length; x++) {
  			op = diffs[x][0]; // Operation (insert, delete, equal)
  			data = diffs[x][1]; // Text of change.
  			switch (op) {
  				case DIFF_INSERT:
  					html[x] = "<ins>" + escapeText(data) + "</ins>";
  					break;
  				case DIFF_DELETE:
  					html[x] = "<del>" + escapeText(data) + "</del>";
  					break;
  				case DIFF_EQUAL:
  					html[x] = "<span>" + escapeText(data) + "</span>";
  					break;
  			}
  		}
  		return html.join("");
  	};

  	/**
    * Determine the common prefix of two strings.
    * @param {string} text1 First string.
    * @param {string} text2 Second string.
    * @return {number} The number of characters common to the start of each
    *     string.
    */
  	DiffMatchPatch.prototype.diffCommonPrefix = function (text1, text2) {
  		var pointermid, pointermax, pointermin, pointerstart;

  		// Quick check for common null cases.
  		if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
  			return 0;
  		}

  		// Binary search.
  		// Performance analysis: https://neil.fraser.name/news/2007/10/09/
  		pointermin = 0;
  		pointermax = Math.min(text1.length, text2.length);
  		pointermid = pointermax;
  		pointerstart = 0;
  		while (pointermin < pointermid) {
  			if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
  				pointermin = pointermid;
  				pointerstart = pointermin;
  			} else {
  				pointermax = pointermid;
  			}
  			pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  		}
  		return pointermid;
  	};

  	/**
    * Determine the common suffix of two strings.
    * @param {string} text1 First string.
    * @param {string} text2 Second string.
    * @return {number} The number of characters common to the end of each string.
    */
  	DiffMatchPatch.prototype.diffCommonSuffix = function (text1, text2) {
  		var pointermid, pointermax, pointermin, pointerend;

  		// Quick check for common null cases.
  		if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
  			return 0;
  		}

  		// Binary search.
  		// Performance analysis: https://neil.fraser.name/news/2007/10/09/
  		pointermin = 0;
  		pointermax = Math.min(text1.length, text2.length);
  		pointermid = pointermax;
  		pointerend = 0;
  		while (pointermin < pointermid) {
  			if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
  				pointermin = pointermid;
  				pointerend = pointermin;
  			} else {
  				pointermax = pointermid;
  			}
  			pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  		}
  		return pointermid;
  	};

  	/**
    * Find the differences between two texts.  Assumes that the texts do not
    * have any common prefix or suffix.
    * @param {string} text1 Old string to be diffed.
    * @param {string} text2 New string to be diffed.
    * @param {boolean} checklines Speedup flag.  If false, then don't run a
    *     line-level diff first to identify the changed areas.
    *     If true, then run a faster, slightly less optimal diff.
    * @param {number} deadline Time when the diff should be complete by.
    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
    * @private
    */
  	DiffMatchPatch.prototype.diffCompute = function (text1, text2, checklines, deadline) {
  		var diffs, longtext, shorttext, i, hm, text1A, text2A, text1B, text2B, midCommon, diffsA, diffsB;

  		if (!text1) {

  			// Just add some text (speedup).
  			return [[DIFF_INSERT, text2]];
  		}

  		if (!text2) {

  			// Just delete some text (speedup).
  			return [[DIFF_DELETE, text1]];
  		}

  		longtext = text1.length > text2.length ? text1 : text2;
  		shorttext = text1.length > text2.length ? text2 : text1;
  		i = longtext.indexOf(shorttext);
  		if (i !== -1) {

  			// Shorter text is inside the longer text (speedup).
  			diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]];

  			// Swap insertions for deletions if diff is reversed.
  			if (text1.length > text2.length) {
  				diffs[0][0] = diffs[2][0] = DIFF_DELETE;
  			}
  			return diffs;
  		}

  		if (shorttext.length === 1) {

  			// Single character string.
  			// After the previous speedup, the character can't be an equality.
  			return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  		}

  		// Check to see if the problem can be split in two.
  		hm = this.diffHalfMatch(text1, text2);
  		if (hm) {

  			// A half-match was found, sort out the return data.
  			text1A = hm[0];
  			text1B = hm[1];
  			text2A = hm[2];
  			text2B = hm[3];
  			midCommon = hm[4];

  			// Send both pairs off for separate processing.
  			diffsA = this.DiffMain(text1A, text2A, checklines, deadline);
  			diffsB = this.DiffMain(text1B, text2B, checklines, deadline);

  			// Merge the results.
  			return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
  		}

  		if (checklines && text1.length > 100 && text2.length > 100) {
  			return this.diffLineMode(text1, text2, deadline);
  		}

  		return this.diffBisect(text1, text2, deadline);
  	};

  	/**
    * Do the two texts share a substring which is at least half the length of the
    * longer text?
    * This speedup can produce non-minimal diffs.
    * @param {string} text1 First string.
    * @param {string} text2 Second string.
    * @return {Array.<string>} Five element Array, containing the prefix of
    *     text1, the suffix of text1, the prefix of text2, the suffix of
    *     text2 and the common middle.  Or null if there was no match.
    * @private
    */
  	DiffMatchPatch.prototype.diffHalfMatch = function (text1, text2) {
  		var longtext, shorttext, dmp, text1A, text2B, text2A, text1B, midCommon, hm1, hm2, hm;

  		longtext = text1.length > text2.length ? text1 : text2;
  		shorttext = text1.length > text2.length ? text2 : text1;
  		if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
  			return null; // Pointless.
  		}
  		dmp = this; // 'this' becomes 'window' in a closure.

  		/**
     * Does a substring of shorttext exist within longtext such that the substring
     * is at least half the length of longtext?
     * Closure, but does not reference any external variables.
     * @param {string} longtext Longer string.
     * @param {string} shorttext Shorter string.
     * @param {number} i Start index of quarter length substring within longtext.
     * @return {Array.<string>} Five element Array, containing the prefix of
     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
     *     of shorttext and the common middle.  Or null if there was no match.
     * @private
     */
  		function diffHalfMatchI(longtext, shorttext, i) {
  			var seed, j, bestCommon, prefixLength, suffixLength, bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;

  			// Start with a 1/4 length substring at position i as a seed.
  			seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
  			j = -1;
  			bestCommon = "";
  			while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {
  				prefixLength = dmp.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));
  				suffixLength = dmp.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
  				if (bestCommon.length < suffixLength + prefixLength) {
  					bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
  					bestLongtextA = longtext.substring(0, i - suffixLength);
  					bestLongtextB = longtext.substring(i + prefixLength);
  					bestShorttextA = shorttext.substring(0, j - suffixLength);
  					bestShorttextB = shorttext.substring(j + prefixLength);
  				}
  			}
  			if (bestCommon.length * 2 >= longtext.length) {
  				return [bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon];
  			} else {
  				return null;
  			}
  		}

  		// First check if the second quarter is the seed for a half-match.
  		hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));

  		// Check again based on the third quarter.
  		hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
  		if (!hm1 && !hm2) {
  			return null;
  		} else if (!hm2) {
  			hm = hm1;
  		} else if (!hm1) {
  			hm = hm2;
  		} else {

  			// Both matched.  Select the longest.
  			hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  		}

  		// A half-match was found, sort out the return data.
  		if (text1.length > text2.length) {
  			text1A = hm[0];
  			text1B = hm[1];
  			text2A = hm[2];
  			text2B = hm[3];
  		} else {
  			text2A = hm[0];
  			text2B = hm[1];
  			text1A = hm[2];
  			text1B = hm[3];
  		}
  		midCommon = hm[4];
  		return [text1A, text1B, text2A, text2B, midCommon];
  	};

  	/**
    * Do a quick line-level diff on both strings, then rediff the parts for
    * greater accuracy.
    * This speedup can produce non-minimal diffs.
    * @param {string} text1 Old string to be diffed.
    * @param {string} text2 New string to be diffed.
    * @param {number} deadline Time when the diff should be complete by.
    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
    * @private
    */
  	DiffMatchPatch.prototype.diffLineMode = function (text1, text2, deadline) {
  		var a, diffs, linearray, pointer, countInsert, countDelete, textInsert, textDelete, j;

  		// Scan the text on a line-by-line basis first.
  		a = this.diffLinesToChars(text1, text2);
  		text1 = a.chars1;
  		text2 = a.chars2;
  		linearray = a.lineArray;

  		diffs = this.DiffMain(text1, text2, false, deadline);

  		// Convert the diff back to original text.
  		this.diffCharsToLines(diffs, linearray);

  		// Eliminate freak matches (e.g. blank lines)
  		this.diffCleanupSemantic(diffs);

  		// Rediff any replacement blocks, this time character-by-character.
  		// Add a dummy entry at the end.
  		diffs.push([DIFF_EQUAL, ""]);
  		pointer = 0;
  		countDelete = 0;
  		countInsert = 0;
  		textDelete = "";
  		textInsert = "";
  		while (pointer < diffs.length) {
  			switch (diffs[pointer][0]) {
  				case DIFF_INSERT:
  					countInsert++;
  					textInsert += diffs[pointer][1];
  					break;
  				case DIFF_DELETE:
  					countDelete++;
  					textDelete += diffs[pointer][1];
  					break;
  				case DIFF_EQUAL:

  					// Upon reaching an equality, check for prior redundancies.
  					if (countDelete >= 1 && countInsert >= 1) {

  						// Delete the offending records and add the merged ones.
  						diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert);
  						pointer = pointer - countDelete - countInsert;
  						a = this.DiffMain(textDelete, textInsert, false, deadline);
  						for (j = a.length - 1; j >= 0; j--) {
  							diffs.splice(pointer, 0, a[j]);
  						}
  						pointer = pointer + a.length;
  					}
  					countInsert = 0;
  					countDelete = 0;
  					textDelete = "";
  					textInsert = "";
  					break;
  			}
  			pointer++;
  		}
  		diffs.pop(); // Remove the dummy entry at the end.

  		return diffs;
  	};

  	/**
    * Find the 'middle snake' of a diff, split the problem in two
    * and return the recursively constructed diff.
    * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
    * @param {string} text1 Old string to be diffed.
    * @param {string} text2 New string to be diffed.
    * @param {number} deadline Time at which to bail if not yet complete.
    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
    * @private
    */
  	DiffMatchPatch.prototype.diffBisect = function (text1, text2, deadline) {
  		var text1Length, text2Length, maxD, vOffset, vLength, v1, v2, x, delta, front, k1start, k1end, k2start, k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;

  		// Cache the text lengths to prevent multiple calls.
  		text1Length = text1.length;
  		text2Length = text2.length;
  		maxD = Math.ceil((text1Length + text2Length) / 2);
  		vOffset = maxD;
  		vLength = 2 * maxD;
  		v1 = new Array(vLength);
  		v2 = new Array(vLength);

  		// Setting all elements to -1 is faster in Chrome & Firefox than mixing
  		// integers and undefined.
  		for (x = 0; x < vLength; x++) {
  			v1[x] = -1;
  			v2[x] = -1;
  		}
  		v1[vOffset + 1] = 0;
  		v2[vOffset + 1] = 0;
  		delta = text1Length - text2Length;

  		// If the total number of characters is odd, then the front path will collide
  		// with the reverse path.
  		front = delta % 2 !== 0;

  		// Offsets for start and end of k loop.
  		// Prevents mapping of space beyond the grid.
  		k1start = 0;
  		k1end = 0;
  		k2start = 0;
  		k2end = 0;
  		for (d = 0; d < maxD; d++) {

  			// Bail out if deadline is reached.
  			if (new Date().getTime() > deadline) {
  				break;
  			}

  			// Walk the front path one step.
  			for (k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
  				k1Offset = vOffset + k1;
  				if (k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1]) {
  					x1 = v1[k1Offset + 1];
  				} else {
  					x1 = v1[k1Offset - 1] + 1;
  				}
  				y1 = x1 - k1;
  				while (x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1)) {
  					x1++;
  					y1++;
  				}
  				v1[k1Offset] = x1;
  				if (x1 > text1Length) {

  					// Ran off the right of the graph.
  					k1end += 2;
  				} else if (y1 > text2Length) {

  					// Ran off the bottom of the graph.
  					k1start += 2;
  				} else if (front) {
  					k2Offset = vOffset + delta - k1;
  					if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {

  						// Mirror x2 onto top-left coordinate system.
  						x2 = text1Length - v2[k2Offset];
  						if (x1 >= x2) {

  							// Overlap detected.
  							return this.diffBisectSplit(text1, text2, x1, y1, deadline);
  						}
  					}
  				}
  			}

  			// Walk the reverse path one step.
  			for (k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
  				k2Offset = vOffset + k2;
  				if (k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1]) {
  					x2 = v2[k2Offset + 1];
  				} else {
  					x2 = v2[k2Offset - 1] + 1;
  				}
  				y2 = x2 - k2;
  				while (x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1)) {
  					x2++;
  					y2++;
  				}
  				v2[k2Offset] = x2;
  				if (x2 > text1Length) {

  					// Ran off the left of the graph.
  					k2end += 2;
  				} else if (y2 > text2Length) {

  					// Ran off the top of the graph.
  					k2start += 2;
  				} else if (!front) {
  					k1Offset = vOffset + delta - k2;
  					if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
  						x1 = v1[k1Offset];
  						y1 = vOffset + x1 - k1Offset;

  						// Mirror x2 onto top-left coordinate system.
  						x2 = text1Length - x2;
  						if (x1 >= x2) {

  							// Overlap detected.
  							return this.diffBisectSplit(text1, text2, x1, y1, deadline);
  						}
  					}
  				}
  			}
  		}

  		// Diff took too long and hit the deadline or
  		// number of diffs equals number of characters, no commonality at all.
  		return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  	};

  	/**
    * Given the location of the 'middle snake', split the diff in two parts
    * and recurse.
    * @param {string} text1 Old string to be diffed.
    * @param {string} text2 New string to be diffed.
    * @param {number} x Index of split point in text1.
    * @param {number} y Index of split point in text2.
    * @param {number} deadline Time at which to bail if not yet complete.
    * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.
    * @private
    */
  	DiffMatchPatch.prototype.diffBisectSplit = function (text1, text2, x, y, deadline) {
  		var text1a, text1b, text2a, text2b, diffs, diffsb;
  		text1a = text1.substring(0, x);
  		text2a = text2.substring(0, y);
  		text1b = text1.substring(x);
  		text2b = text2.substring(y);

  		// Compute both diffs serially.
  		diffs = this.DiffMain(text1a, text2a, false, deadline);
  		diffsb = this.DiffMain(text1b, text2b, false, deadline);

  		return diffs.concat(diffsb);
  	};

  	/**
    * Reduce the number of edits by eliminating semantically trivial equalities.
    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
    */
  	DiffMatchPatch.prototype.diffCleanupSemantic = function (diffs) {
  		var changes, equalities, equalitiesLength, lastequality, pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1, lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;
  		changes = false;
  		equalities = []; // Stack of indices where equalities are found.
  		equalitiesLength = 0; // Keeping our own length var is faster in JS.
  		/** @type {?string} */
  		lastequality = null;

  		// Always equal to diffs[equalities[equalitiesLength - 1]][1]
  		pointer = 0; // Index of current position.

  		// Number of characters that changed prior to the equality.
  		lengthInsertions1 = 0;
  		lengthDeletions1 = 0;

  		// Number of characters that changed after the equality.
  		lengthInsertions2 = 0;
  		lengthDeletions2 = 0;
  		while (pointer < diffs.length) {
  			if (diffs[pointer][0] === DIFF_EQUAL) {
  				// Equality found.
  				equalities[equalitiesLength++] = pointer;
  				lengthInsertions1 = lengthInsertions2;
  				lengthDeletions1 = lengthDeletions2;
  				lengthInsertions2 = 0;
  				lengthDeletions2 = 0;
  				lastequality = diffs[pointer][1];
  			} else {
  				// An insertion or deletion.
  				if (diffs[pointer][0] === DIFF_INSERT) {
  					lengthInsertions2 += diffs[pointer][1].length;
  				} else {
  					lengthDeletions2 += diffs[pointer][1].length;
  				}

  				// Eliminate an equality that is smaller or equal to the edits on both
  				// sides of it.
  				if (lastequality && lastequality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length <= Math.max(lengthInsertions2, lengthDeletions2)) {

  					// Duplicate record.
  					diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastequality]);

  					// Change second copy to insert.
  					diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;

  					// Throw away the equality we just deleted.
  					equalitiesLength--;

  					// Throw away the previous equality (it needs to be reevaluated).
  					equalitiesLength--;
  					pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;

  					// Reset the counters.
  					lengthInsertions1 = 0;
  					lengthDeletions1 = 0;
  					lengthInsertions2 = 0;
  					lengthDeletions2 = 0;
  					lastequality = null;
  					changes = true;
  				}
  			}
  			pointer++;
  		}

  		// Normalize the diff.
  		if (changes) {
  			this.diffCleanupMerge(diffs);
  		}

  		// Find any overlaps between deletions and insertions.
  		// e.g: <del>abcxxx</del><ins>xxxdef</ins>
  		//   -> <del>abc</del>xxx<ins>def</ins>
  		// e.g: <del>xxxabc</del><ins>defxxx</ins>
  		//   -> <ins>def</ins>xxx<del>abc</del>
  		// Only extract an overlap if it is as big as the edit ahead or behind it.
  		pointer = 1;
  		while (pointer < diffs.length) {
  			if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
  				deletion = diffs[pointer - 1][1];
  				insertion = diffs[pointer][1];
  				overlapLength1 = this.diffCommonOverlap(deletion, insertion);
  				overlapLength2 = this.diffCommonOverlap(insertion, deletion);
  				if (overlapLength1 >= overlapLength2) {
  					if (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) {

  						// Overlap found.  Insert an equality and trim the surrounding edits.
  						diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]);
  						diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1);
  						diffs[pointer + 1][1] = insertion.substring(overlapLength1);
  						pointer++;
  					}
  				} else {
  					if (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) {

  						// Reverse overlap found.
  						// Insert an equality and swap and trim the surrounding edits.
  						diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]);

  						diffs[pointer - 1][0] = DIFF_INSERT;
  						diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2);
  						diffs[pointer + 1][0] = DIFF_DELETE;
  						diffs[pointer + 1][1] = deletion.substring(overlapLength2);
  						pointer++;
  					}
  				}
  				pointer++;
  			}
  			pointer++;
  		}
  	};

  	/**
    * Determine if the suffix of one string is the prefix of another.
    * @param {string} text1 First string.
    * @param {string} text2 Second string.
    * @return {number} The number of characters common to the end of the first
    *     string and the start of the second string.
    * @private
    */
  	DiffMatchPatch.prototype.diffCommonOverlap = function (text1, text2) {
  		var text1Length, text2Length, textLength, best, length, pattern, found;

  		// Cache the text lengths to prevent multiple calls.
  		text1Length = text1.length;
  		text2Length = text2.length;

  		// Eliminate the null case.
  		if (text1Length === 0 || text2Length === 0) {
  			return 0;
  		}

  		// Truncate the longer string.
  		if (text1Length > text2Length) {
  			text1 = text1.substring(text1Length - text2Length);
  		} else if (text1Length < text2Length) {
  			text2 = text2.substring(0, text1Length);
  		}
  		textLength = Math.min(text1Length, text2Length);

  		// Quick check for the worst case.
  		if (text1 === text2) {
  			return textLength;
  		}

  		// Start by looking for a single character match
  		// and increase length until no match is found.
  		// Performance analysis: https://neil.fraser.name/news/2010/11/04/
  		best = 0;
  		length = 1;
  		while (true) {
  			pattern = text1.substring(textLength - length);
  			found = text2.indexOf(pattern);
  			if (found === -1) {
  				return best;
  			}
  			length += found;
  			if (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) {
  				best = length;
  				length++;
  			}
  		}
  	};

  	/**
    * Split two texts into an array of strings.  Reduce the texts to a string of
    * hashes where each Unicode character represents one line.
    * @param {string} text1 First string.
    * @param {string} text2 Second string.
    * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
    *     An object containing the encoded text1, the encoded text2 and
    *     the array of unique strings.
    *     The zeroth element of the array of unique strings is intentionally blank.
    * @private
    */
  	DiffMatchPatch.prototype.diffLinesToChars = function (text1, text2) {
  		var lineArray, lineHash, chars1, chars2;
  		lineArray = []; // E.g. lineArray[4] === 'Hello\n'
  		lineHash = {}; // E.g. lineHash['Hello\n'] === 4

  		// '\x00' is a valid character, but various debuggers don't like it.
  		// So we'll insert a junk entry to avoid generating a null character.
  		lineArray[0] = "";

  		/**
     * Split a text into an array of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * Modifies linearray and linehash through being a closure.
     * @param {string} text String to encode.
     * @return {string} Encoded string.
     * @private
     */
  		function diffLinesToCharsMunge(text) {
  			var chars, lineStart, lineEnd, lineArrayLength, line;
  			chars = "";

  			// Walk the text, pulling out a substring for each line.
  			// text.split('\n') would would temporarily double our memory footprint.
  			// Modifying text would create many large strings to garbage collect.
  			lineStart = 0;
  			lineEnd = -1;

  			// Keeping our own length variable is faster than looking it up.
  			lineArrayLength = lineArray.length;
  			while (lineEnd < text.length - 1) {
  				lineEnd = text.indexOf("\n", lineStart);
  				if (lineEnd === -1) {
  					lineEnd = text.length - 1;
  				}
  				line = text.substring(lineStart, lineEnd + 1);
  				lineStart = lineEnd + 1;

  				var lineHashExists = lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== undefined;

  				if (lineHashExists) {
  					chars += String.fromCharCode(lineHash[line]);
  				} else {
  					chars += String.fromCharCode(lineArrayLength);
  					lineHash[line] = lineArrayLength;
  					lineArray[lineArrayLength++] = line;
  				}
  			}
  			return chars;
  		}

  		chars1 = diffLinesToCharsMunge(text1);
  		chars2 = diffLinesToCharsMunge(text2);
  		return {
  			chars1: chars1,
  			chars2: chars2,
  			lineArray: lineArray
  		};
  	};

  	/**
    * Rehydrate the text in a diff from a string of line hashes to real lines of
    * text.
    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
    * @param {!Array.<string>} lineArray Array of unique strings.
    * @private
    */
  	DiffMatchPatch.prototype.diffCharsToLines = function (diffs, lineArray) {
  		var x, chars, text, y;
  		for (x = 0; x < diffs.length; x++) {
  			chars = diffs[x][1];
  			text = [];
  			for (y = 0; y < chars.length; y++) {
  				text[y] = lineArray[chars.charCodeAt(y)];
  			}
  			diffs[x][1] = text.join("");
  		}
  	};

  	/**
    * Reorder and merge like edit sections.  Merge equalities.
    * Any edit section can move as long as it doesn't cross an equality.
    * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.
    */
  	DiffMatchPatch.prototype.diffCleanupMerge = function (diffs) {
  		var pointer, countDelete, countInsert, textInsert, textDelete, commonlength, changes, diffPointer, position;
  		diffs.push([DIFF_EQUAL, ""]); // Add a dummy entry at the end.
  		pointer = 0;
  		countDelete = 0;
  		countInsert = 0;
  		textDelete = "";
  		textInsert = "";

  		while (pointer < diffs.length) {
  			switch (diffs[pointer][0]) {
  				case DIFF_INSERT:
  					countInsert++;
  					textInsert += diffs[pointer][1];
  					pointer++;
  					break;
  				case DIFF_DELETE:
  					countDelete++;
  					textDelete += diffs[pointer][1];
  					pointer++;
  					break;
  				case DIFF_EQUAL:

  					// Upon reaching an equality, check for prior redundancies.
  					if (countDelete + countInsert > 1) {
  						if (countDelete !== 0 && countInsert !== 0) {

  							// Factor out any common prefixes.
  							commonlength = this.diffCommonPrefix(textInsert, textDelete);
  							if (commonlength !== 0) {
  								if (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL) {
  									diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength);
  								} else {
  									diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]);
  									pointer++;
  								}
  								textInsert = textInsert.substring(commonlength);
  								textDelete = textDelete.substring(commonlength);
  							}

  							// Factor out any common suffixies.
  							commonlength = this.diffCommonSuffix(textInsert, textDelete);
  							if (commonlength !== 0) {
  								diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1];
  								textInsert = textInsert.substring(0, textInsert.length - commonlength);
  								textDelete = textDelete.substring(0, textDelete.length - commonlength);
  							}
  						}

  						// Delete the offending records and add the merged ones.
  						if (countDelete === 0) {
  							diffs.splice(pointer - countInsert, countDelete + countInsert, [DIFF_INSERT, textInsert]);
  						} else if (countInsert === 0) {
  							diffs.splice(pointer - countDelete, countDelete + countInsert, [DIFF_DELETE, textDelete]);
  						} else {
  							diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert, [DIFF_DELETE, textDelete], [DIFF_INSERT, textInsert]);
  						}
  						pointer = pointer - countDelete - countInsert + (countDelete ? 1 : 0) + (countInsert ? 1 : 0) + 1;
  					} else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {

  						// Merge this equality with the previous one.
  						diffs[pointer - 1][1] += diffs[pointer][1];
  						diffs.splice(pointer, 1);
  					} else {
  						pointer++;
  					}
  					countInsert = 0;
  					countDelete = 0;
  					textDelete = "";
  					textInsert = "";
  					break;
  			}
  		}
  		if (diffs[diffs.length - 1][1] === "") {
  			diffs.pop(); // Remove the dummy entry at the end.
  		}

  		// Second pass: look for single edits surrounded on both sides by equalities
  		// which can be shifted sideways to eliminate an equality.
  		// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  		changes = false;
  		pointer = 1;

  		// Intentionally ignore the first and last element (don't need checking).
  		while (pointer < diffs.length - 1) {
  			if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {

  				diffPointer = diffs[pointer][1];
  				position = diffPointer.substring(diffPointer.length - diffs[pointer - 1][1].length);

  				// This is a single edit surrounded by equalities.
  				if (position === diffs[pointer - 1][1]) {

  					// Shift the edit over the previous equality.
  					diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
  					diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
  					diffs.splice(pointer - 1, 1);
  					changes = true;
  				} else if (diffPointer.substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {

  					// Shift the edit over the next equality.
  					diffs[pointer - 1][1] += diffs[pointer + 1][1];
  					diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
  					diffs.splice(pointer + 1, 1);
  					changes = true;
  				}
  			}
  			pointer++;
  		}

  		// If shifts were made, the diff needs reordering and another shift sweep.
  		if (changes) {
  			this.diffCleanupMerge(diffs);
  		}
  	};

  	return function (o, n) {
  		var diff, output, text;
  		diff = new DiffMatchPatch();
  		output = diff.DiffMain(o, n);
  		diff.diffCleanupEfficiency(output);
  		text = diff.diffPrettyHtml(output);

  		return text;
  	};
  }();

}((function() { return this; }())));
});
var qunit_1 = qunit.QUnit;

var Keycodes = {
  BACKSPACE:    8,
  SPACE:       32,
  ENTER:       13,
  SHIFT:       16,
  ESC:         27,
  DELETE:      46,
  '0':         48,
  '9':         57,
  A:           65,
  Z:           90,
  a:           97,
  z:          122,
  'NUMPAD_0': 186,
  'NUMPAD_9': 111,
  ';':        186,
  '.':        190,
  '`':        192,
  '[':        219,
  '"':        222,

  // Input Method Editor uses multiple keystrokes to display characters.
  // Example on mac: press option-i then i. This fires 2 key events in Chrome
  // with keyCode 229 and displays  and then .
  // See http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html#fixed-virtual-key-codes
  IME:        229,

  TAB:          9,
  CLEAR:       12,
  PAUSE:       19,
  PAGEUP:      33,
  PAGEDOWN:    34,
  END:         35,
  HOME:        36,
  LEFT:        37,
  UP:          38,
  RIGHT:       39,
  DOWN:        40,
  INS:         45,
  META:        91,
  ALT:         18,
  CTRL:        17
};

var Keys = {
  BACKSPACE:  'Backspace',
  SPACE:      ' ',
  ENTER:      'Enter',
  SHIFT:      'Shift',
  ESC:        'Escape',
  DELETE:     'Delete',
  INS:        'Insert',
  HOME:       'Home',
  END:        'End',
  PAGEUP:     'PageUp',
  PAGEDOWN:   'PageDown',
  CLEAR:      'Clear',
  PAUSE:      'Pause',
  TAB:        'Tab',
  ALT:        'Alt',
  CTRL:       'Control',

  LEFT:       'ArrowLeft',
  RIGHT:      'ArrowRight',
  UP:         'ArrowUp',
  DOWN:       'ArrowDown'
};

const TAB = '\t';
const ENTER = '\n';

var errorProps = [
  'description',
  'fileName',
  'lineNumber',
  'message',
  'name',
  'number',
  'stack'
];

function MobiledocError() {
  let tmp = Error.apply(this, arguments);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }
  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (let idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }
}

MobiledocError.prototype = Object.create(Error.prototype);

function mobiledocAssert(message, conditional) {
  if (!conditional) {
    throw new MobiledocError(message);
  }
}

/**
 * @typedef Direction
 * @enum {number}
 * @property {number} FORWARD
 * @property {number} BACKWARD
 */
const DIRECTION = {
  FORWARD: 1,
  BACKWARD: -1
};

const MODIFIERS = {
  META: 1, // also called "command" on OS X
  CTRL: 2,
  SHIFT: 4,
  ALT: 8   // also called "option" on OS X
};

function modifierMask(event) {
  let {
    metaKey, shiftKey, ctrlKey, altKey
  } = event;
  let modVal = (val, modifier) => {
    return (val && modifier) || 0;
  };
  return modVal(metaKey,  MODIFIERS.META) +
         modVal(shiftKey, MODIFIERS.SHIFT) +
         modVal(ctrlKey,  MODIFIERS.CTRL) +
         modVal(altKey,   MODIFIERS.ALT);
}

const SPECIAL_KEYS = {
  BACKSPACE: Keycodes.BACKSPACE,
  TAB:       Keycodes.TAB,
  ENTER:     Keycodes.ENTER,
  ESC:       Keycodes.ESC,
  SPACE:     Keycodes.SPACE,
  PAGEUP:    Keycodes.PAGEUP,
  PAGEDOWN:  Keycodes.PAGEDOWN,
  END:       Keycodes.END,
  HOME:      Keycodes.HOME,
  LEFT:      Keycodes.LEFT,
  UP:        Keycodes.UP,
  RIGHT:     Keycodes.RIGHT,
  DOWN:      Keycodes.DOWN,
  INS:       Keycodes.INS,
  DEL:       Keycodes.DELETE
};

function specialCharacterToCode(specialCharacter) {
  return SPECIAL_KEYS[specialCharacter];
}

// heuristic for determining if `event` is a key event
function isKeyEvent(event) {
  return /^key/.test(event.type);
}

/**
 * An abstraction around a KeyEvent
 * that key listeners in the editor can use
 * to determine what sort of key was pressed
 */
const Key = class Key {
  constructor(event) {
    this.key = event.key;
    this.keyCode = event.keyCode;
    this.charCode = event.charCode;
    this.event = event;
    this.modifierMask = modifierMask(event);
  }

  static fromEvent(event) {
    mobiledocAssert('Must pass a Key event to Key.fromEvent',
           event && isKeyEvent(event));
    return new Key(event);
  }

  toString() {
    if (this.isTab()) { return TAB; }
    return String.fromCharCode(this.charCode);
  }

  // See https://caniuse.com/#feat=keyboardevent-key for browser support.
  isKeySupported() {
    return this.key;
  }

  isKey(identifier) {
    if (this.isKeySupported()) {
      mobiledocAssert(`Must define Keys.${identifier}.`, Keys[identifier]);
      return this.key === Keys[identifier];
    } else {
      mobiledocAssert(`Must define Keycodes.${identifier}.`, Keycodes[identifier]);
      return this.keyCode === Keycodes[identifier];
    }
  }

  isEscape() {
    return this.isKey('ESC');
  }

  isDelete() {
    return this.isKey('BACKSPACE') || this.isForwardDelete();
  }

  isForwardDelete() {
    return this.isKey('DELETE');
  }

  isArrow() {
    return this.isHorizontalArrow() || this.isVerticalArrow();
  }

  isHorizontalArrow() {
    return this.isLeftArrow() || this.isRightArrow();
  }

  isHorizontalArrowWithoutModifiersOtherThanShift() {
    return this.isHorizontalArrow() &&
      !(this.ctrlKey || this.metaKey || this.altKey);
  }

  isVerticalArrow() {
    return this.isKey('UP') || this.isKey('DOWN');
  }

  isLeftArrow() {
    return this.isKey('LEFT');
  }

  isRightArrow() {
    return this.isKey('RIGHT');
  }

  isHome() {
    return this.isKey('HOME');
  }

  isEnd() {
    return this.isKey('END');
  }

  isPageUp() {
    return this.isKey('PAGEUP');
  }

  isPageDown() {
    return this.isKey('PAGEDOWN');
  }

  isInsert() {
    return this.isKey('INS');
  }

  isClear() {
    return this.isKey('CLEAR');
  }

  isPause() {
    return this.isKey('PAUSE');
  }

  isSpace() {
    return this.isKey('SPACE');
  }

  // In Firefox, pressing ctrl-TAB will switch to another open browser tab, but
  // it will also fire a keydown event for the tab+modifier (ctrl). This causes
  // Mobiledoc to erroneously insert a tab character before FF switches to the
  // new browser tab.  Chrome doesn't fire this event so the issue doesn't
  // arise there. Fix this by returning false when the TAB key event includes a
  // modifier.
  // See: https://github.com/bustle/mobiledoc-kit/issues/565
  isTab() {
    return !this.hasAnyModifier() && this.isKey('TAB');
  }

  isEnter() {
    return this.isKey('ENTER');
  }

  /*
   * If the key is the actual shift key. This is false when the shift key
   * is held down and the source `event` is not the shift key.
   * @see {isShift}
   * @return {bool}
   */
  isShiftKey() {
    return this.isKey('SHIFT');
  }

  /*
   * If the key is the actual alt key (aka "option" on mac). This is false when the alt key
   * is held down and the source `event` is not the alt key.
   * @return {bool}
   */
  isAltKey() {
    return this.isKey('ALT');
  }

  /*
   * If the key is the actual ctrl key. This is false when the ctrl key
   * is held down and the source `event` is not the ctrl key.
   * @return {bool}
   */
  isCtrlKey() {
    return this.isKey('CTRL');
  }

  isIME() {
    // FIXME the IME action seems to get lost when we issue an
    // `editor.deleteSelection` before it (in Chrome)
    return this.keyCode === Keycodes.IME;
  }

  get direction() {
    switch (true) {
      case this.isDelete():
        return this.isForwardDelete() ? DIRECTION.FORWARD : DIRECTION.BACKWARD;
      case this.isHorizontalArrow():
        return this.isRightArrow() ? DIRECTION.FORWARD : DIRECTION.BACKWARD;
    }
  }

  /**
   * If the shift key is depressed.
   * For example, while holding down meta+shift, pressing the "v"
   * key would result in an event whose `Key` had `isShift()` with a truthy value,
   * because the shift key is down when pressing the "v".
   * @see {isShiftKey} which checks if the key is actually the shift key itself.
   * @return {bool}
   */
  isShift() {
    return this.shiftKey;
  }

  hasModifier(modifier) {
    return modifier & this.modifierMask;
  }

  hasAnyModifier() {
    return !!this.modifierMask;
  }

  get ctrlKey() {
    return MODIFIERS.CTRL & this.modifierMask;
  }

  get metaKey() {
    return MODIFIERS.META & this.modifierMask;
  }

  get shiftKey() {
    return MODIFIERS.SHIFT & this.modifierMask;
  }

  get altKey() {
    return MODIFIERS.ALT & this.modifierMask;
  }

  isPrintableKey() {
    return !(
      this.isArrow() ||
      this.isHome() || this.isEnd() ||
      this.isPageUp() || this.isPageDown() ||
      this.isInsert() || this.isClear() || this.isPause() ||
      this.isEscape()
    );
  }

  isNumberKey() {
    if (this.isKeySupported()) {
      return this.key >= '0' && this.key <= '9';
    } else {
      const code = this.keyCode;
      return (code >= Keycodes['0'] && code <= Keycodes['9']) ||
        (code >= Keycodes.NUMPAD_0 && code <= Keycodes.NUMPAD_9); // numpad keys
    }
  }

  isLetterKey() {
    if (this.isKeySupported()) {
      const key = this.key;
      return (key >= 'a' && key <= 'z') ||
        (key >= 'A' && key <= 'Z');
    } else {
      const code = this.keyCode;
      return (code >= Keycodes.A && code <= Keycodes.Z) ||
        (code >= Keycodes.a && code <= Keycodes.z);
    }
  }

  isPunctuation() {
    if (this.isKeySupported()) {
      const key = this.key;
      return (key >= ';' && key <= '`') ||
        (key >= '[' && key <= '"');
    } else {
      const code = this.keyCode;
      return (code >= Keycodes[';'] && code <= Keycodes['`']) ||
      (code >= Keycodes['['] && code <= Keycodes['"']);
    }
  }

  /**
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Printable_keys_in_standard_position
   *   and http://stackoverflow.com/a/12467610/137784
   */
  isPrintable() {
    if (this.ctrlKey || this.metaKey) {
      return false;
    }

    // Firefox calls keypress events for some keys that should not be printable
    if (!this.isPrintableKey()) {
      return false;
    }

    return (
      this.keyCode !== 0 ||
      this.toString().length > 0 ||
      this.isNumberKey() ||
      this.isSpace() ||
      this.isTab()   ||
      this.isEnter() ||
      this.isLetterKey() ||
      this.isPunctuation() ||
      this.isIME()
    );
  }
};

function detect(enumerable, callback) {
  if (enumerable.detect) {
    return enumerable.detect(callback);
  } else {
    for (let i=0; i<enumerable.length; i++) {
      if (callback(enumerable[i])) {
        return enumerable[i];
      }
    }
  }
}

function any(enumerable, callback) {
  if (enumerable.any) { return enumerable.any(callback); }

  for (let i=0; i<enumerable.length; i++) {
    if (callback(enumerable[i])) {
      return true;
    }
  }

  return false;
}

/**
 * Useful for array-like things that aren't
 * actually arrays, like NodeList
 * @private
 */
function forEach(enumerable, callback) {
  if (enumerable.forEach) {
    enumerable.forEach(callback);
  } else {
    for (let i=0; i<enumerable.length; i++) {
      callback(enumerable[i], i);
    }
  }
}

function filter(enumerable, conditionFn) {
  const filtered = [];
  forEach(enumerable, i => {
    if (conditionFn(i)) { filtered.push(i); }
  });
  return filtered;
}

/**
 * @return {Integer} the number of items that are the same, starting from the 0th index, in a and b
 * @private
 */
function commonItemLength(listA, listB) {
  let offset = 0;
  while (offset < listA.length && offset < listB.length) {
    if (listA[offset] !== listB[offset]) {
      break;
    }
    offset++;
  }
  return offset;
}

/**
 * @return {Array} the items that are the same, starting from the 0th index, in a and b
 * @private
 */
function commonItems(listA, listB) {
  let offset = 0;
  while (offset < listA.length && offset < listB.length) {
    if (listA[offset] !== listB[offset]) {
      break;
    }
    offset++;
  }
  return listA.slice(0, offset);
}

function reduce(enumerable, callback, initialValue) {
  let previousValue = initialValue;
  forEach(enumerable, (val, index) => {
    previousValue = callback(previousValue, val, index);
  });
  return previousValue;
}

/**
 * @param {Array} array of key1,value1,key2,value2,...
 * @return {Object} {key1:value1, key2:value2, ...}
 * @private
 */
function kvArrayToObject(array) {
  const obj = {};
  for (let i = 0; i < array.length; i+=2) {
    let [key, value] = [array[i], array[i+1]];
    obj[key] = value;
  }
  return obj;
}

function objectToSortedKVArray(obj) {
  const keys = Object.keys(obj).sort();
  const result = [];
  keys.forEach(k => {
    result.push(k);
    result.push(obj[k]);
  });
  return result;
}

// check shallow equality of two non-nested arrays
function isArrayEqual(arr1, arr2) {
  let l1 = arr1.length, l2 = arr2.length;
  if (l1 !== l2) { return false; }

  for (let i=0; i < l1; i++) {
    if (arr1[i] !== arr2[i]) { return false; }
  }
  return true;
}

// return an object with only the valid keys
function filterObject(object, validKeys=[]) {
  let result = {};
  forEach(
    filter(Object.keys(object), key => validKeys.indexOf(key) !== -1),
      key => result[key] = object[key]
  );
  return result;
}

function contains(array, item) {
  return array.indexOf(item) !== -1;
}

function values(object) {
  return Object.keys(object).map(key => object[key]);
}

const NODE_TYPES = {
  ELEMENT: 1,
  TEXT: 3,
  COMMENT: 8
};

function isTextNode(node) {
  return node.nodeType === NODE_TYPES.TEXT;
}

function isCommentNode(node) {
  return node.nodeType === NODE_TYPES.COMMENT;
}

function isElementNode(node) {
  return node.nodeType === NODE_TYPES.ELEMENT;
}


function clearChildNodes(element) {
  while (element.childNodes.length) {
    element.removeChild(element.childNodes[0]);
  }
}

/**
 * @return {Boolean} true when the child node is contained or the same as
 * (e.g., inclusive containment)  the parent node
 *  see https://github.com/webmodules/node-contains/blob/master/index.js
 *  Mimics the behavior of `Node.contains`, which is broken in IE 10
 *  @private
 */
function containsNode(parentNode, childNode) {
  if (parentNode === childNode) {
    return true;
  }
  const position = parentNode.compareDocumentPosition(childNode);
  return !!(position & Node.DOCUMENT_POSITION_CONTAINED_BY);
}

/**
 * converts the element's NamedNodeMap of attrs into
 * an object with key-value pairs
 * @param {DOMNode} element
 * @return {Object} key-value pairs
 * @private
 */
function getAttributes(element) {
  const result = {};
  if (element.hasAttributes()) {
    forEach(element.attributes, ({name,value}) => {
      result[name] = value;
    });
  }
  return result;
}

function addClassName(element, className) {
  element.classList.add(className);
}

function removeClassName(element, className) {
  element.classList.remove(className);
}

function normalizeTagName(tagName) {
  return tagName.toLowerCase();
}

function parseHTML(html) {
  const div = document.createElement('div');
  div.innerHTML = html;
  return div;
}

function serializeHTML(node) {
  const div = document.createElement('div');
  div.appendChild(node);
  return div.innerHTML;
}

function clearSelection() {
  window.getSelection().removeAllRanges();
}

function textNodeRects(node) {
  let range = document.createRange();
  range.setEnd(node, node.nodeValue.length);
  range.setStart(node, 0);
  return range.getClientRects();
}

function findOffsetInTextNode(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = range.getBoundingClientRect();
    if (rect.top === rect.bottom) {
      continue;
    }
    if (rect.left <= coords.left && rect.right >= coords.left &&
        rect.top <= coords.top && rect.bottom >= coords.top) {
      return {node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)};
    }
  }
  return {node, offset: 0};
}

/*
 * @param {Object} coords with `top` and `left`
 * @see https://github.com/ProseMirror/prosemirror/blob/4c22e3fe97d87a355a0534e25d65aaf0c0d83e57/src/edit/dompos.js
 * @return {Object} {node, offset}
 */
/* eslint-disable complexity */
function findOffsetInNode(node, coords) {
  let closest, dyClosest = 1e8, coordsClosest, offset = 0;
  for (let child = node.firstChild; child; child = child.nextSibling) {
    let rects;
    if (isElementNode(child)) {
      rects = child.getClientRects();
    } else if (isTextNode(child)) {
      rects = textNodeRects(child);
    } else {
      continue;
    }

    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.left <= coords.left && rect.right >= coords.left) {
        let dy = rect.top > coords.top ? rect.top - coords.top
            : rect.bottom < coords.top ? coords.top - rect.bottom : 0;
        if (dy < dyClosest) {
          closest = child;
          dyClosest = dy;
          coordsClosest = dy ? {left: coords.left, top: rect.top} : coords;
          if (isElementNode(child) && !child.firstChild) {
            offset = i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest &&
          (coords.top >= rect.bottom || coords.top >= rect.top && coords.left >= rect.right)) {
        offset = i + 1;
      }
    }
  }
  if (!closest) {
    return {node, offset};
  }
  if (isTextNode(closest)) {
    return findOffsetInTextNode(closest, coordsClosest);
  }
  if (closest.firstChild) {
    return findOffsetInNode(closest, coordsClosest);
  }
  return {node, offset};
}
/* eslint-enable complexity */

function constrainNodeTo(node, parentNode, existingOffset) {
  let compare = parentNode.compareDocumentPosition(node);
  if (compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    // the node is inside parentNode, do nothing
    return { node, offset: existingOffset};
  } else if (compare & Node.DOCUMENT_POSITION_CONTAINS) {
    // the node contains parentNode. This shouldn't happen.
    return { node, offset: existingOffset};
  } else if (compare & Node.DOCUMENT_POSITION_PRECEDING) {
    // node is before parentNode. return start of deepest first child
    let child = parentNode.firstChild;
    while (child.firstChild) {
      child = child.firstChild;
    }
    return { node: child, offset: 0};
  } else if (compare & Node.DOCUMENT_POSITION_FOLLOWING) {
    // node is after parentNode. return end of deepest last child
    let child = parentNode.lastChild;
    while (child.lastChild) {
      child = child.lastChild;
    }

    let offset = isTextNode(child) ? child.textContent.length : 1;
    return {node: child, offset};
  } else {
    return { node, offset: existingOffset};
  }
}

/*
 * Returns a new selection that is constrained within parentNode.
 * If the anchorNode or focusNode are outside the parentNode, they are replaced with the beginning
 * or end of the parentNode's children
 */
function constrainSelectionTo(selection, parentNode) {
  let {
    node: anchorNode,
    offset: anchorOffset
  } = constrainNodeTo(selection.anchorNode, parentNode, selection.anchorOffset);
  let {
    node: focusNode,
    offset: focusOffset
  } = constrainNodeTo(selection.focusNode, parentNode, selection.focusOffset);

  return { anchorNode, anchorOffset, focusNode, focusOffset };
}

function comparePosition(selection) {
  let { anchorNode, focusNode, anchorOffset, focusOffset } = selection;
  let headNode, tailNode, headOffset, tailOffset, direction;

  const position = anchorNode.compareDocumentPosition(focusNode);

  // IE may select return focus and anchor nodes far up the DOM tree instead of
  // picking the deepest, most specific possible node. For example in
  //
  //     <div><span>abc</span><span>def</span></div>
  //
  // with a cursor between c and d, IE might say the focusNode is <div> with
  // an offset of 1. However the anchorNode for a selection might still be
  // <span> 2 if there was a selection.
  //
  // This code walks down the DOM tree until a good comparison of position can be
  // made.
  //
  if (position & Node.DOCUMENT_POSITION_CONTAINS) {
    if (focusOffset < focusNode.childNodes.length) {
      focusNode = focusNode.childNodes[focusOffset];
      focusOffset = 0;
    } else {
      // This situation happens on IE when triple-clicking to select.
      // Set the focus to the very last character inside the node.
      while (focusNode.lastChild) {
        focusNode = focusNode.lastChild;
      }
      focusOffset = focusNode.textContent.length;
    }

    return comparePosition({
      focusNode,
      focusOffset,
      anchorNode, anchorOffset
    });
  } else if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    let offset = anchorOffset - 1;
    if (offset < 0) {
      offset = 0;
    }
    return comparePosition({
      anchorNode: anchorNode.childNodes[offset],
      anchorOffset: 0,
      focusNode, focusOffset
    });
  // The meat of translating anchor and focus nodes to head and tail nodes
  } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
    headNode = anchorNode; tailNode = focusNode;
    headOffset = anchorOffset; tailOffset = focusOffset;
    direction = DIRECTION.FORWARD;
  } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {
    headNode = focusNode; tailNode = anchorNode;
    headOffset = focusOffset; tailOffset = anchorOffset;
    direction = DIRECTION.BACKWARD;
  } else { // same node
    headNode = tailNode = anchorNode;
    headOffset = anchorOffset;
    tailOffset = focusOffset;
    if (tailOffset < headOffset) {
      // Swap the offset order
      headOffset = focusOffset;
      tailOffset = anchorOffset;
      direction = DIRECTION.BACKWARD;
    } else if (headOffset < tailOffset) {
      direction = DIRECTION.FORWARD;
    } else {
      direction = null;
    }
  }

  return {headNode, headOffset, tailNode, tailOffset, direction};
}

function mergeWithOptions(original, updates, options) {
  options = options || {};
  for(var prop in updates) {
    if (options.hasOwnProperty(prop)) {
      original[prop] = options[prop];
    } else if (updates.hasOwnProperty(prop)) {
      original[prop] = updates[prop];
    }
  }
  return original;
}

/**
 * Merges properties of one object into another
 * @private
 */
function merge(original, updates) {
  return mergeWithOptions(original, updates);
}

class View {
  constructor(options={}) {
    options.tagName   = options.tagName   || 'div';
    options.container = options.container || document.body;

    this.element = document.createElement(options.tagName);
    this.container = options.container;
    this.isShowing = false;

    let classNames = options.classNames || [];
    classNames.forEach(name => addClassName(this.element, name));
    this._eventListeners = [];
  }

  addEventListener(element, type, listener) {
    element.addEventListener(type, listener);
    this._eventListeners.push([element, type, listener]);
  }

  removeAllEventListeners() {
    this._eventListeners.forEach(([element, type, listener]) => {
      element.removeEventListener(type, listener);
    });
  }

  show() {
    if(!this.isShowing) {
      this.container.appendChild(this.element);
      this.isShowing = true;
      return true;
    }
  }

  hide() {
    if (this.isShowing) {
      this.container.removeChild(this.element);
      this.isShowing = false;
      return true;
    }
  }

  destroy() {
    this.removeAllEventListeners();
    this.hide();
    this.isDestroyed = true;
  }
}

/*
 * @param {String} string
 * @return {String} a dasherized string. 'modelIndex' -> 'model-index', etc
 */
function dasherize(string) {
  return string.replace(/[A-Z]/g, (match, offset) => {
    const lower = match.toLowerCase();

    return (offset === 0 ? lower : '-' + lower);
  });
}

function startsWith(string, character) {
  return string.charAt(0) === character;
}

function endsWith(string, endString) {
  let index = string.lastIndexOf(endString);
  return index !== -1 && index === string.length - endString.length;
}

function getEventTargetMatchingTag(tagName, target, container) {
  tagName = normalizeTagName(tagName);
  // Traverses up DOM from an event target to find the node matching specifed tag
  while (target && target !== container) {
    if (normalizeTagName(target.tagName) === tagName) {
      return target;
    }
    target = target.parentNode;
  }
}

function getElementRelativeOffset(element) {
  var offset = { left: 0, top: -window.pageYOffset };
  var offsetParent = element.offsetParent;
  var offsetParentPosition = window.getComputedStyle(offsetParent).position;
  var offsetParentRect;

  if (offsetParentPosition === 'relative') {
    offsetParentRect = offsetParent.getBoundingClientRect();
    offset.left = offsetParentRect.left;
    offset.top  = offsetParentRect.top;
  }
  return offset;
}

function getElementComputedStyleNumericProp(element, prop) {
  return parseFloat(window.getComputedStyle(element)[prop]);
}

function positionElementToRect(element, rect, topOffset, leftOffset) {
  var relativeOffset = getElementRelativeOffset(element);
  var style = element.style;
  var round = Math.round;
  var left, top;

  topOffset = topOffset || 0;
  leftOffset = leftOffset || 0;
  left = round(rect.left - relativeOffset.left - leftOffset);
  top  = round(rect.top  - relativeOffset.top  - topOffset);
  style.left = left + 'px';
  style.top  = top + 'px';
  return { left: left, top: top };
}

function positionElementHorizontallyCenteredToRect(element, rect, topOffset) {
  var horizontalCenter = (element.offsetWidth / 2) - (rect.width / 2);
  return positionElementToRect(element, rect, topOffset, horizontalCenter);
}

function positionElementCenteredBelow(element, belowElement) {
  var elementMargin = getElementComputedStyleNumericProp(element, 'marginTop');
  return positionElementHorizontallyCenteredToRect(element, belowElement.getBoundingClientRect(), -element.offsetHeight - elementMargin);
}

function setData(element, name, value) {
  if (element.dataset) {
    element.dataset[name] = value;
  } else {
    const dataName = dasherize(name);
    return element.setAttribute(dataName, value);
  }
}

function whenElementIsNotInDOM(element, callback) {
  let isCanceled = false;
  const observerFn = () => {
    if (isCanceled) { return; }
    if (!element.parentNode) {
      callback();
    } else {
      window.requestAnimationFrame(observerFn);
    }
  };
  observerFn();
  return { cancel: () => isCanceled = true };
}

const DELAY = 200;

class Tooltip extends View {
  constructor(options) {
    let { rootElement } = options;
    let timeout;
    options.classNames = ['__mobiledoc-tooltip'];
    super(options);

    this.addEventListener(rootElement, 'mouseover', (e) => {
      let target = getEventTargetMatchingTag(options.showForTag, e.target, rootElement);
      if (target && target.isContentEditable) {
        timeout = setTimeout(() => {
          this.showLink(target.href, target);
        }, DELAY);
      }
    });
    
    this.addEventListener(rootElement, 'mouseout', (e) => {
      clearTimeout(timeout);
      if (this.elementObserver) { this.elementObserver.cancel(); }
      let toElement = e.toElement || e.relatedTarget;
      if (toElement && toElement.className !== this.element.className) {
        this.hide();
      }
    });
  }

  showMessage(message, element) {
    let tooltipElement = this.element;
    tooltipElement.innerHTML = message;
    this.show();
    positionElementCenteredBelow(tooltipElement, element);
  }

  showLink(link, element) {
    let message = `<a href="${link}" target="_blank">${link}</a>`;
    this.showMessage(message, element);
    this.elementObserver = whenElementIsNotInDOM(element, () => this.hide());
  }
}

const MARKUP_SECTION_TYPE = 'markup-section';
const LIST_SECTION_TYPE = 'list-section';
const MARKUP_TYPE = 'markup';
const MARKER_TYPE = 'marker';
const POST_TYPE = 'post';
const LIST_ITEM_TYPE = 'list-item';
const CARD_TYPE = 'card-section';
const IMAGE_SECTION_TYPE = 'image-section';
const ATOM_TYPE = 'atom';

const CONSTRUCTOR_FN_NAME = 'constructor';

function mixin(target, source) {
  target = target.prototype;
  // Fallback to just `source` to allow mixing in a plain object (pojo)
  source = source.prototype || source;

  Object.getOwnPropertyNames(source).forEach((name) => {
    if (name !== CONSTRUCTOR_FN_NAME) {
      const descriptor = Object.getOwnPropertyDescriptor(source, name);

      Object.defineProperty(target, name, descriptor);
    }
  });
}

class Markerupable {

  clearMarkups() {
    this.markups = [];
  }

  addMarkup(markup) {
    this.markups.push(markup);
  }

  addMarkupAtIndex(markup, index) {
    this.markups.splice(index, 0, markup);
  }

  removeMarkup(markupOrMarkupCallback) {
    let callback;
    if (typeof markupOrMarkupCallback === 'function') {
      callback = markupOrMarkupCallback;
    } else {
      let markup = markupOrMarkupCallback;
      callback = (_markup) => _markup === markup;
    }

    forEach(
      filter(this.markups, callback),
      m => this._removeMarkup(m)
    );
  }

  _removeMarkup(markup) {
    const index = this.markups.indexOf(markup);
    if (index !== -1) {
      this.markups.splice(index, 1);
    }
  }

  hasMarkup(tagNameOrMarkup) {
    return !!this.getMarkup(tagNameOrMarkup);
  }

  getMarkup(tagNameOrMarkup) {
    if (typeof tagNameOrMarkup === 'string') {
      let tagName = normalizeTagName(tagNameOrMarkup);
      return detect(this.markups, markup => markup.tagName === tagName);
    } else {
      let targetMarkup = tagNameOrMarkup;
      return detect(this.markups, markup => markup === targetMarkup);
    }
  }

  get openedMarkups() {
    let count = 0;
    if (this.prev) {
      count = commonItemLength(this.markups, this.prev.markups);
    }

    return this.markups.slice(count);
  }

  get closedMarkups() {
    let count = 0;
    if (this.next) {
      count = commonItemLength(this.markups, this.next.markups);
    }

    return this.markups.slice(count);
  }
}

class LinkedItem {
  constructor() {
    this.next = null;
    this.prev = null;
  }
}

// Unicode uses a pair of "surrogate" characters" (a high- and low-surrogate)
// to encode characters outside the basic multilingual plane (like emoji and
// some languages).
// These values are the unicode code points for the start and end of the
// high- and low-surrogate characters.
// See "high surrogate" and "low surrogate" on
// https://en.wikipedia.org/wiki/Unicode_block
const HIGH_SURROGATE_RANGE = [0xD800, 0xDBFF];
const LOW_SURROGATE_RANGE  = [0xDC00, 0xDFFF];

const Marker = class Marker extends LinkedItem {
  constructor(value='', markups=[]) {
    super();
    this.value = value;
    mobiledocAssert('Marker must have value', value !== undefined && value !== null);
    this.markups = [];
    this.type = MARKER_TYPE;
    this.isMarker = true;
    this.isAtom = false;
    markups.forEach(m => this.addMarkup(m));
  }

  clone() {
    const clonedMarkups = this.markups.slice();
    return this.builder.createMarker(this.value, clonedMarkups);
  }

  get isEmpty() {
    return this.isBlank;
  }

  get isBlank() {
    return this.length === 0;
  }

  charAt(offset) {
    return this.value.slice(offset, offset+1);
  }

  /**
   * A marker's text is equal to its value.
   * Compare with an Atom which distinguishes between text and value
   */
  get text() {
    return this.value;
  }

  get length() {
    return this.value.length;
  }

  // delete the character at this offset,
  // update the value with the new value
  deleteValueAtOffset(offset) {
    mobiledocAssert('Cannot delete value at offset outside bounds',
           offset >= 0 && offset <= this.length);

    let width = 1;
    let code = this.value.charCodeAt(offset);
    if (code >= HIGH_SURROGATE_RANGE[0] && code <= HIGH_SURROGATE_RANGE[1]) {
      width = 2;
    } else if (code >= LOW_SURROGATE_RANGE[0] && code <= LOW_SURROGATE_RANGE[1]) {
      width = 2;
      offset = offset - 1;
    }

    const [ left, right ] = [
      this.value.slice(0, offset),
      this.value.slice(offset+width)
    ];
    this.value = left + right;

    return width;
  }

  canJoin(other) {
    return other && other.isMarker && isArrayEqual(this.markups, other.markups);
  }

  textUntil(offset) {
    return this.value.slice(0, offset);
  }

  split(offset=0, endOffset=this.length) {
    let markers = [
      this.builder.createMarker(this.value.substring(0, offset)),
      this.builder.createMarker(this.value.substring(offset, endOffset)),
      this.builder.createMarker(this.value.substring(endOffset))
    ];

    this.markups.forEach(mu => markers.forEach(m => m.addMarkup(mu)));
    return markers;
  }

  /**
   * @return {Array} 2 markers either or both of which could be blank
   */
  splitAtOffset(offset) {
    mobiledocAssert('Cannot split a marker at an offset > its length',
           offset <= this.length);
    let { value, builder } = this;

    let pre  = builder.createMarker(value.substring(0, offset));
    let post = builder.createMarker(value.substring(offset));

    this.markups.forEach(markup => {
      pre.addMarkup(markup);
      post.addMarkup(markup);
    });

    return [pre, post];
  }

};

mixin(Marker, Markerupable);

/**
 * A logical range of a {@link Post}.
 * Usually an instance of Range will be read from the {@link Editor#range} property,
 * but it may be useful to instantiate a range directly when programmatically modifying a Post.
 */
class Range {
  /**
   * @param {Position} head
   * @param {Position} [tail=head]
   * @param {Direction} [direction=null]
   * @return {Range}
   * @private
   */
  constructor(head, tail=head, direction=null) {
    /** @property {Position} head */
    this.head = head;

    /** @property {Position} tail */
    this.tail = tail;

    /** @property {Direction} direction */
    this.direction = direction;
  }

  /**
   * Shorthand to create a new range from a section(s) and offset(s).
   * When given only a head section and offset, creates a collapsed range.
   * @param {Section} headSection
   * @param {number} headOffset
   * @param {Section} [tailSection=headSection]
   * @param {number} [tailOffset=headOffset]
   * @param {Direction} [direction=null]
   * @return {Range}
   */
  static create(headSection, headOffset, tailSection=headSection, tailOffset=headOffset, direction=null) {
    return new Range(
      new Position$1(headSection, headOffset),
      new Position$1(tailSection, tailOffset),
      direction
    );
  }

  static blankRange() {
    return new Range(Position$1.blankPosition(), Position$1.blankPosition());
  }

  /**
   * @param {Markerable} section
   * @return {Range} A range that is constrained to only the part that
   * includes the section.
   * FIXME -- if the section isn't the head or tail, it's assumed to be
   * wholly contained. It's possible to call `trimTo` with a selection that is
   * outside of the range, though, which would invalidate that assumption.
   * There's no efficient way to determine if a section is within a range, yet.
   * @private
   */
  trimTo(section) {
    const length = section.length;

    let headOffset = section === this.head.section ?
      Math.min(this.head.offset, length) : 0;
    let tailOffset = section === this.tail.section ?
      Math.min(this.tail.offset, length) : length;

    return Range.create(section, headOffset, section, tailOffset);
  }

  /**
   * Expands the range 1 unit in the given direction
   * If the range is expandable in the given direction, always returns a
   * non-collapsed range.
   * @param {Number} units If units is > 0, the range is extended to the right,
   *                 otherwise range is extended to the left.
   * @return {Range}
   * @public
   */
  extend(units) {
    mobiledocAssert(`Must pass integer to Range#extend`, typeof units === 'number');

    if (units === 0) { return this; }

    let { head, tail, direction: currentDirection } = this;
    switch (currentDirection) {
      case DIRECTION.FORWARD:
        return new Range(head, tail.move(units), currentDirection);
      case DIRECTION.BACKWARD:
        return new Range(head.move(units), tail, currentDirection);
      default: {
        let newDirection = units > 0 ? DIRECTION.FORWARD : DIRECTION.BACKWARD;
        return new Range(head, tail, newDirection).extend(units);
      }
    }
  }

  /**
   * Moves this range 1 unit in the given direction.
   * If the range is collapsed, returns a collapsed range shifted by 1 unit,
   * otherwise collapses this range to the position at the `direction` end of the range.
   * Always returns a collapsed range.
   * @param {Direction} direction
   * @return {Range}
   * @public
   */
  move(direction) {
    mobiledocAssert(`Must pass DIRECTION.FORWARD (${DIRECTION.FORWARD}) or DIRECTION.BACKWARD (${DIRECTION.BACKWARD}) to Range#move`,
           direction === DIRECTION.FORWARD || direction === DIRECTION.BACKWARD);

    let { focusedPosition, isCollapsed } = this;

    if (isCollapsed) {
      return new Range(focusedPosition.move(direction));
    } else {
      return this._collapse(direction);
    }
  }

  /**
   * expand a range to all markers matching a given check
   *
   * @param {Function} detectMarker
   * @return {Range} The expanded range
   *
   * @public
   */
  expandByMarker(detectMarker) {
    let {
      head,
      tail,
      direction
    } = this;
    let {section: headSection} = head;
    if (headSection !== tail.section) {
      throw new Error('#expandByMarker does not work across sections. Perhaps you should confirm the range is collapsed');
    }

    let firstNotMatchingDetect = i => {
      return !detectMarker(i);
    };

    let headMarker = headSection.markers.detect(firstNotMatchingDetect, head.marker, true);
    if (!headMarker && detectMarker(headSection.markers.head)) {
      headMarker = headSection.markers.head;
    } else {
      headMarker = headMarker.next || head.marker;
    }
    let headPosition = new Position$1(headSection, headSection.offsetOfMarker(headMarker));

    let tailMarker = tail.section.markers.detect(firstNotMatchingDetect, tail.marker);
    if (!tailMarker && detectMarker(headSection.markers.tail)) {
      tailMarker = headSection.markers.tail;
    } else {
      tailMarker = tailMarker.prev || tail.marker;
    }
    let tailPosition = new Position$1(tail.section, tail.section.offsetOfMarker(tailMarker) + tailMarker.length);

    return headPosition.toRange(tailPosition, direction);
  }

  _collapse(direction) {
    return new Range(direction === DIRECTION.BACKWARD ? this.head : this.tail);
  }

  get focusedPosition() {
    return this.direction === DIRECTION.BACKWARD ? this.head : this.tail;
  }

  isEqual(other) {
    return other &&
      this.head.isEqual(other.head) &&
      this.tail.isEqual(other.tail);
  }

  get isBlank() {
    return this.head.isBlank && this.tail.isBlank;
  }

  // "legacy" APIs
  get headSection() {
    return this.head.section;
  }
  get tailSection() {
    return this.tail.section;
  }
  get headSectionOffset() {
    return this.head.offset;
  }
  get tailSectionOffset() {
    return this.tail.offset;
  }
  get isCollapsed() {
    return this.head.isEqual(this.tail);
  }
  get headMarker() {
    return this.head.marker;
  }
  get tailMarker() {
    return this.tail.marker;
  }
  get headMarkerOffset() {
    return this.head.offsetInMarker;
  }
  get tailMarkerOffset() {
    return this.tail.offsetInMarker;
  }
}

const { FORWARD, BACKWARD } = DIRECTION;

// generated via http://xregexp.com/ to cover chars that \w misses
// (new XRegExp('\\p{Alphabetic}|[0-9]|_|:')).toString()
const WORD_CHAR_REGEX = /[A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]|[0-9]|_|:/;

function findParentSectionFromNode(renderTree, node) {
  let renderNode =  renderTree.findRenderNodeFromElement(
    node,
    (renderNode) => renderNode.postNode.isSection
  );

  return renderNode && renderNode.postNode;
}

function findOffsetInMarkerable(markerable, node, offset) {
  let offsetInSection = 0;
  let marker = markerable.markers.head;
  while (marker) {
    let markerNode = marker.renderNode.element;
    if (markerNode === node) {
      return offsetInSection + offset;
    } else if (marker.isAtom) {
      if (marker.renderNode.headTextNode === node) {
        return offsetInSection;
      } else if (marker.renderNode.tailTextNode === node) {
        return offsetInSection + 1;
      }
    }

    offsetInSection += marker.length;
    marker = marker.next;
  }

  return offsetInSection;
}

function findOffsetInSection(section, node, offset) {
  if (section.isMarkerable) {
    return findOffsetInMarkerable(section, node, offset);
  } else {
    mobiledocAssert('findOffsetInSection must be called with markerable or card section',
           section.isCardSection);

    let wrapperNode = section.renderNode.element;
    let endTextNode = wrapperNode.lastChild;
    if (node === endTextNode) {
      return 1;
    }
    return 0;
  }
}

let Position, BlankPosition;

Position = class Position {
  /**
   * A position is a logical location (zero-width, or "collapsed") in a post,
   * typically between two characters in a section.
   * Two positions (a head and a tail) make up a {@link Range}.
   * @constructor
   */
  constructor(section, offset=0, isBlank=false) {
    if (!isBlank) {
      mobiledocAssert('Position must have a section that is addressable by the cursor',
             (section && section.isLeafSection));
      mobiledocAssert('Position must have numeric offset',
             (typeof offset === 'number'));
    }

    this.section = section;
    this.offset = offset;
    this.isBlank = isBlank;
  }

  /**
   * @param {integer} x x-position in current viewport
   * @param {integer} y y-position in current viewport
   * @param {Editor} editor
   * @return {Position|null}
   */
  static atPoint(x, y, editor) {
    let { _renderTree, element: rootElement } = editor;
    let elementFromPoint = document.elementFromPoint(x, y);
    if (!containsNode(rootElement, elementFromPoint)) {
      return;
    }

    let { node, offset } = findOffsetInNode(elementFromPoint, {left: x, top: y});
    return Position.fromNode(_renderTree, node, offset);
  }

  static blankPosition() {
    return new BlankPosition();
  }

  /**
   * Returns a range from this position to the given tail. If no explicit
   * tail is given this returns a collapsed range focused on this position.
   * @param {Position} [tail=this] The ending position
   * @return {Range}
   * @public
   */
  toRange(tail=this, direction=null) {
    return new Range(this, tail, direction);
  }

  get leafSectionIndex() {
    let post = this.section.post;
    let leafSectionIndex;
    post.walkAllLeafSections((section, index) => {
      if (section === this.section) {
        leafSectionIndex = index;
      }
    });
    return leafSectionIndex;
  }

  get isMarkerable() {
    return this.section && this.section.isMarkerable;
  }

  /**
   * Returns the marker at this position, in the backward direction
   * (i.e., the marker to the left of the cursor if the cursor is on a marker boundary and text is left-to-right)
   * @return {Marker|undefined}
   */
  get marker() {
    return this.isMarkerable && this.markerPosition.marker;
  }

  /**
   * Returns the marker in `direction` from this position.
   * If the position is in the middle of a marker, the direction is irrelevant.
   * Otherwise, if the position is at a boundary between two markers, returns the
   * marker to the left if `direction` === BACKWARD and the marker to the right
   * if `direction` === FORWARD (assuming left-to-right text direction).
   * @param {Direction}
   * @return {Marker|undefined}
   */
  markerIn(direction) {
    if (!this.isMarkerable) { return; }

    let { marker, offsetInMarker } = this;
    if (!marker) { return; }

    if (offsetInMarker > 0 && offsetInMarker < marker.length) {
      return marker;
    } else if (offsetInMarker === 0) {
      return direction === BACKWARD ? marker : marker.prev;
    } else if (offsetInMarker === marker.length) {
      return direction === FORWARD ? marker.next : marker;
    }
  }

  get offsetInMarker() {
    return this.markerPosition.offset;
  }

  isEqual(position) {
    return this.section === position.section &&
           this.offset  === position.offset;
  }

  /**
   * @return {Boolean} If this position is at the head of the post
   */
  isHeadOfPost() {
    return this.move(BACKWARD).isEqual(this);
  }

  /**
   * @return {Boolean} If this position is at the tail of the post
   */
  isTailOfPost() {
    return this.move(FORWARD).isEqual(this);
  }

  /**
   * @return {Boolean} If this position is at the head of its section
   */
  isHead() {
    return this.isEqual(this.section.headPosition());
  }

  /**
   * @return {Boolean} If this position is at the tail of its section
   */
  isTail() {
    return this.isEqual(this.section.tailPosition());
  }

  /**
   * Move the position 1 unit in `direction`.
   *
   * @param {Number} units to move. > 0 moves right, < 0 moves left
   * @return {Position} Return a new position one unit in the given
   * direction. If the position is moving left and at the beginning of the post,
   * the same position will be returned. Same if the position is moving right and
   * at the end of the post.
   */
  move(units) {
    mobiledocAssert('Must pass integer to Position#move', typeof units === 'number');

    if (units < 0) {
      return this.moveLeft().move(++units);
    } else if (units > 0) {
      return this.moveRight().move(--units);
    } else {
      return this;
    }
  }

  /**
   * @param {Number} direction (FORWARD or BACKWARD)
   * @return {Position} The result of moving 1 "word" unit in `direction`
   */
  moveWord(direction) {
    let isPostBoundary = direction === BACKWARD ? this.isHeadOfPost() : this.isTailOfPost();
    if (isPostBoundary) {
      return this;
    }

    if (!this.isMarkerable) {
      return this.move(direction);
    }

    let pos = this;

    // Helper fn to check if the pos is at the `dir` boundary of its section
    let isBoundary = (pos, dir) => {
      return dir === BACKWARD ? pos.isHead() : pos.isTail();
    };
    // Get the char at this position (looking forward/right)
    let getChar = (pos) => {
      let { marker, offsetInMarker } = pos;
      return marker.charAt(offsetInMarker);
    };
    // Get the char in `dir` at this position
    let peekChar = (pos, dir) => {
      return dir === BACKWARD ? getChar(pos.move(BACKWARD)) : getChar(pos);
    };
    // Whether there is an atom in `dir` from this position
    let isAtom = (pos, dir) => {
      // Special case when position is at end, the marker associated with it is
      // the marker to its left. Normally `pos#marker` is the marker to the right of the pos's offset.
      if (dir === BACKWARD && pos.isTail() && pos.marker.isAtom) {
        return true;
      }
      return dir === BACKWARD ? pos.move(BACKWARD).marker.isAtom : pos.marker.isAtom;
    };

    if (isBoundary(pos, direction)) {
      // extend movement into prev/next section
      return pos.move(direction).moveWord(direction);
    }

    let seekWord = (pos) => {
      return !isBoundary(pos, direction) &&
        !isAtom(pos, direction) &&
        !WORD_CHAR_REGEX.test(peekChar(pos, direction));
    };

    // move(dir) while we are seeking the first word char
    while (seekWord(pos)) {
      pos = pos.move(direction);
    }

    if (isAtom(pos, direction)) {
      return pos.move(direction);
    }

    let seekBoundary = (pos) => {
      return !isBoundary(pos, direction) &&
        !isAtom(pos, direction) &&
        WORD_CHAR_REGEX.test(peekChar(pos, direction));
    };

    // move(dir) while we are seeking the first boundary position
    while (seekBoundary(pos)) {
      pos = pos.move(direction);
    }

    return pos;
  }

  /**
   * The position to the left of this position.
   * If this position is the post's headPosition it returns itself.
   * @return {Position}
   * @private
   */
  moveLeft() {
    if (this.isHead()) {
      let prev = this.section.previousLeafSection();
      return prev ? prev.tailPosition() : this;
    } else {
      let offset = this.offset - 1;
      if (this.isMarkerable && this.marker) {
        let code = this.marker.value.charCodeAt(offset);
        if (code >= LOW_SURROGATE_RANGE[0] && code <= LOW_SURROGATE_RANGE[1]) {
          offset = offset - 1;
        }
      }
      return new Position(this.section, offset);
    }
  }

  /**
   * The position to the right of this position.
   * If this position is the post's tailPosition it returns itself.
   * @return {Position}
   * @private
   */
  moveRight() {
    if (this.isTail()) {
      let next = this.section.nextLeafSection();
      return next ? next.headPosition() : this;
    } else {
      let offset = this.offset + 1;
      if (this.isMarkerable && this.marker) {
        let code = this.marker.value.charCodeAt(offset - 1);
        if (code >= HIGH_SURROGATE_RANGE[0] && code <= HIGH_SURROGATE_RANGE[1]) {
          offset = offset + 1;
        }
      }
      return new Position(this.section, offset);
    }
  }

  static fromNode(renderTree, node, offset) {
    if (isTextNode(node)) {
      return Position.fromTextNode(renderTree, node, offset);
    } else {
      return Position.fromElementNode(renderTree, node, offset);
    }
  }

  static fromTextNode(renderTree, textNode, offsetInNode) {
    const renderNode = renderTree.getElementRenderNode(textNode);
    let section, offsetInSection;

    if (renderNode) {
      const marker = renderNode.postNode;
      section = marker.section;

      mobiledocAssert(`Could not find parent section for mapped text node "${textNode.textContent}"`,
             !!section);
      offsetInSection = section.offsetOfMarker(marker, offsetInNode);
    } else {
      // all text nodes should be rendered by markers except:
      //   * text nodes inside cards
      //   * text nodes created by the browser during text input
      // both of these should have rendered parent sections, though
      section = findParentSectionFromNode(renderTree, textNode);
      mobiledocAssert(`Could not find parent section for un-mapped text node "${textNode.textContent}"`,
             !!section);

      offsetInSection = findOffsetInSection(section, textNode, offsetInNode);
    }

    return new Position(section, offsetInSection);
  }

  static fromElementNode(renderTree, elementNode, offset) {
    let position;

    // The browser may change the reported selection to equal the editor's root
    // element if the user clicks an element that is immediately removed,
    // which can happen when clicking to remove a card.
    if (elementNode === renderTree.rootElement) {
      let post = renderTree.rootNode.postNode;
      position = offset === 0 ? post.headPosition() : post.tailPosition();
    } else {
      let section = findParentSectionFromNode(renderTree, elementNode);
      mobiledocAssert('Could not find parent section from element node', !!section);

      if (section.isCardSection) {
        // Selections in cards are usually made on a text node
        // containing a &zwnj;  on one side or the other of the card but
        // some scenarios (Firefox) will result in selecting the
        // card's wrapper div. If the offset is 2 we've selected
        // the final zwnj and should consider the cursor at the
        // end of the card (offset 1). Otherwise,  the cursor is at
        // the start of the card
        position = offset < 2 ? section.headPosition() : section.tailPosition();
      } else {

        // In Firefox it is possible for the cursor to be on an atom's wrapper
        // element. (In Chrome/Safari, the browser corrects this to be on
        // one of the text nodes surrounding the wrapper).
        // This code corrects for when the browser reports the cursor position
        // to be on the wrapper element itself
        let renderNode = renderTree.getElementRenderNode(elementNode);
        let postNode = renderNode && renderNode.postNode;
        if (postNode && postNode.isAtom) {
          let sectionOffset = section.offsetOfMarker(postNode);
          if (offset > 1) {
            // we are on the tail side of the atom
            sectionOffset += postNode.length;
          }
          position = new Position(section, sectionOffset);
        } else if (offset >= elementNode.childNodes.length) {

          // This is to deal with how Firefox handles triple-click selections.
          // See https://stackoverflow.com/a/21234837/1269194 for an
          // explanation.
          position = section.tailPosition();
        } else {
          // The offset is 0 if the cursor is on a non-atom-wrapper element node
          // (e.g., a <br> tag in a blank markup section)
          position = section.headPosition();
        }
      }
    }

    return position;
  }

  /**
   * @private
   */
  get markerPosition() {
    mobiledocAssert('Cannot get markerPosition without a section', !!this.section);
    mobiledocAssert('cannot get markerPosition of a non-markerable', !!this.section.isMarkerable);
    return this.section.markerPositionAtOffset(this.offset);
  }
};

BlankPosition = class BlankPosition extends Position {
  constructor() {
    super(null, 0, true);
  }

  isEqual(other) {
    return other && other.isBlank;
  }

  toRange() { return Range.blankRange(); }
  get leafSectionIndex() { mobiledocAssert('must implement get leafSectionIndex', false); }

  get isMarkerable() { return false; }
  get marker() { return false; }
  isHeadOfPost() { return false; }
  isTailOfPost() { return false; }
  isHead() { return false; }
  isTail() { return false; }
  move() { return this; }
  moveWord() { return this; }

  get markerPosition() { return {}; }
};

var Position$1 = Position;

class LifecycleCallbacks {
  constructor(queueNames=[]) {
    this.callbackQueues = {};
    this.removalQueues = {};

    queueNames.forEach(name => {
      this.callbackQueues[name] = [];
      this.removalQueues[name] = [];
    });
  }

  runCallbacks(queueName, args=[]) {
    let queue = this._getQueue(queueName);
    queue.forEach(cb => cb(...args));

    let toRemove = this.removalQueues[queueName];
    toRemove.forEach(cb => {
      let index = queue.indexOf(cb);
      if (index !== -1) {
        queue.splice(index, 1);
      }
    });

    this.removalQueues[queueName] = [];
  }

  addCallback(queueName, callback) {
    this._getQueue(queueName).push(callback);
  }

  _scheduleCallbackForRemoval(queueName, callback) {
    this.removalQueues[queueName].push(callback);
  }

  addCallbackOnce(queueName, callback) {
    let queue = this._getQueue(queueName);
    if (queue.indexOf(callback) === -1) {
      queue.push(callback);
      this._scheduleCallbackForRemoval(queueName, callback);
    }
  }

  _getQueue(queueName) {
    let queue = this.callbackQueues[queueName];
    mobiledocAssert(`No queue found for "${queueName}"`, !!queue);
    return queue;
  }
}

const MARKERABLE = 'markerable',
      NESTED_MARKERABLE = 'nested_markerable',
      NON_MARKERABLE = 'non_markerable';

class Visitor {
  constructor(inserter, cursorPosition) {
    let { postEditor, post } = inserter;
    this.postEditor = postEditor;
    this._post = post;
    this.cursorPosition = cursorPosition;
    this.builder = this.postEditor.builder;

    this._hasInsertedFirstLeafSection = false;
  }

  get cursorPosition() {
    return this._cursorPosition;
  }

  set cursorPosition(position) {
    this._cursorPosition = position;
    this.postEditor.setRange(position);
  }

  visit(node) {
    let method = node.type;
    mobiledocAssert(`Cannot visit node of type ${node.type}`, !!this[method]);
    this[method](node);
  }

  _canMergeSection(section) {
    if (this._hasInsertedFirstLeafSection) {
      return false;
    } else {
      return this._isMarkerable && section.isMarkerable;
    }
  }

  get _isMarkerable() {
    return this.cursorSection.isMarkerable;
  }

  get cursorSection() {
    return this.cursorPosition.section;
  }

  get cursorOffset() {
    return this.cursorPosition.offset;
  }

  get _isNested() {
    return this.cursorSection.isNested;
  }

  [POST_TYPE](node) {
    if (this.cursorSection.isBlank && !this._isNested) {
      // replace blank section with entire post
      let newSections = node.sections.map(s => s.clone());
      this._replaceSection(this.cursorSection, newSections);
    } else {
      node.sections.forEach(section => this.visit(section));
    }
  }

  [MARKUP_SECTION_TYPE](node) {
    this[MARKERABLE](node);
  }

  [LIST_SECTION_TYPE](node) {
    let hasNext = !!node.next;
    node.items.forEach(item => this.visit(item));

    if (this._isNested && hasNext) {
      this._breakNestedAtCursor();
    }
  }

  [LIST_ITEM_TYPE](node) {
    this[NESTED_MARKERABLE](node);
  }

  [CARD_TYPE](node) {
    this[NON_MARKERABLE](node);
  }

  [IMAGE_SECTION_TYPE](node) {
    this[NON_MARKERABLE](node);
  }

  [NON_MARKERABLE](section) {
    if (this._isNested) {
      this._breakNestedAtCursor();
    } else if (!this.cursorSection.isBlank) {
      this._breakAtCursor();
    }

    this._insertLeafSection(section);
  }

  [MARKERABLE](section) {
    if (this._canMergeSection(section)) {
      this._mergeSection(section);
    } else if (this._isNested && this._isMarkerable) {
      // If we are attaching a markerable section to a list item,
      // insert a linebreak then merge the section onto the resulting blank list item
      this._breakAtCursor();

      // Advance the cursor to the head of the blank list item
      let nextPosition = this.cursorSection.next.headPosition();
      this.cursorPosition = nextPosition;

      // Merge this section onto the list item
      this._mergeSection(section);
    } else {
      this._breakAtCursor();
      this._insertLeafSection(section);
    }
  }

  [NESTED_MARKERABLE](section) {
    if (this._canMergeSection(section)) {
      this._mergeSection(section);
      return;
    }

    section = this._isNested ? section : this._wrapNestedSection(section);
    this._breakAtCursor();
    this._insertLeafSection(section);
  }

  // break out of a nested cursor position
  _breakNestedAtCursor() {
    mobiledocAssert('Cannot call _breakNestedAtCursor if not nested', this._isNested);

    let parent = this.cursorSection.parent;
    let cursorAtEndOfList = this.cursorPosition.isEqual(parent.tailPosition());

    if (cursorAtEndOfList) {
      let blank = this.builder.createMarkupSection();
      this._insertSectionAfter(blank, parent);
    } else {
      let [, blank,] = this._breakListAtCursor();
      this.cursorPosition = blank.tailPosition();
    }
  }

  _breakListAtCursor() {
    mobiledocAssert('Cannot _splitParentSection if cursor position is not nested',
           this._isNested);

    let list     = this.cursorSection.parent,
        position = this.cursorPosition,
        blank    = this.builder.createMarkupSection();
    let [pre, post] = this.postEditor._splitListAtPosition(list, position);

    let collection = this._post.sections,
        reference  = post;
    this.postEditor.insertSectionBefore(collection, blank, reference);
    return [pre, blank, post];
  }

  _wrapNestedSection(section) {
    let tagName = section.parent.tagName;
    let parent = this.builder.createListSection(tagName);
    parent.items.append(section.clone());
    return parent;
  }

  _mergeSection(section) {
    mobiledocAssert('Can only merge markerable sections',
           this._isMarkerable && section.isMarkerable);
    this._hasInsertedFirstLeafSection = true;

    let markers = section.markers.map(m => m.clone());
    let position = this.postEditor.insertMarkers(this.cursorPosition, markers);

    this.cursorPosition = position;
  }

  // Can be called to add a line break when in a nested section or a parent
  // section.
  _breakAtCursor() {
    if (this.cursorSection.isBlank) {
      return;
    } else if (this._isMarkerable) {
      this._breakMarkerableAtCursor();
    } else {
      this._breakNonMarkerableAtCursor();
    }
  }

  // Inserts a blank section before/after the cursor,
  // depending on cursor position.
  _breakNonMarkerableAtCursor() {
    let collection = this._post.sections,
        blank = this.builder.createMarkupSection(),
        reference = this.cursorPosition.isHead() ? this.cursorSection :
                                                   this.cursorSection.next;
    this.postEditor.insertSectionBefore(collection, blank, reference);
    this.cursorPosition = blank.tailPosition();
  }

  _breakMarkerableAtCursor() {
    let [pre,] =
      this.postEditor.splitSection(this.cursorPosition);

    this.cursorPosition = pre.tailPosition();
  }

  _replaceSection(section, newSections) {
    mobiledocAssert('Cannot replace section that does not have parent.sections',
           section.parent && section.parent.sections);
    mobiledocAssert('Must pass enumerable to _replaceSection', !!newSections.forEach);

    let collection = section.parent.sections;
    let reference = section.next;
    this.postEditor.removeSection(section);
    newSections.forEach(section => {
      this.postEditor.insertSectionBefore(collection, section, reference);
    });
    let lastSection = newSections[newSections.length - 1];

    this.cursorPosition = lastSection.tailPosition();
  }

  _insertSectionBefore(section, reference) {
    let collection = this.cursorSection.parent.sections;
    this.postEditor.insertSectionBefore(collection, section, reference);

    this.cursorPosition = section.tailPosition();
  }

  // Insert a section after the parent section.
  // E.g., add a markup section after a list section
  _insertSectionAfter(section, parent) {
    mobiledocAssert('Cannot _insertSectionAfter nested section', !parent.isNested);
    let reference = parent.next;
    let collection = this._post.sections;
    this.postEditor.insertSectionBefore(collection, section, reference);
    this.cursorPosition = section.tailPosition();
  }

  _insertLeafSection(section) {
    mobiledocAssert('Can only _insertLeafSection when cursor is at end of section',
           this.cursorPosition.isTail());

    this._hasInsertedFirstLeafSection = true;
    section = section.clone();

    if (this.cursorSection.isBlank) {
      mobiledocAssert('Cannot insert leaf non-markerable section when cursor is nested',
             !(section.isMarkerable && this._isNested));
      this._replaceSection(this.cursorSection, [section]);
    } else if (this.cursorSection.next && this.cursorSection.next.isBlank) {
      this._replaceSection(this.cursorSection.next, [section]);
    } else {
      let reference = this.cursorSection.next;
      this._insertSectionBefore(section, reference);
    }
  }
}

class Inserter {
  constructor(postEditor, post) {
    this.postEditor = postEditor;
    this.post = post;
  }

  insert(cursorPosition, newPost) {
    let visitor = new Visitor(this, cursorPosition);
    if (!newPost.isBlank) {
      visitor.visit(newPost);
    }
    return visitor.cursorPosition;
  }
}

/**
 * Usage:
 * Without a conditional, always prints deprecate message:
 *   `deprecate('This is deprecated')`
 *
 * Conditional deprecation, works similarly to `assert`, prints deprecation if
 * conditional is false:
 *   `deprecate('Deprecated only if foo !== bar', foo === bar)`
 */
function deprecate(message, conditional=false) {
  if (!conditional) {
    // eslint-disable-next-line no-console
    console.log(`[mobiledoc-kit] [DEPRECATED]: ${message}`);
  }
}

function toRange(rangeLike) {
  mobiledocAssert(`Must pass non-blank object to "toRange"`, !!rangeLike);

  if (rangeLike instanceof Range) {
    return rangeLike;
  } else if (rangeLike instanceof Position$1) {
    return rangeLike.toRange();
  }

  mobiledocAssert(`Incorrect structure for rangeLike: ${rangeLike}`, false);
}

const { FORWARD: FORWARD$1, BACKWARD: BACKWARD$1 } = DIRECTION;

function isListSectionTagName(tagName) {
  return tagName === 'ul' || tagName === 'ol';
}

const CALLBACK_QUEUES = {
  BEFORE_COMPLETE: 'beforeComplete',
  COMPLETE: 'complete',
  AFTER_COMPLETE: 'afterComplete'
};

// There are only two events that we're concerned about for Undo, that is inserting text and deleting content.
// These are the only two states that go on a "run" and create a combined undo, everything else has it's own
// deadicated undo.
const EDIT_ACTIONS = {
  INSERT_TEXT: 1,
  DELETE: 2
};


/**
 * The PostEditor is used to modify a post. It should not be instantiated directly.
 * Instead, a new instance of a PostEditor is created by the editor and passed
 * as the argument to the callback in {@link Editor#run}.
 *
 * Usage:
 * ```
 * editor.run((postEditor) => {
 *   // postEditor is an instance of PostEditor that can operate on the
 *   // editor's post
 * });
 * ```
 */
class PostEditor {
  /**
   * @private
   */
  constructor(editor) {
    this.editor = editor;
    this.builder = this.editor.builder;
    this._callbacks = new LifecycleCallbacks(values(CALLBACK_QUEUES));

    this._didComplete = false;
    this.editActionTaken = null;

    this._renderRange = () => this.editor.selectRange(this._range);
    this._postDidChange = () => this.editor._postDidChange();
    this._rerender = () => this.editor.rerender();
  }

  addCallback(...args) {
    this._callbacks.addCallback(...args);
  }

  addCallbackOnce(...args) {
    this._callbacks.addCallbackOnce(...args);
  }

  runCallbacks(...args) {
    this._callbacks.runCallbacks(...args);
  }

  begin() {
    // cache the editor's range
    this._range = this.editor.range;
  }

  /**
   * Schedules to select the given range on the editor after the postEditor
   * has completed its work. This also updates the postEditor's active range
   * (so that multiple calls to range-changing methods on the postEditor will
   * update the correct range).
   *
   * Usage:
   *   let range = editor.range;
   *   editor.run(postEditor => {
   *     let nextPosition = postEditor.deleteRange(range);
   *
   *     // Will position the editor's cursor at `nextPosition` after
   *     // the postEditor finishes work and the editor rerenders.
   *     postEditor.setRange(nextPosition);
   *   });
   * @param {Range|Position} range
   * @public
   */
  setRange(range) {
    range = toRange(range);

    // TODO validate that the range is valid
    // (does not contain marked-for-removal head or tail sections?)
    this._range = range;
    this.scheduleAfterRender(this._renderRange, true);
  }

  /**
   * Delete a range from the post
   *
   * Usage:
   * ```
   *     let { range } = editor;
   *     editor.run((postEditor) => {
   *       let nextPosition = postEditor.deleteRange(range);
   *       postEditor.setRange(nextPosition);
   *     });
   * ```
   * @param {Range} range Cursor Range object with head and tail Positions
   * @return {Position} The position where the cursor would go after deletion
   * @public
   */
  deleteRange(range) {
    mobiledocAssert("Must pass MobiledocKit Range to `deleteRange`", range instanceof Range);

    this.editActionTaken = EDIT_ACTIONS.DELETE;

    let {
      head, head: {section: headSection},
      tail, tail: {section: tailSection}
    } = range;

    let { editor: { post } } = this;

    if (headSection === tailSection) {
      return this.cutSection(headSection, head, tail);
    }

    let nextSection = headSection.nextLeafSection();

    let nextPos = this.cutSection(headSection, head, headSection.tailPosition());
    // cutSection can replace the section, so re-read headSection here
    headSection = nextPos.section;

    // Remove sections in the middle of the range
    while (nextSection !== tailSection) {
      let tmp = nextSection;
      nextSection = nextSection.nextLeafSection();
      this.removeSection(tmp);
    }

    let tailPos = this.cutSection(tailSection, tailSection.headPosition(), tail);
    // cutSection can replace the section, so re-read tailSection here
    tailSection = tailPos.section;

    if (tailSection.isBlank) {
      this.removeSection(tailSection);
    } else {
      // If head and tail sections are markerable, join them
      // Note: They may not be the same section type. E.g. this may join
      // a tail section that was a list item onto a markup section, or vice versa.
      // (This is the desired behavior.)
      if (headSection.isMarkerable && tailSection.isMarkerable) {
        headSection.join(tailSection);
        this._markDirty(headSection);
        this.removeSection(tailSection);
      } else if (headSection.isBlank) {
        this.removeSection(headSection);
        nextPos = tailPos;
      }
    }

    if (post.isBlank) {
      post.sections.append(this.builder.createMarkupSection('p'));
      nextPos = post.headPosition();
    }

    return nextPos;
  }

  /**
   * Note: This method may replace `section` with a different section.
   *
   * "Cut" out the part of the section inside `headOffset` and `tailOffset`.
   * If section is markerable this splits markers that straddle the head or tail (if necessary),
   * and removes markers that are wholly inside the offsets.
   * If section is a card, this may replace it with a blank markup section if the
   * positions contain the entire card.
   *
   * @param {Section} section
   * @param {Position} head
   * @param {Position} tail
   * @return {Position}
   * @private
   */
  cutSection(section, head, tail) {
    mobiledocAssert('Must pass head position and tail position to `cutSection`',
           head instanceof Position$1 && tail instanceof Position$1);
    mobiledocAssert('Must pass positions within same section to `cutSection`',
           head.section === tail.section);

    if (section.isBlank || head.isEqual(tail)) {
      return head;
    }
    if (section.isCardSection) {
      if (head.isHead() && tail.isTail()) {
        let newSection = this.builder.createMarkupSection();
        this.replaceSection(section, newSection);
        return newSection.headPosition();
      } else {
        return tail;
      }
    }

    let range = head.toRange(tail);
    this.splitMarkers(range).forEach(m => this.removeMarker(m));

    return head;
  }

  _coalesceMarkers(section) {
    if (section.isMarkerable) {
      this._removeBlankMarkers(section);
      this._joinSimilarMarkers(section);
    }
  }

  _removeBlankMarkers(section) {
    forEach(
      filter(section.markers, m => m.isBlank),
      m => this.removeMarker(m)
    );
  }

  // joins markers that have identical markups
  _joinSimilarMarkers(section) {
    let marker = section.markers.head;
    let nextMarker;
    while (marker && marker.next) {
      nextMarker = marker.next;

      if (marker.canJoin(nextMarker)) {
        nextMarker.value = marker.value + nextMarker.value;
        this._markDirty(nextMarker);
        this.removeMarker(marker);
      }

      marker = nextMarker;
    }
  }

  removeMarker(marker) {
    this._scheduleForRemoval(marker);
    if (marker.section) {
      this._markDirty(marker.section);
      marker.section.markers.remove(marker);
    }
  }

  _scheduleForRemoval(postNode) {
    if (postNode.renderNode) {
      postNode.renderNode.scheduleForRemoval();

      this.scheduleRerender();
      this.scheduleDidUpdate();
    }
    let removedAdjacentToList = (postNode.prev && postNode.prev.isListSection) ||
                                (postNode.next && postNode.next.isListSection);
    if (removedAdjacentToList) {
      this.addCallback(
        CALLBACK_QUEUES.BEFORE_COMPLETE,
        () => this._joinContiguousListSections()
      );
    }
  }

  _joinContiguousListSections() {
    let { post } = this.editor;
    let range = this._range;
    let prev;
    let groups = [];
    let currentGroup;

    // FIXME do we need to force a re-render of the range if changed sections
    // are contained within the range?
    let updatedHead = null;
    forEach(post.sections, section => {
      if (prev &&
          prev.isListSection &&
          section.isListSection &&
          prev.tagName === section.tagName) {

        currentGroup = currentGroup || [prev];
        currentGroup.push(section);
      } else {
        if (currentGroup) {
          groups.push(currentGroup);
        }
        currentGroup = null;
      }
      prev = section;
    });

    if (currentGroup) {
      groups.push(currentGroup);
    }

    forEach(groups, group => {
      let list = group[0];
      forEach(group, listSection => {
        if (listSection === list) {
          return;
        }

        let currentHead = range.head;
        let prevPosition;

        // FIXME is there a currentHead if there is no range?
        // is the current head a list item in the section
        if (!range.isBlank && currentHead.section.isListItem &&
            currentHead.section.parent === listSection) {
          prevPosition = list.tailPosition();
        }
        this._joinListSections(list, listSection);
        if (prevPosition) {
          updatedHead = prevPosition.move(FORWARD$1);
        }
      });
    });

    if (updatedHead) {
      this.setRange(updatedHead);
    }
  }

  _joinListSections(baseList, nextList) {
    baseList.join(nextList);
    this._markDirty(baseList);
    this.removeSection(nextList);
  }

  _markDirty(postNode) {
    if (postNode.renderNode) {
      postNode.renderNode.markDirty();

      this.scheduleRerender();
      this.scheduleDidUpdate();
    }
    if (postNode.section) {
      this._markDirty(postNode.section);
    }
    if (postNode.isMarkerable) {
      this.addCallback(
        CALLBACK_QUEUES.BEFORE_COMPLETE, () => this._coalesceMarkers(postNode));
    }
  }

  /**
   * @param {Position} position object with {section, offset} the marker and offset to delete from
   * @param {Number} direction The direction to delete in (default is BACKWARD)
   * @return {Position} for positioning the cursor
   * @public
   * @deprecated after v0.10.3
   */
  deleteFrom(position, direction=DIRECTION.BACKWARD) {
    deprecate("`postEditor#deleteFrom is deprecated. Use `deleteAtPosition(position, direction=BACKWARD, {unit}={unit: 'char'})` instead");
    return this.deleteAtPosition(position, direction, {unit: 'char'});
  }

  /**
   * Delete 1 `unit` (can be 'char' or 'word') in the given `direction` at the given
   * `position`. In almost all cases this will be equivalent to deleting the range formed
   * by expanding the position 1 unit in the given direction. The exception is when deleting
   * backward from the beginning of a list item, which reverts the list item into a markup section
   * instead of joining it with its previous list item (if any).
   *
   * Usage:
   *
   *     let position = section.tailPosition();
   *     // Section has text of "Howdy!"
   *     editor.run((postEditor) => {
   *       postEditor.deleteAtPosition(position);
   *     });
   *     // section has text of "Howdy"
   *
   * @param {Position} position The position to delete at
   * @param {Direction} [direction=DIRECTION.BACKWARD] direction The direction to delete in
   * @param {Object} [options]
   * @param {String} [options.unit="char"] The unit of deletion ("word" or "char")
   * @return {Position}
   */
  deleteAtPosition(position, direction=DIRECTION.BACKWARD, {unit}={unit: 'char'}) {
    if (direction === DIRECTION.BACKWARD) {
      return this._deleteAtPositionBackward(position, unit);
    } else {
      return this._deleteAtPositionForward(position, unit);
    }
  }

  _deleteAtPositionBackward(position, unit) {
    if (position.isHead() && position.section.isListItem) {
      this.toggleSection('p', position);
      return this._range.head;
    } else {
      let prevPosition = unit === 'word' ? position.moveWord(BACKWARD$1) : position.move(BACKWARD$1);
      let range = prevPosition.toRange(position);
      return this.deleteRange(range);
    }
  }

  _deleteAtPositionForward(position, unit) {
    let nextPosition = unit === 'word' ? position.moveWord(FORWARD$1) : position.move(FORWARD$1);
    let range = position.toRange(nextPosition);
    return this.deleteRange(range);
  }

  /**
   * Split markers at two positions, once at the head, and if necessary once
   * at the tail.
   *
   * Usage:
   * ```
   *     let range = editor.range;
   *     editor.run((postEditor) => {
   *       postEditor.splitMarkers(range);
   *     });
   * ```
   * The return value will be marker object completely inside the offsets
   * provided. Markers outside of the split may also have been modified.
   *
   * @param {Range} markerRange
   * @return {Array} of markers that are inside the split
   * @private
   */
  splitMarkers(range) {
    const { post } = this.editor;
    const { head, tail } = range;

    this.splitSectionMarkerAtOffset(head.section, head.offset);
    this.splitSectionMarkerAtOffset(tail.section, tail.offset);

    return post.markersContainedByRange(range);
  }

  splitSectionMarkerAtOffset(section, offset) {
    const edit = section.splitMarkerAtOffset(offset);
    edit.removed.forEach(m => this.removeMarker(m));
  }

  /**
   * Split the section at the position.
   *
   * Usage:
   * ```
   *     let position = editor.cursor.offsets.head;
   *     editor.run((postEditor) => {
   *       postEditor.splitSection(position);
   *     });
   *     // Will result in the creation of two new sections
   *     // replacing the old one at the cursor position
   * ```
   * The return value will be the two new sections. One or both of these
   * sections can be blank (contain only a blank marker), for example if the
   * headMarkerOffset is 0.
   *
   * @param {Position} position
   * @return {Array} new sections, one for the first half and one for the second (either one can be null)
   * @public
   */
  splitSection(position) {
    const { section } = position;

    if (section.isCardSection) {
      return this._splitCardSection(section, position);
    } else if (section.isListItem) {
      let isLastAndBlank = section.isBlank && !section.next;
      if (isLastAndBlank) {
        // if is last, replace the item with a blank markup section
        let parent = section.parent;
        let collection = this.editor.post.sections;
        let blank = this.builder.createMarkupSection();
        this.removeSection(section);
        this.insertSectionBefore(collection, blank, parent.next);

        return [null, blank];
      } else {
        let [pre, post] = this._splitListItem(section, position);
        return [pre, post];
      }
    } else {
      let splitSections = section.splitAtPosition(position);
      splitSections.forEach(s => this._coalesceMarkers(s));
      this._replaceSection(section, splitSections);

      return splitSections;
    }
  }

  /**
   * @param {Section} cardSection
   * @param {Position} position to split at
   * @return {Section[]} 2-item array of pre and post-split sections
   * @private
   */
  _splitCardSection(cardSection, position) {
    let { offset } = position;
    mobiledocAssert('Cards section must be split at offset 0 or 1',
           offset === 0 || offset === 1);

    let newSection = this.builder.createMarkupSection();
    let nextSection;
    let surroundingSections;

    if (offset === 0) {
      nextSection = cardSection;
      surroundingSections = [newSection, cardSection];
    } else {
      nextSection = cardSection.next;
      surroundingSections = [cardSection, newSection];
    }

    let collection = this.editor.post.sections;
    this.insertSectionBefore(collection, newSection, nextSection);

    return surroundingSections;
  }

  /**
   * @param {Section} section
   * @param {Section} newSection
   * @return null
   * @public
   */
  replaceSection(section, newSection) {
    if (!section) {
      // FIXME should a falsy section be a valid argument?
      this.insertSectionBefore(this.editor.post.sections, newSection, null);
    } else {
      this._replaceSection(section, [newSection]);
    }
  }

  moveSectionBefore(collection, renderedSection, beforeSection) {
    const newSection = renderedSection.clone();
    this.removeSection(renderedSection);
    this.insertSectionBefore(collection, newSection, beforeSection);
    return newSection;
  }

  /**
   * @param {Section} section A section that is already in DOM
   * @public
   */
  moveSectionUp(renderedSection) {
    const isFirst = !renderedSection.prev;
    if (isFirst) {
      return renderedSection;
    }

    const collection = renderedSection.parent.sections;
    const beforeSection = renderedSection.prev;
    return this.moveSectionBefore(collection, renderedSection, beforeSection);
  }

  /**
   * @param {Section} section A section that is already in DOM
   * @public
   */
  moveSectionDown(renderedSection) {
    const isLast = !renderedSection.next;
    if (isLast) {
      return renderedSection;
    }

    const beforeSection = renderedSection.next.next;
    const collection = renderedSection.parent.sections;
    return this.moveSectionBefore(collection, renderedSection, beforeSection);
  }

  /**
   * Insert an array of markers at the given position. If the position is in
   * a non-markerable section (like a card section), this method throws an error.
   *
   * @param {Position} position
   * @param {Marker[]} markers
   * @return {Position} The position that represents the end of the inserted markers.
   * @public
   */
  insertMarkers(position, markers) {
    let { section, offset } = position;
    mobiledocAssert('Cannot insert markers at non-markerable position',
           section.isMarkerable);

    this.editActionTaken = EDIT_ACTIONS.INSERT_TEXT;

    let edit = section.splitMarkerAtOffset(offset);
    edit.removed.forEach(marker => this._scheduleForRemoval(marker));

    let prevMarker = section.markerBeforeOffset(offset);
    markers.forEach(marker => {
      section.markers.insertAfter(marker, prevMarker);
      offset += marker.length;
      prevMarker = marker;
    });

    this._coalesceMarkers(section);
    this._markDirty(section);

    let nextPosition = section.toPosition(offset);
    this.setRange(nextPosition);
    return nextPosition;
  }

  /**
   * Inserts text with the given markups, ignoring the existing markups at
   * the position, if any.
   *
   * @param {Position} position
   * @param {String} text
   * @param {Markup[]} markups
   * @return {Position} position at the end of the inserted text
   */
  insertTextWithMarkup(position, text, markups=[]) {
    let { section } = position;
    if (!section.isMarkerable) { return; }
    let marker = this.builder.createMarker(text, markups);
    return this.insertMarkers(position, [marker]);
  }

  /**
   * Insert the text at the given position
   * Inherits the markups already at that position, if any.
   *
   * @param {Position} position
   * @param {String} text
   * @return {Position} position at the end of the inserted text.
   */
  insertText(position, text) {
    let { section } = position;
    if (!section.isMarkerable) { return; }
    let markups = position.marker && position.marker.markups;
    markups = markups || [];
    return this.insertTextWithMarkup(position, text, markups);
  }

  _replaceSection(section, newSections) {
    let nextSection = section.next;
    let collection = section.parent.sections;

    let nextNewSection = newSections[0];
    if (nextNewSection.isMarkupSection && section.isListItem) {
      // put the new section after the ListSection (section.parent)
      // instead of after the ListItem
      collection = section.parent.parent.sections;
      nextSection = section.parent.next;
    }

    newSections.forEach(s => this.insertSectionBefore(collection, s, nextSection));
    this.removeSection(section);
  }

  /**
   * Given a markerRange (for example `editor.range`) mark all markers
   * inside it as a given markup. The markup must be provided as a post
   * abstract node.
   *
   * Usage:
   *
   *     let range = editor.range;
   *     let strongMarkup = editor.builder.createMarkup('strong');
   *     editor.run((postEditor) => {
   *       postEditor.addMarkupToRange(range, strongMarkup);
   *     });
   *     // Will result some markers possibly being split, and the markup
   *     // being applied to all markers between the split.
   *
   * @param {Range} range
   * @param {Markup} markup A markup post abstract node
   * @public
   */
  addMarkupToRange(range, markup) {
    if (range.isCollapsed) { return; }

    let markers = this.splitMarkers(range);
    if (markers.length) {
      // We insert the new markup at a consistent index across the range.
      // If we just push on the end of the list, it can end up in different positions
      // of the markup stack. This results in unnecessary closing and re-opening of
      // the markup each time it changes position.
      // If we just push it at the beginning of the list, this causes unnecessary closing
      // and re-opening of surrounding tags.
      // So, we look for any tags open across the whole range, and push into the stack
      // at the end of those.
      // Prompted by https://github.com/bustle/mobiledoc-kit/issues/360

      let markupsOpenAcrossRange = reduce(markers, function (soFar, marker) {
        return commonItems(soFar, marker.markups);
      }, markers[0].markups);
      let indexToInsert = markupsOpenAcrossRange.length;

      markers.forEach(marker => {
        marker.addMarkupAtIndex(markup, indexToInsert);
        this._markDirty(marker);
      });
    }
  }

  /**
   * Given a markerRange (for example `editor.range`) remove the given
   * markup from all contained markers.
   *
   * Usage:
   * ```
   *     let { range } = editor;
   *     let markup = markerRange.headMarker.markups[0];
   *     editor.run(postEditor => {
   *       postEditor.removeMarkupFromRange(range, markup);
   *     });
   *     // Will result in some markers possibly being split, and the markup
   *     // being removed from all markers between the split.
   * ```
   * @param {Range} range Object with offsets
   * @param {Markup|Function} markupOrCallback A markup post abstract node or
   * a function that returns true when passed a markup that should be removed
   * @private
   */
  removeMarkupFromRange(range, markupOrMarkupCallback) {
    if (range.isCollapsed) { return; }

    this.splitMarkers(range).forEach(marker => {
      marker.removeMarkup(markupOrMarkupCallback);
      this._markDirty(marker);
    });
  }

  /**
   * Toggle the given markup in the given range (or at the position given). If the range/position
   * has the markup, the markup will be removed. If nothing in the range/position
   * has the markup, the markup will be added to everything in the range/position.
   *
   * Usage:
   * ```
   * // Remove any 'strong' markup if it exists in the selection, otherwise
   * // make it all 'strong'
   * editor.run(postEditor => postEditor.toggleMarkup('strong'));
   *
   * // add/remove a link to 'bustle.com' to the selection
   * editor.run(postEditor => {
   *   const linkMarkup = postEditor.builder.createMarkup('a', {href: 'http://bustle.com'});
   *   postEditor.toggleMarkup(linkMarkup);
   * });
   * ```
   * @param {Markup|String} markupOrString Either a markup object created using
   * the builder (useful when adding a markup with attributes, like an 'a' markup),
   * or, if a string, the tag name of the markup (e.g. 'strong', 'em') to toggle.
   * @param {Range|Position} range in which to toggle. Defaults to current editor range.
   * @public
   */
  toggleMarkup(markupOrMarkupString, range=this._range) {
    range = toRange(range);
    const markup = typeof markupOrMarkupString === 'string' ?
                     this.builder.createMarkup(markupOrMarkupString) :
                     markupOrMarkupString;

    const hasMarkup = this.editor.detectMarkupInRange(range, markup.tagName);
    // FIXME: This implies only a single markup in a range. This may not be
    // true for links (which are not the same object instance like multiple
    // strong tags would be).
    if (hasMarkup) {
      this.removeMarkupFromRange(range, hasMarkup);
    } else {
      this.addMarkupToRange(range, markup);
    }

    this.setRange(range);
  }

  /**
   * Toggles the tagName of the active section or sections in the given range/position.
   * If every section has the tag name, they will all be reset to default sections.
   * Otherwise, every section will be changed to the requested type
   *
   * @param {String} sectionTagName A valid markup section or
   *        list section tag name (e.g. 'blockquote', 'h2', 'ul')
   * @param {Range|Position} range The range over which to toggle.
   *        Defaults to the current editor range.
   * @public
   */
  toggleSection(sectionTagName, range=this._range) {
    range = toRange(range);

    sectionTagName = normalizeTagName(sectionTagName);
    let { post } = this.editor;

    let everySectionHasTagName = true;
    post.walkMarkerableSections(range, section => {
      if (!this._isSameSectionType(section, sectionTagName)) {
        everySectionHasTagName = false;
      }
    });

    let tagName = everySectionHasTagName ? 'p' : sectionTagName;
    let sectionTransformations = [];
    post.walkMarkerableSections(range, section => {
      let changedSection = this.changeSectionTagName(section, tagName);
      sectionTransformations.push({
        from: section,
        to: changedSection
      });
    });

    let nextRange = this._determineNextRangeAfterToggleSection(range, sectionTransformations);
    this.setRange(nextRange);
  }

  _determineNextRangeAfterToggleSection(range, sectionTransformations) {
    if (sectionTransformations.length) {
      let changedHeadSection = detect(sectionTransformations, ({ from }) => {
        return from === range.headSection;
      }).to;
      let changedTailSection = detect(sectionTransformations, ({ from }) => {
        return from === range.tailSection;
      }).to;

      if (changedHeadSection.isListSection || changedTailSection.isListSection) {
        // We don't know to which ListItem's the original sections point at, so
        // we don't have enough information to reconstruct the range when
        // dealing with lists.
        return sectionTransformations[0].to.headPosition().toRange();
      } else {
        return Range.create(
          changedHeadSection,
          range.headSectionOffset,
          changedTailSection,
          range.tailSectionOffset,
          range.direction
        );
      }
    } else {
      return range;
    }
  }

  setAttribute(key, value, range=this._range) {
    this._mutateAttribute(key, range, (section, attribute) => {
      if (section.getAttribute(attribute) !== value) {
        section.setAttribute(attribute, value);
        return true;
      }
    });
  }

  removeAttribute(key, range=this._range) {
    this._mutateAttribute(key, range, (section, attribute) => {
      if (section.hasAttribute(attribute)) {
        section.removeAttribute(attribute);
        return true;
      }
    });
  }

  _mutateAttribute(key, range, cb) {
    range = toRange(range);
    let { post } = this.editor;
    let attribute = `data-md-${key}`;

    post.walkMarkerableSections(range, section => {
      if (section.isListItem) {
        section = section.parent;
      }

      if (cb(section, attribute) === true) {
        this._markDirty(section);
      }
    });

    this.setRange(range);
  }

  _isSameSectionType(section, sectionTagName) {
    return section.isListItem ?
      section.parent.tagName === sectionTagName :
      section.tagName        === sectionTagName;
  }

  /**
   * @param {Markerable} section
   * @private
   */
  changeSectionTagName(section, newTagName) {
    mobiledocAssert('Cannot pass non-markerable section to `changeSectionTagName`',
           section.isMarkerable);

    if (isListSectionTagName(newTagName)) {
      return this._changeSectionToListItem(section, newTagName);
    } else if (section.isListItem) {
      return this._changeSectionFromListItem(section, newTagName);
    } else {
      section.tagName = newTagName;
      this._markDirty(section);
      return section;
    }
  }

  /**
   * Splits the item at the position given.
   * If the position is at the start or end of the item, the pre- or post-item
   * will contain a single empty ("") marker.
   * @param {ListItem} item
   * @param {Position} position
   * @return {Array} the pre-item and post-item on either side of the split
   * @private
   */
  _splitListItem(item, position) {
    let { section, offset } = position;
    mobiledocAssert('Cannot split list item at position that does not include item',
           item === section);

    item.splitMarkerAtOffset(offset);
    let prevMarker = item.markerBeforeOffset(offset);
    let preItem  = this.builder.createListItem(),
        postItem = this.builder.createListItem();

    let currentItem = preItem;
    item.markers.forEach(marker => {
      currentItem.markers.append(marker.clone());
      if (marker === prevMarker) {
        currentItem = postItem;
      }
    });
    this._replaceSection(item, [preItem, postItem]);
    return [preItem, postItem];
  }

  /**
   * Splits the list at the position given.
   * @return {Array} pre-split list and post-split list, either of which could
   * be blank (0-item list) if the position is at the start or end of the list.
   *
   * Note: Contiguous list sections will be joined in the before_complete queue
   * of the postEditor.
   *
   * @private
   */
  _splitListAtPosition(list, position) {
    mobiledocAssert('Cannot split list at position not in list',
           position.section.parent === list);

    let positionIsMiddle = !position.isHead() && !position.isTail();
    if (positionIsMiddle) {
      let item = position.section;
      let [pre,] =
        this._splitListItem(item, position);
      position = pre.tailPosition();
    }

    let preList  = this.builder.createListSection(list.tagName);
    let postList = this.builder.createListSection(list.tagName);

    let preItem = position.section;
    let currentList = preList;
    list.items.forEach(item => {
      // If this item matches the start item and the position is at its start,
      // it should be appended to the postList instead of the preList
      if (item === preItem && position.isEqual(item.headPosition())) {
        currentList = postList;
      }
      currentList.items.append(item.clone());
      // If we just appended the preItem, append the remaining items to the postList
      if (item === preItem) {
        currentList = postList;
      }
    });

    this._replaceSection(list, [preList, postList]);
    return [preList, postList];
  }

  /**
   * @return Array of [prev, mid, next] lists. `prev` and `next` can
   *         be blank, depending on the position of `item`. `mid` will always
   *         be a 1-item list containing `item`. `prev` and `next` will be
   *         removed in the before_complete queue if they are blank
   *         (and still attached).
   *
   * @private
   */
  _splitListAtItem(list, item) {
    let next = list;
    let prev = this.builder.createListSection(next.tagName, [], next.attributes);
    let mid = this.builder.createListSection(next.tagName);

    let addToPrev = true;
    // must turn the LinkedList into an array so that we can remove items
    // as we iterate through it
    let items = next.items.toArray();
    items.forEach(i => {
      let listToAppend;
      if (i === item) {
        addToPrev    = false;
        listToAppend = mid;
      } else if (addToPrev) {
        listToAppend = prev;
      } else {
        return; // break after iterating prev and mid parts of the list
      }
      listToAppend.join(i);
      this.removeSection(i);
    });
    let found = !addToPrev;
    mobiledocAssert('Cannot split list at item that is not present in the list', found);

    let collection = this.editor.post.sections;
    this.insertSectionBefore(collection, mid, next);
    this.insertSectionBefore(collection, prev, mid);

    // Remove possibly blank prev/next lists
    this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => {
      [prev, next].forEach(_list => {
        let isAttached = !!_list.parent;
        if (_list.isBlank && isAttached) {
          this.removeSection(_list);
        }
      });
    });

    return [prev, mid, next];
  }

  _changeSectionFromListItem(section, newTagName) {
    mobiledocAssert('Must pass list item to `_changeSectionFromListItem`',
           section.isListItem);

    let listSection = section.parent;
    let markupSection = this.builder.createMarkupSection(newTagName);
    markupSection.join(section);

    let [, mid,] = this._splitListAtItem(listSection, section);
    this.replaceSection(mid, markupSection);
    return markupSection;
  }

  _changeSectionToListItem(section, newTagName) {
    let isAlreadyCorrectListItem = section.isListItem &&
      section.parent.tagName === newTagName;

    if (isAlreadyCorrectListItem) {
      return section;
    }

    let listSection = this.builder.createListSection(newTagName);
    listSection.join(section);

    let sectionToReplace;
    if (section.isListItem) {
      let [, mid,] = this._splitListAtItem(section.parent, section);
      sectionToReplace = mid;
    } else {
      sectionToReplace = section;
    }
    this.replaceSection(sectionToReplace, listSection);
    return listSection;
  }

  /**
   * Insert a given section before another one, updating the post abstract
   * and the rendered UI.
   *
   * Usage:
   * ```
   *     let markerRange = editor.range;
   *     let sectionWithCursor = markerRange.headMarker.section;
   *     let section = editor.builder.createCardSection('my-image');
   *     let collection = sectionWithCursor.parent.sections;
   *     editor.run((postEditor) => {
   *       postEditor.insertSectionBefore(collection, section, sectionWithCursor);
   *     });
   * ```
   * @param {LinkedList} collection The list of sections to insert into
   * @param {Object} section The new section
   * @param {Object} beforeSection Optional The section "before" is relative to,
   *        if falsy the new section will be appended to the collection
   * @public
   */
  insertSectionBefore(collection, section, beforeSection) {
    collection.insertBefore(section, beforeSection);
    this._markDirty(section.parent);
  }

  /**
   * Insert the given section after the current active section, or, if no
   * section is active, at the end of the document.
   * @param {Section} section
   * @public
   */
  insertSection(section) {
    const activeSection = this.editor.activeSection;
    const nextSection = activeSection && activeSection.next;

    const collection = this.editor.post.sections;
    this.insertSectionBefore(collection, section, nextSection);
  }

  /**
   * Insert the given section at the end of the document.
   * @param {Section} section
   * @public
   */
  insertSectionAtEnd(section) {
    this.insertSectionBefore(this.editor.post.sections, section, null);
  }

  /**
   * Insert the `post` at the given position in the editor's post.
   * @param {Position} position
   * @param {Post} post
   * @private
   */
  insertPost(position, newPost) {
    let post = this.editor.post;
    let inserter = new Inserter(this, post);
    let nextPosition = inserter.insert(position, newPost);
    return nextPosition;
  }

  /**
   * Remove a given section from the post abstract and the rendered UI.
   *
   * Usage:
   * ```
   *     let { range } = editor;
   *     let sectionWithCursor = range.head.section;
   *     editor.run((postEditor) => {
   *       postEditor.removeSection(sectionWithCursor);
   *     });
   * ```
   * @param {Object} section The section to remove
   * @public
   */
  removeSection(section) {
    let parent          = section.parent;
    this._scheduleForRemoval(section);
    parent.sections.remove(section);

    if (parent.isListSection) {
      this._scheduleListRemovalIfEmpty(parent);
    }
  }

  removeAllSections() {
    this.editor.post.sections.toArray().forEach(section => {
      this.removeSection(section);
    });
  }

  migrateSectionsFromPost(post) {
    post.sections.toArray().forEach(section => {
      post.sections.remove(section);
      this.insertSectionBefore(this.editor.post.sections, section, null);
    });
  }

  _scheduleListRemovalIfEmpty(listSection) {
    this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => {
      // if the list is attached and blank after we do other rendering stuff,
      // remove it
      let isAttached = !!listSection.parent;
      if (isAttached && listSection.isBlank) {
        this.removeSection(listSection);
      }
    });
  }

  /**
   * A method for adding work the deferred queue
   *
   * @param {Function} callback to run during completion
   * @param {Boolean} [once=false] Whether to only schedule the callback once.
   * @public
   */
  schedule(callback, once=false) {
    mobiledocAssert('Work can only be scheduled before a post edit has completed',
           !this._didComplete);
    if (once) {
      this.addCallbackOnce(CALLBACK_QUEUES.COMPLETE, callback);
    } else {
      this.addCallback(CALLBACK_QUEUES.COMPLETE, callback);
    }
  }

  /**
   * A method for adding work the deferred queue. The callback will only
   * be added to the queue once, even if `scheduleOnce` is called multiple times.
   * The function cannot be an anonymous function.
   *
   * @param {Function} callback to run during completion
   * @public
   */
  scheduleOnce(callback) {
    this.schedule(callback, true);
  }

  /**
   * Add a rerender job to the queue
   *
   * @public
   */
  scheduleRerender() {
    this.scheduleOnce(this._rerender);
  }

  /**
   * Schedule a notification that the post has been changed.
   * The notification will result in the editor firing its `postDidChange`
   * hook after the postEditor completes its work (at the end of {@link Editor#run}).
   *
   * @public
   */
  scheduleDidUpdate() {
    this.scheduleOnce(this._postDidChange);
  }

  scheduleAfterRender(callback, once=false) {
    if (once) {
      this.addCallbackOnce(CALLBACK_QUEUES.AFTER_COMPLETE, callback);
    } else {
      this.addCallback(CALLBACK_QUEUES.AFTER_COMPLETE, callback);
    }
  }

  /**
   * Flush any work on the queue. {@link Editor#run} calls this method; it
   * should not be called directly.
   *
   * @private
   */
  complete() {
    mobiledocAssert('Post editing can only be completed once', !this._didComplete);

    this.runCallbacks(CALLBACK_QUEUES.BEFORE_COMPLETE);
    this._didComplete = true;
    this.runCallbacks(CALLBACK_QUEUES.COMPLETE);
    this.runCallbacks(CALLBACK_QUEUES.AFTER_COMPLETE);
  }

  undoLastChange() {
    this.editor._editHistory.stepBackward(this);
  }

  redoLastChange() {
    this.editor._editHistory.stepForward(this);
  }

  cancelSnapshot() {
    this._shouldCancelSnapshot = true;
  }
}

const placeholderImageSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAMFBMVEXp7vG6vsHm6+63u77Hy868wMPe4+bO09bh5unr8fTR1djAxMfM0NPX3N/c4eTBxcjXRf5TAAACh0lEQVR4nO3b6ZKqMBSFUSQMYZL3f9tbBq/NEEDiqUqOfusn1ZXKbjcQlGQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACC6RkbsGHuabChEtHmiGYfS3EQYM+Sxw/gMQvmcNnYaj6oTDHi73WPn2eqnj9B8zo3TJXcq5uNjXmVff86VwSR3JtryMa1BYqi7S1hJDCVpSigyLcGhJJEwzlCSNtPKrbVhVwsdCfOhH7uuaG3ARV9DwsaOzxt3N1yPqCHhvXytTUz92VDpmE/LLhZwl++R6Sds6sUa/PL6K/2E2fIhw1xdRKefsFolrPc+xNx/N0k/4fpBsdhL2HfeiN+TsDCms8dDpeRyS3P3QDl6Iqaf8L0rTf+80m6Lmn7Ct+4Wxf+/2RY1/YRv3PHz/u+fsCmqgoTnq7Z+8SGviqoh4dnKu1ieqauiakh4/PQ0r6ivqDoSHj0B97eNRVG1JNxV+L4bnxdVecJtRTdFVZ7QU9F1UXUn9FZ0VVRlCav5ob2KLouqKmFjy676u2HsVnRRVFUJq3J+8KCi86IqSthMvyl209Hjijqm3RsqAZ5pNfa5PJ2KelJRjQmr1/r7cfy0ouoSNvOfvbvhvKLaEr4qOin9kTQnrN7LpDZhE/Zmhp6Eq4p+YcKgiipKGFhRRQkDK6ooYfgLbiSMioQkJGF8P5XwHv4O+7AaKiXzaeXh1kMl5AffTUxiKEm/krD94BR8Gdxl1fceSlR58ZhXKbEpyD2amNiBtmrJLTMHL1LF8/rpXkSZXEmz8K8uvAFFNm6Iq0aBLUFOmeCuJ6exrcCmoLpN7kYx891bSAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgh/wDdr8peyRHLogAAAAASUVORK5CYII=";

var ImageCard = {
  name: 'image',
  type: 'dom',

  render({payload}) {
    let img = document.createElement('img');
    img.src = payload.src || placeholderImageSrc;
    return img;
  }
};

function visit(visitor, node, opcodes) {
  const method = node.type;
  mobiledocAssert(`Cannot visit unknown type ${method}`, !!visitor[method]);
  visitor[method](node, opcodes);
}

function compile(compiler, opcodes) {
  for (var i=0, l=opcodes.length; i<l; i++) {
    let [method, ...params] = opcodes[i];
    let length = params.length;
    if (length === 0) {
      compiler[method].call(compiler);
    } else if (length === 1) {
      compiler[method].call(compiler, params[0]);
    } else if (length === 2) {
      compiler[method].call(compiler, params[0], params[1]);
    } else {
      compiler[method].apply(compiler, params);
    }
  }
}

function visitArray(visitor, nodes, opcodes) {
  if (!nodes || nodes.length === 0) {
    return;
  }
  forEach(nodes, node => {
    visit(visitor, node, opcodes);
  });
}

const MOBILEDOC_VERSION = '0.2.0';
const MOBILEDOC_MARKUP_SECTION_TYPE = 1;
const MOBILEDOC_IMAGE_SECTION_TYPE = 2;
const MOBILEDOC_LIST_SECTION_TYPE = 3;
const MOBILEDOC_CARD_SECTION_TYPE = 10;

const visitor = {
  [POST_TYPE](node, opcodes) {
    opcodes.push(['openPost']);
    visitArray(visitor, node.sections, opcodes);
  },
  [MARKUP_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openMarkupSection', node.tagName]);
    visitArray(visitor, node.markers, opcodes);
  },
  [LIST_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openListSection', node.tagName]);
    visitArray(visitor, node.items, opcodes);
  },
  [LIST_ITEM_TYPE](node, opcodes) {
    opcodes.push(['openListItem']);
    visitArray(visitor, node.markers, opcodes);
  },
  [IMAGE_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openImageSection', node.src]);
  },
  [CARD_TYPE](node, opcodes) {
    opcodes.push(['openCardSection', node.name, node.payload]);
  },
  [MARKER_TYPE](node, opcodes) {
    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);
    visitArray(visitor, node.openedMarkups, opcodes);
  },
  [MARKUP_TYPE](node, opcodes) {
    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);
  }
};

const postOpcodeCompiler = {
  openMarker(closeCount, value) {
    this.markupMarkerIds = [];
    this.markers.push([
      this.markupMarkerIds,
      closeCount,
      value || ''
    ]);
  },
  openMarkupSection(tagName) {
    this.markers = [];
    this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE, tagName, this.markers]);
  },
  openListSection(tagName) {
    this.items = [];
    this.sections.push([MOBILEDOC_LIST_SECTION_TYPE, tagName, this.items]);
  },
  openListItem() {
    this.markers = [];
    this.items.push(this.markers);
  },
  openImageSection(url) {
    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE, url]);
  },
  openCardSection(name, payload) {
    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE, name, payload]);
  },
  openPost() {
    this.markerTypes = [];
    this.sections = [];
    this.result = {
      version: MOBILEDOC_VERSION,
      sections: [this.markerTypes, this.sections]
    };
  },
  openMarkup(tagName, attributes) {
    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);
    this.markupMarkerIds.push(index);
  },
  _findOrAddMarkerTypeIndex(tagName, attributesArray) {
    if (!this._markerTypeCache) { this._markerTypeCache = {}; }
    const key = `${tagName}-${attributesArray.join('-')}`;

    let index = this._markerTypeCache[key];
    if (index === undefined) {
      let markerType = [tagName];
      if (attributesArray.length) { markerType.push(attributesArray); }
      this.markerTypes.push(markerType);

      index =  this.markerTypes.length - 1;
      this._markerTypeCache[key] = index;
    }

    return index;
  }
};

/**
 * Render from post -> mobiledoc
 */
var MobiledocRenderer = {
  /**
   * @param {Post}
   * @return {Mobiledoc}
   */
  render(post) {
    let opcodes = [];
    visit(visitor, post, opcodes);
    let compiler = Object.create(postOpcodeCompiler);
    compile(compiler, opcodes);
    return compiler.result;
  }
};

/*
 * Parses from mobiledoc -> post
 */
class MobiledocParser {
  constructor(builder) {
    this.builder = builder;
  }

  /**
   * @param {Mobiledoc}
   * @return {Post}
   */
  parse({sections: sectionData}) {
    try {
      const markerTypes = sectionData[0];
      const sections    = sectionData[1];

      const post = this.builder.createPost();

      this.markups = [];
      this.markerTypes = this.parseMarkerTypes(markerTypes);
      this.parseSections(sections, post);

      return post;
    } catch (e) {
      mobiledocAssert(`Unable to parse mobiledoc: ${e.message}`, false);
    }
  }

  parseMarkerTypes(markerTypes) {
    return markerTypes.map((markerType) => this.parseMarkerType(markerType));
  }

  parseMarkerType([tagName, attributesArray]) {
    const attributesObject = kvArrayToObject(attributesArray || []);
    return this.builder.createMarkup(tagName, attributesObject);
  }

  parseSections(sections, post) {
    sections.forEach((section) => this.parseSection(section, post));
  }

  parseSection(section, post) {
    let [type] = section;
    switch(type) {
      case MOBILEDOC_MARKUP_SECTION_TYPE:
        this.parseMarkupSection(section, post);
        break;
      case MOBILEDOC_IMAGE_SECTION_TYPE:
        this.parseImageSection(section, post);
        break;
      case MOBILEDOC_CARD_SECTION_TYPE:
        this.parseCardSection(section, post);
        break;
      case MOBILEDOC_LIST_SECTION_TYPE:
        this.parseListSection(section, post);
        break;
      default:
        mobiledocAssert(`Unexpected section type ${type}`, false);
    }
  }

  parseCardSection([, name, payload], post) {
    const section = this.builder.createCardSection(name, payload);
    post.sections.append(section);
  }

  parseImageSection([, src], post) {
    const section = this.builder.createImageSection(src);
    post.sections.append(section);
  }

  parseMarkupSection([, tagName, markers], post) {
    const section = this.builder.createMarkupSection(tagName.toLowerCase() === 'pull-quote' ? 'aside' : tagName);
    post.sections.append(section);
    this.parseMarkers(markers, section);
    // Strip blank markers after they have been created. This ensures any
    // markup they include has been correctly populated.
    filter(section.markers, m => m.isBlank).forEach(m => {
      section.markers.remove(m);
    });
  }

  parseListSection([, tagName, items], post) {
    const section = this.builder.createListSection(tagName);
    post.sections.append(section);
    this.parseListItems(items, section);
  }

  parseListItems(items, section) {
    items.forEach(i => this.parseListItem(i, section));
  }

  parseListItem(markers, section) {
    const item = this.builder.createListItem();
    this.parseMarkers(markers, item);
    section.items.append(item);
  }

  parseMarkers(markers, parent) {
    markers.forEach(m => this.parseMarker(m, parent));
  }

  parseMarker([markerTypeIndexes, closeCount, value], parent) {
    markerTypeIndexes.forEach(index => {
      this.markups.push(this.markerTypes[index]);
    });
    const marker = this.builder.createMarker(value, this.markups.slice());
    parent.markers.append(marker);
    this.markups = this.markups.slice(0, this.markups.length-closeCount);
  }
}

const MOBILEDOC_VERSION$1 = '0.3.0';
const MOBILEDOC_MARKUP_SECTION_TYPE$1 = 1;
const MOBILEDOC_IMAGE_SECTION_TYPE$1 = 2;
const MOBILEDOC_LIST_SECTION_TYPE$1 = 3;
const MOBILEDOC_CARD_SECTION_TYPE$1 = 10;

const MOBILEDOC_MARKUP_MARKER_TYPE = 0;
const MOBILEDOC_ATOM_MARKER_TYPE = 1;

const visitor$1 = {
  [POST_TYPE](node, opcodes) {
    opcodes.push(['openPost']);
    visitArray(visitor$1, node.sections, opcodes);
  },
  [MARKUP_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openMarkupSection', node.tagName]);
    visitArray(visitor$1, node.markers, opcodes);
  },
  [LIST_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openListSection', node.tagName]);
    visitArray(visitor$1, node.items, opcodes);
  },
  [LIST_ITEM_TYPE](node, opcodes) {
    opcodes.push(['openListItem']);
    visitArray(visitor$1, node.markers, opcodes);
  },
  [IMAGE_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openImageSection', node.src]);
  },
  [CARD_TYPE](node, opcodes) {
    opcodes.push(['openCardSection', node.name, node.payload]);
  },
  [MARKER_TYPE](node, opcodes) {
    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);
    visitArray(visitor$1, node.openedMarkups, opcodes);
  },
  [MARKUP_TYPE](node, opcodes) {
    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);
  },
  [ATOM_TYPE](node, opcodes) {
    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload]);
    visitArray(visitor$1, node.openedMarkups, opcodes);
  }
};

const postOpcodeCompiler$1 = {
  openMarker(closeCount, value) {
    this.markupMarkerIds = [];
    this.markers.push([
      MOBILEDOC_MARKUP_MARKER_TYPE,
      this.markupMarkerIds,
      closeCount,
      value || ''
    ]);
  },
  openMarkupSection(tagName) {
    this.markers = [];
    this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$1, tagName, this.markers]);
  },
  openListSection(tagName) {
    this.items = [];
    this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$1, tagName, this.items]);
  },
  openListItem() {
    this.markers = [];
    this.items.push(this.markers);
  },
  openImageSection(url) {
    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE$1, url]);
  },
  openCardSection(name, payload) {
    const index = this._addCardTypeIndex(name, payload);
    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE$1, index]);
  },
  openAtom(closeCount, name, value, payload) {
    const index = this._addAtomTypeIndex(name, value, payload);
    this.markupMarkerIds = [];
    this.markers.push([
      MOBILEDOC_ATOM_MARKER_TYPE,
      this.markupMarkerIds,
      closeCount,
      index
    ]);
  },
  openPost() {
    this.atomTypes = [];
    this.cardTypes = [];
    this.markerTypes = [];
    this.sections = [];
    this.result = {
      version: MOBILEDOC_VERSION$1,
      atoms: this.atomTypes,
      cards: this.cardTypes,
      markups: this.markerTypes,
      sections: this.sections
    };
  },
  openMarkup(tagName, attributes) {
    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);
    this.markupMarkerIds.push(index);
  },
  _addCardTypeIndex(cardName, payload) {
    let cardType = [cardName, payload];
    this.cardTypes.push(cardType);
    return this.cardTypes.length - 1;
  },
  _addAtomTypeIndex(atomName, atomValue, payload) {
    let atomType = [atomName, atomValue, payload];
    this.atomTypes.push(atomType);
    return this.atomTypes.length - 1;
  },
  _findOrAddMarkerTypeIndex(tagName, attributesArray) {
    if (!this._markerTypeCache) { this._markerTypeCache = {}; }
    const key = `${tagName}-${attributesArray.join('-')}`;

    let index = this._markerTypeCache[key];
    if (index === undefined) {
      let markerType = [tagName];
      if (attributesArray.length) { markerType.push(attributesArray); }
      this.markerTypes.push(markerType);

      index =  this.markerTypes.length - 1;
      this._markerTypeCache[key] = index;
    }

    return index;
  }
};

/**
 * Render from post -> mobiledoc
 */
var MobiledocRenderer$1 = {
  /**
   * @param {Post}
   * @return {Mobiledoc}
   */
  render(post) {
    let opcodes = [];
    visit(visitor$1, post, opcodes);
    let compiler = Object.create(postOpcodeCompiler$1);
    compile(compiler, opcodes);
    return compiler.result;
  }
};

/*
 * Parses from mobiledoc -> post
 */
class MobiledocParser$1 {
  constructor(builder) {
    this.builder = builder;
  }

  /**
   * @param {Mobiledoc}
   * @return {Post}
   */
  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }) {
    try {
      const post = this.builder.createPost();

      this.markups = [];
      this.markerTypes = this.parseMarkerTypes(markerTypes);
      this.cardTypes = this.parseCardTypes(cardTypes);
      this.atomTypes = this.parseAtomTypes(atomTypes);
      this.parseSections(sections, post);

      return post;
    } catch (e) {
      mobiledocAssert(`Unable to parse mobiledoc: ${e.message}`, false);
    }
  }

  parseMarkerTypes(markerTypes) {
    return markerTypes.map((markerType) => this.parseMarkerType(markerType));
  }

  parseMarkerType([tagName, attributesArray]) {
    const attributesObject = kvArrayToObject(attributesArray || []);
    return this.builder.createMarkup(tagName, attributesObject);
  }

  parseCardTypes(cardTypes) {
    return cardTypes.map((cardType) => this.parseCardType(cardType));
  }

  parseCardType([cardName, cardPayload]) {
    return [cardName, cardPayload];
  }

  parseAtomTypes(atomTypes) {
    return atomTypes.map((atomType) => this.parseAtomType(atomType));
  }

  parseAtomType([atomName, atomValue, atomPayload]) {
    return [atomName, atomValue, atomPayload];
  }

  parseSections(sections, post) {
    sections.forEach((section) => this.parseSection(section, post));
  }

  parseSection(section, post) {
    let [type] = section;
    switch(type) {
      case MOBILEDOC_MARKUP_SECTION_TYPE$1:
        this.parseMarkupSection(section, post);
        break;
      case MOBILEDOC_IMAGE_SECTION_TYPE$1:
        this.parseImageSection(section, post);
        break;
      case MOBILEDOC_CARD_SECTION_TYPE$1:
        this.parseCardSection(section, post);
        break;
      case MOBILEDOC_LIST_SECTION_TYPE$1:
        this.parseListSection(section, post);
        break;
      default:
        mobiledocAssert('Unexpected section type ${type}', false);
    }
  }

  getAtomTypeFromIndex(index) {
    const atomType = this.atomTypes[index];
    mobiledocAssert(`No atom definition found at index ${index}`, !!atomType);
    return atomType;
  }

  getCardTypeFromIndex(index) {
    const cardType = this.cardTypes[index];
    mobiledocAssert(`No card definition found at index ${index}`, !!cardType);
    return cardType;
  }

  parseCardSection([, cardIndex], post) {
    const [name, payload] = this.getCardTypeFromIndex(cardIndex);
    const section = this.builder.createCardSection(name, payload);
    post.sections.append(section);
  }

  parseImageSection([, src], post) {
    const section = this.builder.createImageSection(src);
    post.sections.append(section);
  }

  parseMarkupSection([, tagName, markers], post) {
    const section = this.builder.createMarkupSection(tagName.toLowerCase() === 'pull-quote' ? 'aside' : tagName);
    post.sections.append(section);
    this.parseMarkers(markers, section);
    // Strip blank markers after they have been created. This ensures any
    // markup they include has been correctly populated.
    filter(section.markers, m => m.isBlank).forEach(m => {
      section.markers.remove(m);
    });
  }

  parseListSection([, tagName, items], post) {
    const section = this.builder.createListSection(tagName);
    post.sections.append(section);
    this.parseListItems(items, section);
  }

  parseListItems(items, section) {
    items.forEach(i => this.parseListItem(i, section));
  }

  parseListItem(markers, section) {
    const item = this.builder.createListItem();
    this.parseMarkers(markers, item);
    section.items.append(item);
  }

  parseMarkers(markers, parent) {
    markers.forEach(m => this.parseMarker(m, parent));
  }

  parseMarker([type, markerTypeIndexes, closeCount, value], parent) {
    markerTypeIndexes.forEach(index => {
      this.markups.push(this.markerTypes[index]);
    });

    const marker = this.buildMarkerType(type, value);
    parent.markers.append(marker);

    this.markups = this.markups.slice(0, this.markups.length-closeCount);
  }

  buildMarkerType(type, value) {
    switch (type) {
      case MOBILEDOC_MARKUP_MARKER_TYPE:
        return this.builder.createMarker(value, this.markups.slice());
      case MOBILEDOC_ATOM_MARKER_TYPE: {
        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value);
        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice());
      }
      default:
        mobiledocAssert(`Unexpected marker type ${type}`, false);
    }
  }
}

const MOBILEDOC_VERSION$2 = '0.3.1';
const MOBILEDOC_MARKUP_SECTION_TYPE$2 = 1;
const MOBILEDOC_IMAGE_SECTION_TYPE$2 = 2;
const MOBILEDOC_LIST_SECTION_TYPE$2 = 3;
const MOBILEDOC_CARD_SECTION_TYPE$2 = 10;

const MOBILEDOC_MARKUP_MARKER_TYPE$1 = 0;
const MOBILEDOC_ATOM_MARKER_TYPE$1 = 1;

const visitor$2 = {
  [POST_TYPE](node, opcodes) {
    opcodes.push(['openPost']);
    visitArray(visitor$2, node.sections, opcodes);
  },
  [MARKUP_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openMarkupSection', node.tagName]);
    visitArray(visitor$2, node.markers, opcodes);
  },
  [LIST_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openListSection', node.tagName]);
    visitArray(visitor$2, node.items, opcodes);
  },
  [LIST_ITEM_TYPE](node, opcodes) {
    opcodes.push(['openListItem']);
    visitArray(visitor$2, node.markers, opcodes);
  },
  [IMAGE_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openImageSection', node.src]);
  },
  [CARD_TYPE](node, opcodes) {
    opcodes.push(['openCardSection', node.name, node.payload]);
  },
  [MARKER_TYPE](node, opcodes) {
    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);
    visitArray(visitor$2, node.openedMarkups, opcodes);
  },
  [MARKUP_TYPE](node, opcodes) {
    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);
  },
  [ATOM_TYPE](node, opcodes) {
    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload]);
    visitArray(visitor$2, node.openedMarkups, opcodes);
  }
};

const postOpcodeCompiler$2 = {
  openMarker(closeCount, value) {
    this.markupMarkerIds = [];
    this.markers.push([
      MOBILEDOC_MARKUP_MARKER_TYPE$1,
      this.markupMarkerIds,
      closeCount,
      value || ''
    ]);
  },
  openMarkupSection(tagName) {
    this.markers = [];
    this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$2, tagName, this.markers]);
  },
  openListSection(tagName) {
    this.items = [];
    this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$2, tagName, this.items]);
  },
  openListItem() {
    this.markers = [];
    this.items.push(this.markers);
  },
  openImageSection(url) {
    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE$2, url]);
  },
  openCardSection(name, payload) {
    const index = this._addCardTypeIndex(name, payload);
    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE$2, index]);
  },
  openAtom(closeCount, name, value, payload) {
    const index = this._addAtomTypeIndex(name, value, payload);
    this.markupMarkerIds = [];
    this.markers.push([
      MOBILEDOC_ATOM_MARKER_TYPE$1,
      this.markupMarkerIds,
      closeCount,
      index
    ]);
  },
  openPost() {
    this.atomTypes = [];
    this.cardTypes = [];
    this.markerTypes = [];
    this.sections = [];
    this.result = {
      version: MOBILEDOC_VERSION$2,
      atoms: this.atomTypes,
      cards: this.cardTypes,
      markups: this.markerTypes,
      sections: this.sections
    };
  },
  openMarkup(tagName, attributes) {
    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);
    this.markupMarkerIds.push(index);
  },
  _addCardTypeIndex(cardName, payload) {
    let cardType = [cardName, payload];
    this.cardTypes.push(cardType);
    return this.cardTypes.length - 1;
  },
  _addAtomTypeIndex(atomName, atomValue, payload) {
    let atomType = [atomName, atomValue, payload];
    this.atomTypes.push(atomType);
    return this.atomTypes.length - 1;
  },
  _findOrAddMarkerTypeIndex(tagName, attributesArray) {
    if (!this._markerTypeCache) { this._markerTypeCache = {}; }
    const key = `${tagName}-${attributesArray.join('-')}`;

    let index = this._markerTypeCache[key];
    if (index === undefined) {
      let markerType = [tagName];
      if (attributesArray.length) { markerType.push(attributesArray); }
      this.markerTypes.push(markerType);

      index =  this.markerTypes.length - 1;
      this._markerTypeCache[key] = index;
    }

    return index;
  }
};

/**
 * Render from post -> mobiledoc
 */
var MobiledocRenderer$2 = {
  /**
   * @param {Post}
   * @return {Mobiledoc}
   */
  render(post) {
    let opcodes = [];
    visit(visitor$2, post, opcodes);
    let compiler = Object.create(postOpcodeCompiler$2);
    compile(compiler, opcodes);
    return compiler.result;
  }
};

/*
 * Parses from mobiledoc -> post
 */
class MobiledocParser$2 {
  constructor(builder) {
    this.builder = builder;
  }

  /**
   * @param {Mobiledoc}
   * @return {Post}
   */
  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }) {
    try {
      const post = this.builder.createPost();

      this.markups = [];
      this.markerTypes = this.parseMarkerTypes(markerTypes);
      this.cardTypes = this.parseCardTypes(cardTypes);
      this.atomTypes = this.parseAtomTypes(atomTypes);
      this.parseSections(sections, post);

      return post;
    } catch (e) {
      mobiledocAssert(`Unable to parse mobiledoc: ${e.message}`, false);
    }
  }

  parseMarkerTypes(markerTypes) {
    return markerTypes.map((markerType) => this.parseMarkerType(markerType));
  }

  parseMarkerType([tagName, attributesArray]) {
    const attributesObject = kvArrayToObject(attributesArray || []);
    return this.builder.createMarkup(tagName, attributesObject);
  }

  parseCardTypes(cardTypes) {
    return cardTypes.map((cardType) => this.parseCardType(cardType));
  }

  parseCardType([cardName, cardPayload]) {
    return [cardName, cardPayload];
  }

  parseAtomTypes(atomTypes) {
    return atomTypes.map((atomType) => this.parseAtomType(atomType));
  }

  parseAtomType([atomName, atomValue, atomPayload]) {
    return [atomName, atomValue, atomPayload];
  }

  parseSections(sections, post) {
    sections.forEach((section) => this.parseSection(section, post));
  }

  parseSection(section, post) {
    let [type] = section;
    switch(type) {
      case MOBILEDOC_MARKUP_SECTION_TYPE$2:
        this.parseMarkupSection(section, post);
        break;
      case MOBILEDOC_IMAGE_SECTION_TYPE$2:
        this.parseImageSection(section, post);
        break;
      case MOBILEDOC_CARD_SECTION_TYPE$2:
        this.parseCardSection(section, post);
        break;
      case MOBILEDOC_LIST_SECTION_TYPE$2:
        this.parseListSection(section, post);
        break;
      default:
        mobiledocAssert('Unexpected section type ${type}', false);
    }
  }

  getAtomTypeFromIndex(index) {
    const atomType = this.atomTypes[index];
    mobiledocAssert(`No atom definition found at index ${index}`, !!atomType);
    return atomType;
  }

  getCardTypeFromIndex(index) {
    const cardType = this.cardTypes[index];
    mobiledocAssert(`No card definition found at index ${index}`, !!cardType);
    return cardType;
  }

  parseCardSection([, cardIndex], post) {
    const [name, payload] = this.getCardTypeFromIndex(cardIndex);
    const section = this.builder.createCardSection(name, payload);
    post.sections.append(section);
  }

  parseImageSection([, src], post) {
    const section = this.builder.createImageSection(src);
    post.sections.append(section);
  }

  parseMarkupSection([, tagName, markers], post) {
    const section = this.builder.createMarkupSection(tagName);
    post.sections.append(section);
    this.parseMarkers(markers, section);
    // Strip blank markers after they have been created. This ensures any
    // markup they include has been correctly populated.
    filter(section.markers, m => m.isBlank).forEach(m => {
      section.markers.remove(m);
    });
  }

  parseListSection([, tagName, items], post) {
    const section = this.builder.createListSection(tagName);
    post.sections.append(section);
    this.parseListItems(items, section);
  }

  parseListItems(items, section) {
    items.forEach(i => this.parseListItem(i, section));
  }

  parseListItem(markers, section) {
    const item = this.builder.createListItem();
    this.parseMarkers(markers, item);
    section.items.append(item);
  }

  parseMarkers(markers, parent) {
    markers.forEach(m => this.parseMarker(m, parent));
  }

  parseMarker([type, markerTypeIndexes, closeCount, value], parent) {
    markerTypeIndexes.forEach(index => {
      this.markups.push(this.markerTypes[index]);
    });

    const marker = this.buildMarkerType(type, value);
    parent.markers.append(marker);

    this.markups = this.markups.slice(0, this.markups.length-closeCount);
  }

  buildMarkerType(type, value) {
    switch (type) {
      case MOBILEDOC_MARKUP_MARKER_TYPE$1:
        return this.builder.createMarker(value, this.markups.slice());
      case MOBILEDOC_ATOM_MARKER_TYPE$1: {
        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value);
        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice());
      }
      default:
        mobiledocAssert(`Unexpected marker type ${type}`, false);
    }
  }
}

const MOBILEDOC_VERSION$3 = '0.3.2';
const MOBILEDOC_MARKUP_SECTION_TYPE$3 = 1;
const MOBILEDOC_IMAGE_SECTION_TYPE$3 = 2;
const MOBILEDOC_LIST_SECTION_TYPE$3 = 3;
const MOBILEDOC_CARD_SECTION_TYPE$3 = 10;

const MOBILEDOC_MARKUP_MARKER_TYPE$2 = 0;
const MOBILEDOC_ATOM_MARKER_TYPE$2 = 1;

const visitor$3 = {
  [POST_TYPE](node, opcodes) {
    opcodes.push(['openPost']);
    visitArray(visitor$3, node.sections, opcodes);
  },
  [MARKUP_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openMarkupSection', node.tagName, objectToSortedKVArray(node.attributes)]);
    visitArray(visitor$3, node.markers, opcodes);
  },
  [LIST_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openListSection', node.tagName, objectToSortedKVArray(node.attributes)]);
    visitArray(visitor$3, node.items, opcodes);
  },
  [LIST_ITEM_TYPE](node, opcodes) {
    opcodes.push(['openListItem']);
    visitArray(visitor$3, node.markers, opcodes);
  },
  [IMAGE_SECTION_TYPE](node, opcodes) {
    opcodes.push(['openImageSection', node.src]);
  },
  [CARD_TYPE](node, opcodes) {
    opcodes.push(['openCardSection', node.name, node.payload]);
  },
  [MARKER_TYPE](node, opcodes) {
    opcodes.push(['openMarker', node.closedMarkups.length, node.value]);
    visitArray(visitor$3, node.openedMarkups, opcodes);
  },
  [MARKUP_TYPE](node, opcodes) {
    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)]);
  },
  [ATOM_TYPE](node, opcodes) {
    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload]);
    visitArray(visitor$3, node.openedMarkups, opcodes);
  }
};

const postOpcodeCompiler$3 = {
  openMarker(closeCount, value) {
    this.markupMarkerIds = [];
    this.markers.push([
      MOBILEDOC_MARKUP_MARKER_TYPE$2,
      this.markupMarkerIds,
      closeCount,
      value || ''
    ]);
  },
  openMarkupSection(tagName, attributes) {
    this.markers = [];
    if (attributes && attributes.length !== 0) {
      this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$3, tagName, this.markers, attributes]);
    } else {
      this.sections.push([MOBILEDOC_MARKUP_SECTION_TYPE$3, tagName, this.markers]);
    }
  },
  openListSection(tagName, attributes) {
    this.items = [];
    if (attributes && attributes.length !== 0) {
      this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$3, tagName, this.items, attributes]);
    } else {
      this.sections.push([MOBILEDOC_LIST_SECTION_TYPE$3, tagName, this.items]);
    }
  },
  openListItem() {
    this.markers = [];
    this.items.push(this.markers);
  },
  openImageSection(url) {
    this.sections.push([MOBILEDOC_IMAGE_SECTION_TYPE$3, url]);
  },
  openCardSection(name, payload) {
    const index = this._addCardTypeIndex(name, payload);
    this.sections.push([MOBILEDOC_CARD_SECTION_TYPE$3, index]);
  },
  openAtom(closeCount, name, value, payload) {
    const index = this._addAtomTypeIndex(name, value, payload);
    this.markupMarkerIds = [];
    this.markers.push([
      MOBILEDOC_ATOM_MARKER_TYPE$2,
      this.markupMarkerIds,
      closeCount,
      index
    ]);
  },
  openPost() {
    this.atomTypes = [];
    this.cardTypes = [];
    this.markerTypes = [];
    this.sections = [];
    this.result = {
      version: MOBILEDOC_VERSION$3,
      atoms: this.atomTypes,
      cards: this.cardTypes,
      markups: this.markerTypes,
      sections: this.sections
    };
  },
  openMarkup(tagName, attributes) {
    const index = this._findOrAddMarkerTypeIndex(tagName, attributes);
    this.markupMarkerIds.push(index);
  },
  _addCardTypeIndex(cardName, payload) {
    let cardType = [cardName, payload];
    this.cardTypes.push(cardType);
    return this.cardTypes.length - 1;
  },
  _addAtomTypeIndex(atomName, atomValue, payload) {
    let atomType = [atomName, atomValue, payload];
    this.atomTypes.push(atomType);
    return this.atomTypes.length - 1;
  },
  _findOrAddMarkerTypeIndex(tagName, attributesArray) {
    if (!this._markerTypeCache) { this._markerTypeCache = {}; }
    const key = `${tagName}-${attributesArray.join('-')}`;

    let index = this._markerTypeCache[key];
    if (index === undefined) {
      let markerType = [tagName];
      if (attributesArray.length) { markerType.push(attributesArray); }
      this.markerTypes.push(markerType);

      index =  this.markerTypes.length - 1;
      this._markerTypeCache[key] = index;
    }

    return index;
  }
};

/**
 * Render from post -> mobiledoc
 */
var MobiledocRenderer$3 = {
  /**
   * @param {Post}
   * @return {Mobiledoc}
   */
  render(post) {
    let opcodes = [];
    visit(visitor$3, post, opcodes);
    let compiler = Object.create(postOpcodeCompiler$3);
    compile(compiler, opcodes);
    return compiler.result;
  }
};

function entries(obj) {
  const ownProps = Object.keys(obj);
  let i = ownProps.length;
  const resArray = new Array(i);

  while (i--) {
    resArray[i] = [ownProps[i], obj[ownProps[i]]];
  }

  return resArray;
}

/*
 * Parses from mobiledoc -> post
 */
class MobiledocParser$3 {
  constructor(builder) {
    this.builder = builder;
  }

  /**
   * @param {Mobiledoc}
   * @return {Post}
   */
  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }) {
    try {
      const post = this.builder.createPost();

      this.markups = [];
      this.markerTypes = this.parseMarkerTypes(markerTypes);
      this.cardTypes = this.parseCardTypes(cardTypes);
      this.atomTypes = this.parseAtomTypes(atomTypes);
      this.parseSections(sections, post);

      return post;
    } catch (e) {
      mobiledocAssert(`Unable to parse mobiledoc: ${e.message}`, false);
    }
  }

  parseMarkerTypes(markerTypes) {
    return markerTypes.map((markerType) => this.parseMarkerType(markerType));
  }

  parseMarkerType([tagName, attributesArray]) {
    const attributesObject = kvArrayToObject(attributesArray || []);
    return this.builder.createMarkup(tagName, attributesObject);
  }

  parseCardTypes(cardTypes) {
    return cardTypes.map((cardType) => this.parseCardType(cardType));
  }

  parseCardType([cardName, cardPayload]) {
    return [cardName, cardPayload];
  }

  parseAtomTypes(atomTypes) {
    return atomTypes.map((atomType) => this.parseAtomType(atomType));
  }

  parseAtomType([atomName, atomValue, atomPayload]) {
    return [atomName, atomValue, atomPayload];
  }

  parseSections(sections, post) {
    sections.forEach((section) => this.parseSection(section, post));
  }

  parseSection(section, post) {
    let [type] = section;
    switch(type) {
      case MOBILEDOC_MARKUP_SECTION_TYPE$3:
        this.parseMarkupSection(section, post);
        break;
      case MOBILEDOC_IMAGE_SECTION_TYPE$3:
        this.parseImageSection(section, post);
        break;
      case MOBILEDOC_CARD_SECTION_TYPE$3:
        this.parseCardSection(section, post);
        break;
      case MOBILEDOC_LIST_SECTION_TYPE$3:
        this.parseListSection(section, post);
        break;
      default:
        mobiledocAssert('Unexpected section type ${type}', false);
    }
  }

  getAtomTypeFromIndex(index) {
    const atomType = this.atomTypes[index];
    mobiledocAssert(`No atom definition found at index ${index}`, !!atomType);
    return atomType;
  }

  getCardTypeFromIndex(index) {
    const cardType = this.cardTypes[index];
    mobiledocAssert(`No card definition found at index ${index}`, !!cardType);
    return cardType;
  }

  parseCardSection([, cardIndex], post) {
    const [name, payload] = this.getCardTypeFromIndex(cardIndex);
    const section = this.builder.createCardSection(name, payload);
    post.sections.append(section);
  }

  parseImageSection([, src], post) {
    const section = this.builder.createImageSection(src);
    post.sections.append(section);
  }

  parseMarkupSection([, tagName, markers, attributesArray], post) {
    const section = this.builder.createMarkupSection(tagName);
    post.sections.append(section);
    if (attributesArray) {
      entries(kvArrayToObject(attributesArray)).forEach(([key, value]) => {
        section.setAttribute(key, value);
      });
    }
    this.parseMarkers(markers, section);
    // Strip blank markers after they have been created. This ensures any
    // markup they include has been correctly populated.
    filter(section.markers, m => m.isBlank).forEach(m => {
      section.markers.remove(m);
    });
  }

  parseListSection([, tagName, items, attributesArray], post) {
    const section = this.builder.createListSection(tagName);
    post.sections.append(section);
    if (attributesArray) {
      entries(kvArrayToObject(attributesArray)).forEach(([key, value]) => {
        section.setAttribute(key, value);
      });
    }
    this.parseListItems(items, section);
  }

  parseListItems(items, section) {
    items.forEach(i => this.parseListItem(i, section));
  }

  parseListItem(markers, section) {
    const item = this.builder.createListItem();
    this.parseMarkers(markers, item);
    section.items.append(item);
  }

  parseMarkers(markers, parent) {
    markers.forEach(m => this.parseMarker(m, parent));
  }

  parseMarker([type, markerTypeIndexes, closeCount, value], parent) {
    markerTypeIndexes.forEach(index => {
      this.markups.push(this.markerTypes[index]);
    });

    const marker = this.buildMarkerType(type, value);
    parent.markers.append(marker);

    this.markups = this.markups.slice(0, this.markups.length-closeCount);
  }

  buildMarkerType(type, value) {
    switch (type) {
      case MOBILEDOC_MARKUP_MARKER_TYPE$2:
        return this.builder.createMarker(value, this.markups.slice());
      case MOBILEDOC_ATOM_MARKER_TYPE$2: {
        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value);
        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice());
      }
      default:
        mobiledocAssert(`Unexpected marker type ${type}`, false);
    }
  }
}

function parseVersion(mobiledoc) {
  return mobiledoc.version;
}

var mobiledocParsers = {
  parse(builder, mobiledoc) {
    let version = parseVersion(mobiledoc);
    switch (version) {
      case MOBILEDOC_VERSION:
        return new MobiledocParser(builder).parse(mobiledoc);
      case MOBILEDOC_VERSION$1:
        return new MobiledocParser$1(builder).parse(mobiledoc);
      case MOBILEDOC_VERSION$2:
        return new MobiledocParser$2(builder).parse(mobiledoc);
      case MOBILEDOC_VERSION$3:
        return new MobiledocParser$3(builder).parse(mobiledoc);
      default:
        mobiledocAssert(`Unknown version of mobiledoc parser requested: ${version}`,
               false);
    }
  }
};

class CardNode {
  constructor(editor, card, section, element, options) {
    this.editor  = editor;
    this.card    = card;
    this.section = section;
    this.element = element;
    this.options = options;

    this.mode = null;

    this._teardownCallback = null;
    this._rendered         = null;
  }

  render(mode) {
    if (this.mode === mode) { return; }

    this.teardown();

    this.mode = mode;

    let method = mode === 'display' ? 'render' : 'edit';
    method = this.card[method];

    mobiledocAssert(`Card is missing "${method}" (tried to render mode: "${mode}")`,
           !!method);
    let rendered = method({
      env: this.env,
      options: this.options,
      payload: this.section.payload
    });

    this._validateAndAppendRenderResult(rendered);
  }

  teardown() {
    if (this._teardownCallback) {
      this._teardownCallback();
      this._teardownCallback = null;
    }
    if (this._rendered) {
      this.element.removeChild(this._rendered);
      this._rendered = null;
    }
  }

  didRender() {
    if (this._didRenderCallback) {
      this._didRenderCallback();
    }
  }

  get env() {
    return {
      name: this.card.name,
      isInEditor: true,
      onTeardown: (callback) => this._teardownCallback = callback,
      didRender: (callback) => this._didRenderCallback = callback,
      edit: () => this.edit(),
      save: (payload, transition=true) => {
        this.section.payload = payload;

        this.editor._postDidChange();
        if (transition) {
          this.display();
        }
      },
      cancel: () => this.display(),
      remove: () => this.remove(),
      postModel: this.section
    };
  }

  display() {
    this.render('display');
  }

  edit() {
    this.render('edit');
  }

  remove() {
    this.editor.run(postEditor => postEditor.removeSection(this.section));
  }

  _validateAndAppendRenderResult(rendered) {
    if (!rendered) {
      return;
    }

    let { card: { name } } = this;
    mobiledocAssert(
      `Card "${name}" must render dom (render value was: "${rendered}")`,
      !!rendered.nodeType
    );
    this.element.appendChild(rendered);
    this._rendered = rendered;
    this.didRender();
  }
}

class AtomNode {
  constructor(editor, atom, model, element, atomOptions) {
    this.editor = editor;
    this.atom = atom;
    this.model = model;
    this.atomOptions = atomOptions;
    this.element = element;

    this._teardownCallback = null;
    this._rendered         = null;
  }

  render() {
    if (!this._rendered) {
      let {atomOptions: options, env, model: { value, payload } } = this;
      // cache initial render
      this._rendered = this.atom.render({options, env, value, payload});
    }

    this._validateAndAppendRenderResult(this._rendered);
  }

  get env() {
    return {
      name: this.atom.name,
      onTeardown: (callback) => this._teardownCallback = callback,
      save: (value, payload={}) => {
        this.model.value = value;
        this.model.payload = payload;

        this.editor._postDidChange();
        this.teardown();
        this.render();
      }
    };
  }

  teardown() {
    if (this._teardownCallback) {
      this._teardownCallback();
      this._teardownCallback = null;
    }
    if (this._rendered) {
      this.element.removeChild(this._rendered);
      this._rendered = null;
    }
  }

  _validateAndAppendRenderResult(rendered) {
    if (!rendered) {
      return;
    }

    let { atom: { name } } = this;
    mobiledocAssert(
      `Atom "${name}" must return a DOM node (returned value was: "${rendered}")`,
      !!rendered.nodeType
    );
    this.element.appendChild(rendered);
  }
}

class Set {
  constructor(items=[]) {
    this.items = [];
    items.forEach(i => this.add(i));
  }

  add(item) {
    if (!this.has(item)) {
      this.items.push(item);
    }
  }

  get length() {
    return this.items.length;
  }

  has(item) {
    return this.items.indexOf(item) !== -1;
  }

  toArray() {
    return this.items;
  }
}

const PARENT_PROP = '__parent';

class LinkedList {
  constructor(options) {
    this.head = null;
    this.tail = null;
    this.length = 0;

    if (options) {
      const {adoptItem, freeItem} = options;
      this._adoptItem = adoptItem;
      this._freeItem = freeItem;
    }
  }
  adoptItem(item) {
    item[PARENT_PROP]= this;
    this.length++;
    if (this._adoptItem) { this._adoptItem(item); }
  }
  freeItem(item) {
    item[PARENT_PROP] = null;
    this.length--;
    if (this._freeItem) { this._freeItem(item); }
  }
  get isEmpty() {
    return this.length === 0;
  }
  prepend(item) {
    this.insertBefore(item, this.head);
  }
  append(item) {
    this.insertBefore(item, null);
  }
  insertAfter(item, prevItem) {
    let nextItem = prevItem ? prevItem.next : this.head;
    this.insertBefore(item, nextItem);
  }
  _ensureItemIsNotAlreadyInList(item){
    mobiledocAssert(
      'Cannot insert an item into a list if it is already in a list',
      !item.next && !item.prev && this.head !== item
    );
  }
  insertBefore(item, nextItem) {
    this._ensureItemIsNotInList(item);
    this.adoptItem(item);

    let insertPos;
    if (nextItem && nextItem.prev) {
      insertPos = 'middle';
    } else if (nextItem) {
      insertPos = 'start';
    } else {
      insertPos = 'end';
    }

    switch (insertPos) {
      case 'start':
        if (this.head) {
          item.next      = this.head;
          this.head.prev = item;
        }
        this.head = item;

        break;
      case 'middle': {
        let prevItem  = nextItem.prev;
        item.next     = nextItem;
        item.prev     = prevItem;
        nextItem.prev = item;
        prevItem.next = item;

        break;
      }
      case 'end': {
        let tail = this.tail;
        item.prev = tail;

        if (tail) {
          tail.next = item;
        } else {
          this.head = item;
        }
        this.tail = item;

        break;
      }
    }
  }
  remove(item) {
    if (!item[PARENT_PROP]) {
      return;
    }
    this._ensureItemIsInThisList(item);
    this.freeItem(item);

    let [prev, next] = [item.prev, item.next];
    item.prev = null;
    item.next = null;

    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }

    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
  }
  forEach(callback) {
    let item = this.head;
    let index = 0;
    while (item) {
      callback(item, index++);
      item = item.next;
    }
  }
  map(callback) {
    let result = [];
    this.forEach(i => result.push(callback(i)));
    return result;
  }
  walk(startItem, endItem, callback) {
    let item = startItem || this.head;
    while (item) {
      callback(item);
      if (item === endItem) {
        break;
      }
      item = item.next;
    }
  }
  readRange(startItem, endItem) {
    let items = [];
    this.walk(startItem, endItem, (item) => {
      items.push(item);
    });
    return items;
  }
  toArray() {
    return this.readRange();
  }
  detect(callback, item=this.head, reverse=false) {
    while (item) {
      if (callback(item)) {
        return item;
      }
      item = reverse ? item.prev : item.next;
    }
  }
  any(callback) {
    return !!this.detect(callback);
  }
  every(callback) {
    let item = this.head;
    while (item) {
      if (!callback(item)) {
        return false;
      }
      item = item.next;
    }
    return true;
  }
  objectAt(targetIndex) {
    let index = -1;
    return this.detect(() => {
      index++;
      return (targetIndex === index);
    });
  }
  splice(targetItem, removalCount, newItems) {
    let item = targetItem;
    let nextItem = item.next;
    let count = 0;
    while (item && count < removalCount) {
      count++;
      nextItem = item.next;
      this.remove(item);
      item = nextItem;
    }
    newItems.forEach((newItem) => {
      this.insertBefore(newItem, nextItem);
    });
  }
  removeBy(conditionFn) {
    let item = this.head;
    while (item) {
      let nextItem = item.next;

      if (conditionFn(item)) {
        this.remove(item);
      }

      item = nextItem;
    }
  }
  _ensureItemIsNotInList(item) {
    mobiledocAssert('Cannot insert an item into a list if it is already in a list',
           !item[PARENT_PROP]);
  }
  _ensureItemIsInThisList(item) {
    mobiledocAssert('Cannot remove item that is in another list',
           item[PARENT_PROP] === this);
  }
}

function unimplementedMethod(methodName, me) {
  mobiledocAssert(`\`${methodName}()\` must be implemented by ${me.constructor.name}`,
         false);
}

class Section extends LinkedItem {
  constructor(type) {
    super();
    mobiledocAssert('Cannot create section without type', !!type);
    this.type = type;
    this.isSection = true;
    this.isMarkerable = false;
    this.isNested = false;
    this.isSection = true;
    this.isLeafSection = true;
  }

  set tagName(val) {
    let normalizedTagName = normalizeTagName(val);
    mobiledocAssert(`Cannot set section tagName to ${val}`,
           this.isValidTagName(normalizedTagName));
    this._tagName = normalizedTagName;
  }

  get tagName() {
    return this._tagName;
  }

  isValidTagName(/* normalizedTagName */) {
    unimplementedMethod('isValidTagName', this);
  }

  get length() {
    return 0;
  }

  get isBlank() {
    unimplementedMethod('isBlank', this);
  }

  clone() {
    unimplementedMethod('clone', this);
  }

  canJoin(/* otherSection */) {
    unimplementedMethod('canJoin', this);
  }

  /**
   * @return {Position} The position at the start of this section
   * @public
   */
  headPosition() {
    return this.toPosition(0);
  }

  /**
   * @return {Position} The position at the end of this section
   * @public
   */
  tailPosition() {
    return this.toPosition(this.length);
  }

  /**
   * @param {Number} offset
   * @return {Position} The position in this section at the given offset
   * @public
   */
  toPosition(offset) {
    mobiledocAssert("Must pass number to `toPosition`", typeof offset === 'number');
    mobiledocAssert("Cannot call `toPosition` with offset > length", offset <= this.length);

    return new Position$1(this, offset);
  }

  /**
   * @return {Range} A range from this section's head to tail positions
   * @public
   */
  toRange() {
    return this.headPosition().toRange(this.tailPosition());
  }

  join() {
    unimplementedMethod('join', this);
  }

  textUntil(/* position */) {
    return '';
  }

  /**
   * Markerable sections should override this method
   */
  splitMarkerAtOffset() {
    let blankEdit = { added: [], removed: [] };
    return blankEdit;
  }

  nextLeafSection() {
    const next = this.next;
    if (next) {
      if (next.items) {
        return next.items.head;
      } else {
        return next;
      }
    } else {
      if (this.isNested) {
        return this.parent.nextLeafSection();
      }
    }
  }

  immediatelyNextMarkerableSection() {
    let next = this.nextLeafSection();
    while (next && !next.isMarkerable) {
      next = next.nextLeafSection();
    }
    return next;
  }

  previousLeafSection() {
    const prev = this.prev;

    if (prev) {
      if (prev.items) {
        return prev.items.tail;
      } else {
        return prev;
      }
    } else {
      if (this.isNested) {
        return this.parent.previousLeafSection();
      }
    }
  }
}

class Markerable extends Section {
  constructor(type, tagName, markers=[]) {
    super(type);
    this.isMarkerable = true;
    this.tagName = tagName;
    this.markers = new LinkedList({
      adoptItem: m => {
        mobiledocAssert(`Can only insert markers and atoms into markerable (was: ${m.type})`,
               m.isMarker || m.isAtom);
        m.section = m.parent = this;
      },
      freeItem: m => m.section = m.parent = null
    });

    markers.forEach(m => this.markers.append(m));
  }

  canJoin(other) {
    return other.isMarkerable &&
      other.type === this.type &&
      other.tagName === this.tagName;
  }

  clone() {
    const newMarkers = this.markers.map(m => m.clone());
    return this.builder.createMarkerableSection(
      this.type, this.tagName, newMarkers);
  }

  get isBlank() {
    if (!this.markers.length) {
      return true;
    }
    return this.markers.every(m => m.isBlank);
  }

  textUntil(position) {
    mobiledocAssert(`Cannot get textUntil for a position not in this section`, position.section === this);
    let {marker, offsetInMarker} = position;
    let text = '';
    let currentMarker = this.markers.head;
    while (currentMarker) {
      if (currentMarker === marker) {
        text += currentMarker.textUntil(offsetInMarker);
        break;
      } else {
        text += currentMarker.text;
        currentMarker = currentMarker.next;
      }
    }
    return text;
  }

  /**
   * @param {Marker}
   * @param {Number} markerOffset The offset relative to the start of the marker
   *
   * @return {Number} The offset relative to the start of this section
   */
  offsetOfMarker(marker, markerOffset=0) {
    mobiledocAssert(`Cannot get offsetOfMarker for marker that is not child of this`,
           marker.section === this);

    // FIXME it is possible, when we get a cursor position before having finished reparsing,
    // for markerOffset to be > marker.length. We shouldn't rely on this functionality.

    let offset = 0;
    let currentMarker = this.markers.head;
    while (currentMarker && currentMarker !== marker.next) {
      let length = currentMarker === marker ? markerOffset :
                                              currentMarker.length;
      offset += length;
      currentMarker = currentMarker.next;
    }

    return offset;
  }

  // puts clones of this.markers into beforeSection and afterSection,
  // all markers before the marker/offset split go in beforeSection, and all
  // after the marker/offset split go in afterSection
  // @return {Array} [beforeSection, afterSection], two new sections
  _redistributeMarkers(beforeSection, afterSection, marker, offset=0) {
    let currentSection = beforeSection;
    forEach(this.markers, m => {
      if (m === marker) {
        const [beforeMarker, ...afterMarkers] = marker.split(offset);
        beforeSection.markers.append(beforeMarker);
        forEach(afterMarkers, _m => afterSection.markers.append(_m));
        currentSection = afterSection;
      } else {
        currentSection.markers.append(m.clone());
      }
    });

    return [beforeSection, afterSection];
  }

  splitAtMarker(/*marker, offset=0*/) {
    mobiledocAssert('splitAtMarker must be implemented by sub-class', false);
  }

  /**
   * Split this section's marker (if any) at the given offset, so that
   * there is now a marker boundary at that offset (useful for later applying
   * a markup to a range)
   * @param {Number} sectionOffset The offset relative to start of this section
   * @return {EditObject} An edit object with 'removed' and 'added' keys with arrays of Markers. The added markers may be blank.
   * After calling `splitMarkerAtOffset(offset)`, there will always be a valid
   * result returned from `markerBeforeOffset(offset)`.
   */
  splitMarkerAtOffset(sectionOffset) {
    mobiledocAssert('Cannot splitMarkerAtOffset when offset is > length',
           sectionOffset <= this.length);
    let markerOffset;
    let len = 0;
    let currentMarker = this.markers.head;
    let edit = {added: [], removed: []};

    if (!currentMarker) {
      let blankMarker = this.builder.createMarker();
      this.markers.prepend(blankMarker);
      edit.added.push(blankMarker);
    } else {
      while (currentMarker) {
        len += currentMarker.length;
        if (len === sectionOffset) {
          // nothing to do, there is a gap at the requested offset
          break;
        } else if (len > sectionOffset) {
          markerOffset = currentMarker.length - (len - sectionOffset);
          let newMarkers = currentMarker.splitAtOffset(markerOffset);
          edit.added.push(...newMarkers);
          edit.removed.push(currentMarker);
          this.markers.splice(currentMarker, 1, newMarkers);
          break;
        } else {
          currentMarker = currentMarker.next;
        }
      }
    }

    return edit;
  }

  splitAtPosition(position) {
    const {marker, offsetInMarker} = position;
    return this.splitAtMarker(marker, offsetInMarker);
  }

  // returns the marker just before this offset.
  // It is an error to call this method with an offset that is in the middle
  // of a marker.
  markerBeforeOffset(sectionOffset) {
    let len = 0;
    let currentMarker = this.markers.head;

    while (currentMarker) {
      len += currentMarker.length;
      if (len === sectionOffset) {
        return currentMarker;
      } else {
        mobiledocAssert('markerBeforeOffset called with sectionOffset not between markers',
               len < sectionOffset);
        currentMarker = currentMarker.next;
      }
    }
  }

  markerPositionAtOffset(offset) {
    let currentOffset = 0;
    let currentMarker;
    let remaining = offset;
    this.markers.detect((marker) => {
      currentOffset = Math.min(remaining, marker.length);
      remaining -= currentOffset;
      if (remaining === 0) {
        currentMarker = marker;
        return true; // break out of detect
      }
    });

    return {marker:currentMarker, offset:currentOffset};
  }

  get text() {
    return reduce(this.markers, (prev, m) => prev + m.value, '');
  }

  get length() {
    return reduce(this.markers, (prev, m) => prev + m.length, 0);
  }

  /**
   * @return {Array} New markers that match the boundaries of the
   * range. Does not change the existing markers in this section.
   */
  markersFor(headOffset, tailOffset) {
    const range = {head: {section:this, offset:headOffset},
                   tail: {section:this, offset:tailOffset}};

    let markers = [];
    this._markersInRange(range, (marker, {markerHead, markerTail, isContained}) => {
      const cloned = marker.clone();
      if (!isContained) {
        // cannot do marker.value.slice if the marker is an atom -- this breaks the atom's "atomic" value
        // If a marker is an atom `isContained` should always be true so
        // we shouldn't hit this code path. FIXME add tests
        cloned.value = marker.value.slice(markerHead, markerTail);
      }
      markers.push(cloned);
    });
    return markers;
  }

  markupsInRange(range) {
    const markups = new Set();
    this._markersInRange(range, marker => {
      marker.markups.forEach(m => markups.add(m));
    });
    return markups.toArray();
  }

  // calls the callback with (marker, {markerHead, markerTail, isContained})
  // for each marker that is wholly or partially contained in the range.
  _markersInRange(range, callback) {
    const { head, tail } = range;
    mobiledocAssert('Cannot call #_markersInRange if range expands beyond this section',
           head.section === this && tail.section === this);
    const {offset:headOffset} = head, {offset:tailOffset} = tail;

    let currentHead = 0, currentTail = 0, currentMarker = this.markers.head;

    while (currentMarker) {
      currentTail += currentMarker.length;

      if (currentTail > headOffset && currentHead < tailOffset) {
        let markerHead = Math.max(headOffset - currentHead, 0);
        let markerTail = currentMarker.length -
          Math.max(currentTail - tailOffset, 0);
        let isContained = markerHead === 0 && markerTail === currentMarker.length;

        callback(currentMarker, {markerHead, markerTail, isContained});
      }

      currentHead += currentMarker.length;
      currentMarker = currentMarker.next;

      if (currentHead > tailOffset) { break; }
    }
  }

  // mutates this by appending the other section's (cloned) markers to it
  join(otherSection) {
    let beforeMarker = this.markers.tail;
    let afterMarker = null;

    otherSection.markers.forEach(m => {
      if (!m.isBlank) {
        m = m.clone();
        this.markers.append(m);
        if (!afterMarker) {
          afterMarker = m;
        }
      }
    });

    return { beforeMarker, afterMarker };
  }
}

const VALID_ATTRIBUTES = [
  'data-md-text-align'
];

/*
 * A "mixin" to add section attribute support
 * to markup and list sections.
 */
function attributable(ctx) {
  ctx.attributes = {};

  ctx.hasAttribute = key => key in ctx.attributes;

  ctx.setAttribute = (key, value) => {
    if (!contains(VALID_ATTRIBUTES, key)) {
      throw new Error(`Invalid attribute "${key}" was passed. Constrain attributes to the spec-compliant whitelist.`);
    }
    ctx.attributes[key] = value;
  };
  ctx.removeAttribute = key => {
    delete ctx.attributes[key];
  };
  ctx.getAttribute = key => ctx.attributes[key];
  ctx.eachAttribute = cb => {
    entries(ctx.attributes).forEach(([k,v]) => cb(k,v));
  };
}

// valid values of `tagName` for a MarkupSection
const VALID_MARKUP_SECTION_TAGNAMES = [
  'aside',
  'blockquote',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'p'
].map(normalizeTagName);

// valid element names for a MarkupSection. A MarkupSection with a tagName
// not in this will be rendered as a div with a className matching the
// tagName
const MARKUP_SECTION_ELEMENT_NAMES = [
  'aside',
  'blockquote',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'p'
].map(normalizeTagName);
const DEFAULT_TAG_NAME = VALID_MARKUP_SECTION_TAGNAMES[8];

const MarkupSection = class MarkupSection extends Markerable {
  constructor(tagName=DEFAULT_TAG_NAME, markers=[], attributes={}) {
    super(MARKUP_SECTION_TYPE, tagName, markers);

    attributable(this);
    entries(attributes).forEach(([k,v]) => this.setAttribute(k, v));

    this.isMarkupSection = true;
  }

  isValidTagName(normalizedTagName) {
    return contains(VALID_MARKUP_SECTION_TAGNAMES, normalizedTagName);
  }

  splitAtMarker(marker, offset=0) {
    let [beforeSection, afterSection] = [
      this.builder.createMarkupSection(this.tagName, [], false, this.attributes),
      this.builder.createMarkupSection()
    ];

    return this._redistributeMarkers(beforeSection, afterSection, marker, offset);
  }
};

const CARD_ELEMENT_CLASS_NAME = '__mobiledoc-card';
const NO_BREAK_SPACE = '\u00A0';
const TAB_CHARACTER = '\u2003';
const SPACE = ' ';
const ZWNJ = '\u200c';
const ATOM_CLASS_NAME = '-mobiledoc-kit__atom';
const EDITOR_HAS_NO_CONTENT_CLASS_NAME = '__has-no-content';
const EDITOR_ELEMENT_CLASS_NAME = '__mobiledoc-editor';

function createElementFromMarkup(doc, markup) {
  let element = doc.createElement(markup.tagName);
  Object.keys(markup.attributes).forEach(k => {
    element.setAttribute(k, markup.attributes[k]);
  });
  return element;
}

const TWO_SPACES         = `${SPACE}${SPACE}`;
const SPACE_AND_NO_BREAK = `${SPACE}${NO_BREAK_SPACE}`;
const SPACES_REGEX       = new RegExp(TWO_SPACES, 'g');
const TAB_REGEX          = new RegExp(TAB, 'g');
const endsWithSpace = function(text) {
  return endsWith(text, SPACE);
};
const startsWithSpace = function(text) {
  return startsWith(text, SPACE);
};

// FIXME: This can be done more efficiently with a single pass
// building a correct string based on the original.
function renderHTMLText(marker) {
  let text = marker.value;
  text = text.replace(SPACES_REGEX, SPACE_AND_NO_BREAK)
             .replace(TAB_REGEX,    TAB_CHARACTER);

  // If the first marker has a leading space or the last marker has a
  // trailing space, the browser will collapse the space when we position
  // the cursor.
  // See https://github.com/bustle/mobiledoc-kit/issues/68
  //   and https://github.com/bustle/mobiledoc-kit/issues/75
  if (marker.isMarker && endsWithSpace(text) && !marker.next) {
    text = text.substr(0, text.length - 1) + NO_BREAK_SPACE;
  }
  if (marker.isMarker && startsWithSpace(text) &&
      (!marker.prev || (marker.prev.isMarker && endsWithSpace(marker.prev.value)))) {
    text = NO_BREAK_SPACE + text.substr(1);
  }
  return text;
}

// ascends from element upward, returning the last parent node that is not
// parentElement
function penultimateParentOf(element, parentElement) {
  while (parentElement &&
         element.parentNode !== parentElement &&
         element.parentNode !== document.body // ensure the while loop stops
        ) {
    element = element.parentNode;
  }
  return element;
}

function setSectionAttributesOnElement(section, element) {
  section.eachAttribute((key, value) => {
    element.setAttribute(key, value);
  });
}

function renderMarkupSection(section) {
  let element;
  if (MARKUP_SECTION_ELEMENT_NAMES.indexOf(section.tagName) !== -1) {
    element = document.createElement(section.tagName);
  } else {
    element = document.createElement('div');
    addClassName(element, section.tagName);
  }

  setSectionAttributesOnElement(section, element);

  return element;
}

function renderListSection(section) {
  let element = document.createElement(section.tagName);

  setSectionAttributesOnElement(section, element);

  return element;
}

function renderListItem() {
  return document.createElement('li');
}

function renderCursorPlaceholder() {
  return document.createElement('br');
}

function renderInlineCursorPlaceholder() {
  return document.createTextNode(ZWNJ);
}

function renderCard() {
  let wrapper = document.createElement('div');
  let cardElement = document.createElement('div');
  cardElement.contentEditable = false;
  addClassName(cardElement, CARD_ELEMENT_CLASS_NAME);
  wrapper.appendChild(renderInlineCursorPlaceholder());
  wrapper.appendChild(cardElement);
  wrapper.appendChild(renderInlineCursorPlaceholder());
  return { wrapper, cardElement };
}

/**
 * Wrap the element in all of the opened markups
 * @return {DOMElement} the wrapped element
 * @private
 */
function wrapElement(element, openedMarkups) {
  let wrappedElement = element;

  for (let i=openedMarkups.length - 1; i>=0; i--) {
    let markup = openedMarkups[i];
    let openedElement = createElementFromMarkup(document, markup);
    openedElement.appendChild(wrappedElement);
    wrappedElement = openedElement;
  }

  return wrappedElement;
}

// Attach the element to its parent element at the correct position based on the
// previousRenderNode
function attachElementToParent(element, parentElement, previousRenderNode=null) {
  if (previousRenderNode) {
    let previousSibling = previousRenderNode.element;
    let previousSiblingPenultimate = penultimateParentOf(previousSibling,
                                                         parentElement);
    parentElement.insertBefore(element, previousSiblingPenultimate.nextSibling);
  } else {
    parentElement.insertBefore(element, parentElement.firstChild);
  }
}

function renderAtom(atom, element, previousRenderNode) {
  let atomElement = document.createElement('span');
  atomElement.contentEditable = false;

  let wrapper = document.createElement('span');
  addClassName(wrapper, ATOM_CLASS_NAME);
  let headTextNode = renderInlineCursorPlaceholder();
  let tailTextNode = renderInlineCursorPlaceholder();

  wrapper.appendChild(headTextNode);
  wrapper.appendChild(atomElement);
  wrapper.appendChild(tailTextNode);

  let wrappedElement = wrapElement(wrapper, atom.openedMarkups);
  attachElementToParent(wrappedElement, element, previousRenderNode);

  return {
    markupElement: wrappedElement,
    wrapper,
    atomElement,
    headTextNode,
    tailTextNode
  };
}

function getNextMarkerElement(renderNode) {
  let element = renderNode.element.parentNode;
  let marker = renderNode.postNode;
  let closedCount = marker.closedMarkups.length;

  while (closedCount--) {
    element = element.parentNode;
  }
  return element;
}

/**
 * Render the marker
 * @param {Marker} marker the marker to render
 * @param {DOMNode} element the element to attach the rendered marker to
 * @param {RenderNode} [previousRenderNode] The render node before this one, which
 *        affects the determination of where to insert this rendered marker.
 * @return {Object} With properties `element` and `markupElement`.
 *         The element (textNode) that has the text for
 *         this marker, and the outermost rendered element. If the marker has no
 *         markups, element and markupElement will be the same textNode
 * @private
 */
function renderMarker(marker, parentElement, previousRenderNode) {
  let text = renderHTMLText(marker);

  let element = document.createTextNode(text);
  let markupElement = wrapElement(element, marker.openedMarkups);
  attachElementToParent(markupElement, parentElement, previousRenderNode);

  return { element, markupElement };
}

// Attach the render node's element to the DOM,
// replacing the originalElement if it exists
function attachRenderNodeElementToDOM(renderNode, originalElement=null) {
  const element = renderNode.element;
  const hasRendered = !!originalElement;

  if (hasRendered) {
    let parentElement = renderNode.parent.element;
    parentElement.replaceChild(element, originalElement);
  } else {
    let parentElement, nextSiblingElement;
    if (renderNode.prev) {
      let previousElement = renderNode.prev.element;
      parentElement = previousElement.parentNode;
      nextSiblingElement = previousElement.nextSibling;
    } else {
      parentElement = renderNode.parent.element;
      nextSiblingElement = parentElement.firstChild;
    }
    parentElement.insertBefore(element, nextSiblingElement);
  }
}

function removeRenderNodeSectionFromParent(renderNode, section) {
  const parent = renderNode.parent.postNode;
  parent.sections.remove(section);
}

function removeRenderNodeElementFromParent(renderNode) {
  if (renderNode.element && renderNode.element.parentNode) {
    renderNode.element.parentNode.removeChild(renderNode.element);
  }
}

function validateCards(cards=[]) {
  forEach(cards, card => {
    mobiledocAssert(
      `Card "${card.name}" must define type "dom", has: "${card.type}"`,
      card.type === 'dom'
    );
    mobiledocAssert(
      `Card "${card.name}" must define \`render\` method`,
      !!card.render
    );
  });
  return cards;
}

function validateAtoms(atoms=[]) {
  forEach(atoms, atom => {
    mobiledocAssert(
      `Atom "${atom.name}" must define type "dom", has: "${atom.type}"`,
      atom.type === 'dom'
    );
    mobiledocAssert(
      `Atom "${atom.name}" must define \`render\` method`,
      !!atom.render
    );
  });
  return atoms;
}

class Visitor$1 {
  constructor(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options) {
    this.editor = editor;
    this.cards = validateCards(cards);
    this.atoms = validateAtoms(atoms);
    this.unknownCardHandler = unknownCardHandler;
    this.unknownAtomHandler = unknownAtomHandler;
    this.options = options;
  }

  _findCard(cardName) {
    let card = detect(this.cards, card => card.name === cardName);
    return card || this._createUnknownCard(cardName);
  }

  _createUnknownCard(cardName) {
    mobiledocAssert(
      `Unknown card "${cardName}" found, but no unknownCardHandler is defined`,
      !!this.unknownCardHandler
    );

    return {
      name: cardName,
      type: 'dom',
      render: this.unknownCardHandler,
      edit:   this.unknownCardHandler
    };
  }

  _findAtom(atomName) {
    let atom = detect(this.atoms, atom => atom.name === atomName);
    return atom || this._createUnknownAtom(atomName);
  }

  _createUnknownAtom(atomName) {
    mobiledocAssert(
      `Unknown atom "${atomName}" found, but no unknownAtomHandler is defined`,
      !!this.unknownAtomHandler
    );

    return {
      name: atomName,
      type: 'dom',
      render: this.unknownAtomHandler
    };
  }

  [POST_TYPE](renderNode, post, visit) {
    if (!renderNode.element) {
      renderNode.element = document.createElement('div');
    }
    addClassName(renderNode.element, EDITOR_ELEMENT_CLASS_NAME);
    if (post.hasContent) {
      removeClassName(renderNode.element, EDITOR_HAS_NO_CONTENT_CLASS_NAME);
    } else {
      addClassName(renderNode.element, EDITOR_HAS_NO_CONTENT_CLASS_NAME);
    }
    visit(renderNode, post.sections);
  }

  [MARKUP_SECTION_TYPE](renderNode, section, visit) {
    const originalElement = renderNode.element;

    // Always rerender the section -- its tag name or attributes may have changed.
    // TODO make this smarter, only rerendering and replacing the element when necessary
    renderNode.element = renderMarkupSection(section);
    renderNode.cursorElement = null;
    attachRenderNodeElementToDOM(renderNode, originalElement);

    if (section.isBlank) {
      let cursorPlaceholder = renderCursorPlaceholder();
      renderNode.element.appendChild(cursorPlaceholder);
      renderNode.cursorElement = cursorPlaceholder;
    } else {
      const visitAll = true;
      visit(renderNode, section.markers, visitAll);
    }
  }

  [LIST_SECTION_TYPE](renderNode, section, visit) {
    const originalElement = renderNode.element;

    renderNode.element = renderListSection(section);
    attachRenderNodeElementToDOM(renderNode, originalElement);

    const visitAll = true;
    visit(renderNode, section.items, visitAll);
  }

  [LIST_ITEM_TYPE](renderNode, item, visit) {
    // FIXME do we need to do anything special for rerenders?
    renderNode.element = renderListItem();
    renderNode.cursorElement = null;
    attachRenderNodeElementToDOM(renderNode, null);

    if (item.isBlank) {
      let cursorPlaceholder = renderCursorPlaceholder();
      renderNode.element.appendChild(cursorPlaceholder);
      renderNode.cursorElement = cursorPlaceholder;
    } else {
      const visitAll = true;
      visit(renderNode, item.markers, visitAll);
    }
  }

  [MARKER_TYPE](renderNode, marker) {
    let parentElement;

    if (renderNode.prev) {
      parentElement = getNextMarkerElement(renderNode.prev);
    } else {
      parentElement = renderNode.parent.element;
    }

    let { element, markupElement } =
      renderMarker(marker, parentElement, renderNode.prev);

    renderNode.element = element;
    renderNode.markupElement = markupElement;
  }

  [IMAGE_SECTION_TYPE](renderNode, section) {
    if (renderNode.element) {
      if (renderNode.element.src !== section.src) {
        renderNode.element.src = section.src;
      }
    } else {
      let element = document.createElement('img');
      element.src = section.src;
      if (renderNode.prev) {
        let previousElement = renderNode.prev.element;
        let nextElement = previousElement.nextSibling;
        if (nextElement) {
          nextElement.parentNode.insertBefore(element, nextElement);
        }
      }
      if (!element.parentNode) {
        renderNode.parent.element.appendChild(element);
      }
      renderNode.element = element;
    }
  }

  [CARD_TYPE](renderNode, section) {
    const originalElement = renderNode.element;
    const {editor, options} = this;

    const card = this._findCard(section.name);

    let { wrapper, cardElement } = renderCard();
    renderNode.element = wrapper;
    attachRenderNodeElementToDOM(renderNode, originalElement);

    const cardNode = new CardNode(
      editor, card, section, cardElement, options);
    renderNode.cardNode = cardNode;

    const initialMode = section._initialMode;
    cardNode[initialMode]();
  }

  [ATOM_TYPE](renderNode, atomModel) {
    let parentElement;

    if (renderNode.prev) {
      parentElement = getNextMarkerElement(renderNode.prev);
    } else {
      parentElement = renderNode.parent.element;
    }

    const { editor, options } = this;
    const {
      wrapper,
      markupElement,
      atomElement,
      headTextNode,
      tailTextNode
    } = renderAtom(atomModel, parentElement, renderNode.prev);
    const atom = this._findAtom(atomModel.name);

    let atomNode = renderNode.atomNode;
    if (!atomNode) {
      // create new AtomNode
      atomNode = new AtomNode(editor, atom, atomModel, atomElement, options);
    } else {
      // retarget atomNode to new atom element
      atomNode.element = atomElement;
    }

    atomNode.render();

    renderNode.atomNode = atomNode;
    renderNode.element = wrapper;
    renderNode.headTextNode = headTextNode;
    renderNode.tailTextNode = tailTextNode;
    renderNode.markupElement = markupElement;
  }
}

let destroyHooks = {
  [POST_TYPE](/*renderNode, post*/) {
    mobiledocAssert('post destruction is not supported by the renderer', false);
  },

  [MARKUP_SECTION_TYPE](renderNode, section) {
    removeRenderNodeSectionFromParent(renderNode, section);
    removeRenderNodeElementFromParent(renderNode);
  },

  [LIST_SECTION_TYPE](renderNode, section) {
    removeRenderNodeSectionFromParent(renderNode, section);
    removeRenderNodeElementFromParent(renderNode);
  },

  [LIST_ITEM_TYPE](renderNode, li) {
    removeRenderNodeSectionFromParent(renderNode, li);
    removeRenderNodeElementFromParent(renderNode);
  },

  [MARKER_TYPE](renderNode, marker) {
    // FIXME before we render marker, should delete previous renderNode's element
    // and up until the next marker element

    // If an atom throws during render we may end up later destroying a renderNode
    // that has not rendered yet, so exit early here if so.
    if (!renderNode.isRendered) {
      return;
    }
    let { markupElement } = renderNode;

    if (marker.section) {
      marker.section.markers.remove(marker);
    }

    if (markupElement.parentNode) {
      // if no parentNode, the browser already removed this element
      markupElement.parentNode.removeChild(markupElement);
    }
  },

  [IMAGE_SECTION_TYPE](renderNode, section) {
    removeRenderNodeSectionFromParent(renderNode, section);
    removeRenderNodeElementFromParent(renderNode);
  },

  [CARD_TYPE](renderNode, section) {
    if (renderNode.cardNode) {
      renderNode.cardNode.teardown();
    }
    removeRenderNodeSectionFromParent(renderNode, section);
    removeRenderNodeElementFromParent(renderNode);
  },

  [ATOM_TYPE](renderNode, atom) {
    if (renderNode.atomNode) {
      renderNode.atomNode.teardown();
    }

    // an atom is a kind of marker so just call its destroy hook vs copying here
    destroyHooks[MARKER_TYPE](renderNode, atom);
  }
};

// removes children from parentNode (a RenderNode) that are scheduled for removal
function removeDestroyedChildren(parentNode, forceRemoval=false) {
  let child = parentNode.childNodes.head;
  let nextChild, method;
  while (child) {
    nextChild = child.next;
    if (child.isRemoved || forceRemoval) {
      removeDestroyedChildren(child, true);
      method = child.postNode.type;
      mobiledocAssert(`editor-dom cannot destroy "${method}"`, !!destroyHooks[method]);
      destroyHooks[method](child, child.postNode);
      parentNode.childNodes.remove(child);
    }
    child = nextChild;
  }
}

// Find an existing render node for the given postNode, or
// create one, insert it into the tree, and return it
function lookupNode(renderTree, parentNode, postNode, previousNode) {
  if (postNode.renderNode) {
    return postNode.renderNode;
  } else {
    const renderNode = renderTree.buildRenderNode(postNode);
    parentNode.childNodes.insertAfter(renderNode, previousNode);
    return renderNode;
  }
}

class Renderer {
  constructor(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options) {
    this.editor = editor;
    this.visitor = new Visitor$1(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options);
    this.nodes = [];
    this.hasRendered = false;
  }

  destroy() {
    if (!this.hasRendered) {
      return;
    }
    let renderNode = this.renderTree.rootNode;
    let force = true;
    removeDestroyedChildren(renderNode, force);
  }

  visit(renderTree, parentNode, postNodes, visitAll=false) {
    let previousNode;
    postNodes.forEach(postNode => {
      let node = lookupNode(renderTree, parentNode, postNode, previousNode);
      if (node.isDirty || visitAll) {
        this.nodes.push(node);
      }
      previousNode = node;
    });
  }

  render(renderTree) {
    this.hasRendered = true;
    this.renderTree = renderTree;
    let renderNode = renderTree.rootNode;
    let method, postNode;

    while (renderNode) {
      removeDestroyedChildren(renderNode);
      postNode = renderNode.postNode;

      method = postNode.type;
      mobiledocAssert(`EditorDom visitor cannot handle type ${method}`, !!this.visitor[method]);
      this.visitor[method](renderNode, postNode,
                           (...args) => this.visit(renderTree, ...args));
      renderNode.markClean();
      renderNode = this.nodes.shift();
    }
  }
}

const VALID_LIST_SECTION_TAGNAMES = [
  'ul', 'ol'
].map(normalizeTagName);

const DEFAULT_TAG_NAME$1 = VALID_LIST_SECTION_TAGNAMES[0];

class ListSection extends Section {
  constructor(tagName=DEFAULT_TAG_NAME$1, items=[], attributes={}) {
    super(LIST_SECTION_TYPE);
    this.tagName = tagName;
    this.isListSection = true;
    this.isLeafSection = false;

    attributable(this);
    entries(attributes).forEach(([k,v]) => this.setAttribute(k, v));

    this.items = new LinkedList({
      adoptItem: i => {
        mobiledocAssert(`Cannot insert non-list-item to list (is: ${i.type})`,
               i.isListItem);
        i.section = i.parent = this;
      },
      freeItem:  i => i.section = i.parent = null
    });
    this.sections = this.items;

    items.forEach(i => this.items.append(i));
  }

  canJoin() {
    return false;
  }

  isValidTagName(normalizedTagName) {
    return contains(VALID_LIST_SECTION_TAGNAMES, normalizedTagName);
  }

  headPosition() {
    return this.items.head.headPosition();
  }

  tailPosition() {
    return this.items.tail.tailPosition();
  }

  get isBlank() {
    return this.items.isEmpty;
  }

  clone() {
    let newSection = this.builder.createListSection(this.tagName);
    forEach(this.items, i => newSection.items.append(i.clone()));
    return newSection;
  }

  /**
   * Mutates this list
   * @param {ListSection|Markerable}
   * @return null
   */
  join(other) {
    if (other.isListSection) {
      other.items.forEach(i => this.join(i));
    } else if (other.isMarkerable) {
      let item = this.builder.createListItem();
      item.join(other);
      this.items.append(item);
    }
  }
}

const VALID_LIST_ITEM_TAGNAMES = [
  'li'
].map(normalizeTagName);

class ListItem extends Markerable {
  constructor(tagName, markers=[]) {
    super(LIST_ITEM_TYPE, tagName, markers);
    this.isListItem = true;
    this.isNested = true;
  }

  isValidTagName(normalizedTagName) {
    return contains(VALID_LIST_ITEM_TAGNAMES, normalizedTagName);
  }

  splitAtMarker(marker, offset=0) {
    // FIXME need to check if we are going to split into two list items
    // or a list item and a new markup section:
    const isLastItem = !this.next;
    const createNewSection = (!marker && offset === 0 && isLastItem);

    let [beforeSection, afterSection] = [
      this.builder.createListItem(),
      createNewSection ? this.builder.createMarkupSection() :
                         this.builder.createListItem()
    ];

    return this._redistributeMarkers(
      beforeSection, afterSection, marker, offset);
  }

  get post() {
    return this.section.post;
  }
}

const VALID_MARKUP_TAGNAMES = [
  'a',
  'b',
  'code',
  'em',
  'i',
  's',   // strikethrough
  'strong',
  'sub', // subscript
  'sup', // superscript
  'u'
].map(normalizeTagName);

const VALID_ATTRIBUTES$1 = [
  'href',
  'rel'
];

/**
 * A Markup is similar with an inline HTML tag that might be added to
 * text to modify its meaning and/or display. Examples of types of markup
 * that could be added are bold ('b'), italic ('i'), strikethrough ('s'), and `a` tags (links).
 * @property {String} tagName
 */
class Markup {
  /*
   * @param {Object} attributes key-values
   */
  constructor(tagName, attributes={}) {
    this.tagName = normalizeTagName(tagName);

    mobiledocAssert('Must use attributes object param (not array) for Markup',
           !Array.isArray(attributes));

    this.attributes = filterObject(attributes, VALID_ATTRIBUTES$1);
    this.type = MARKUP_TYPE;

    mobiledocAssert(`Cannot create markup of tagName ${tagName}`,
           VALID_MARKUP_TAGNAMES.indexOf(this.tagName) !== -1);
  }

  /**
   * Whether text in the forward direction of the cursor (i.e. to the right in ltr text)
   * should be considered to have this markup applied to it.
   * @private
   */
  isForwardInclusive() {
    return this.tagName === normalizeTagName("a") ? false : true;
  }

  isBackwardInclusive() {
    return false;
  }

  hasTag(tagName) {
    return this.tagName === normalizeTagName(tagName);
  }

  /**
   * Returns the attribute value
   * @param {String} name, e.g. "href"
   */
  getAttribute(name) {
    return this.attributes[name];
  }

  static isValidElement(element) {
    const tagName = normalizeTagName(element.tagName);
    return VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1;
  }
}

const SKIPPABLE_ELEMENT_TAG_NAMES = [
  'style', 'head', 'title', 'meta'
].map(normalizeTagName);

const NEWLINES = /\n/g;
function sanitize(text) {
  return text.replace(NEWLINES, ' ');
}

/**
 * parses an element into a section, ignoring any non-markup
 * elements contained within
 * @private
 */
class SectionParser {
  constructor(builder, options={}) {
    this.builder = builder;
    this.plugins = options.plugins || [];
  }

  parse(element) {
    if (this._isSkippable(element)) {
      return [];
    }
    this.sections = [];
    this.state = {};

    this._updateStateFromElement(element);

    let finished = false;

    // top-level text nodes will be run through parseNode later so avoid running
    // the node through parserPlugins twice
    if (!isTextNode(element)) {
      finished = this.runPlugins(element);
    }

    if (!finished) {
      let childNodes = isTextNode(element) ? [element] : element.childNodes;

      forEach(childNodes, el => {
        this.parseNode(el);
      });
    }

    this._closeCurrentSection();

    return this.sections;
  }

  runPlugins(node) {
    let isNodeFinished = false;
    let env = {
      addSection: (section) => {
        // avoid creating empty paragraphs due to wrapper elements around
        // parser-plugin-handled elements
        if (this.state.section.isMarkerable && !this.state.text && !this.state.section.text) {
          this.state.section = null;
        } else {
          this._closeCurrentSection();
        }
        this.sections.push(section);
      },
      addMarkerable: (marker) => {
        let { state } = this;
        let { section } = state;
        mobiledocAssert(
          'Markerables can only be appended to markup sections and list item sections',
          section && section.isMarkerable
        );
        if (state.text) {
          this._createMarker();
        }
        section.markers.append(marker);
      },
      nodeFinished() {
        isNodeFinished = true;
      }
    };
    for (let i=0; i<this.plugins.length; i++) {
      let plugin = this.plugins[i];
      plugin(node, this.builder, env);
      if (isNodeFinished) {
        return true;
      }
    }
    return false;
  }

  /* eslint-disable complexity */
  parseNode(node) {
    if (!this.state.section) {
      this._updateStateFromElement(node);
    }

    let nodeFinished = this.runPlugins(node);
    if (nodeFinished) {
      return;
    }

    // handle closing the current section and starting a new one if we hit a
    // new-section-creating element.
    if (this.state.section && !isTextNode(node) && node.tagName) {
      let tagName = normalizeTagName(node.tagName);
      let isListSection = contains(VALID_LIST_SECTION_TAGNAMES, tagName);
      let isListItem = contains(VALID_LIST_ITEM_TAGNAMES, tagName);
      let isMarkupSection = contains(VALID_MARKUP_SECTION_TAGNAMES, tagName);
      let isNestedListSection = isListSection && this.state.section.isListItem;
      let lastSection = this.sections[this.sections.length - 1];

      // we can hit a list item after parsing a nested list, when that happens
      // and the lists are of different types we need to make sure we switch
      // the list type back
      if (isListItem && lastSection && lastSection.isListSection) {
        let parentElement = node.parentElement;
        let parentElementTagName = normalizeTagName(parentElement.tagName);
        if (parentElementTagName !== lastSection.tagName) {
          this._closeCurrentSection();
          this._updateStateFromElement(parentElement);
        }
      }

      // if we've broken out of a list due to nested section-level elements we
      // can hit the next list item without having a list section in the current
      // state. In this instance we find the parent list node and use it to
      // re-initialize the state with a new list section
      if (
        isListItem &&
        !(this.state.section.isListItem || this.state.section.isListSection) &&
        !lastSection.isListSection
      ) {
        this._closeCurrentSection();
        this._updateStateFromElement(node.parentElement);
      }

      // if we have consecutive list sections of different types (ul, ol) then
      // ensure we close the current section and start a new one
      let isNewListSection = lastSection
        && lastSection.isListSection
        && this.state.section.isListItem
        && isListSection
        && tagName !== lastSection.tagName;

      if (
        isNewListSection ||
        (isListSection && !isNestedListSection) ||
        isMarkupSection ||
        isListItem
      ) {
        // don't break out of the list for list items that contain a single <p>.
        // deals with typical case of <li><p>Text</p></li><li><p>Text</p></li>
        if (
          this.state.section.isListItem &&
          tagName === 'p' &&
          !node.nextSibling &&
          contains(VALID_LIST_ITEM_TAGNAMES, normalizeTagName(node.parentElement.tagName))
         ) {
          this.parseElementNode(node);
          return;
        }

        // avoid creating empty paragraphs due to wrapper elements around
        // section-creating elements
        if (this.state.section.isMarkerable && !this.state.text && this.state.section.markers.length === 0) {
          this.state.section = null;
        } else {
          this._closeCurrentSection();
        }

        this._updateStateFromElement(node);
      }

      if (this.state.section.isListSection) {
        // ensure the list section is closed and added to the sections list.
        // _closeCurrentSection handles pushing list items onto the list section
        this._closeCurrentSection();

        forEach(node.childNodes, (node) => {
          this.parseNode(node);
        });
        return;
      }
    }

    switch (node.nodeType) {
      case NODE_TYPES.TEXT:
        this.parseTextNode(node);
        break;
      case NODE_TYPES.ELEMENT:
        this.parseElementNode(node);
        break;
    }
  }

  parseElementNode(element) {
    let { state } = this;

    const markups = this._markupsFromElement(element);
    if (markups.length && state.text.length && state.section.isMarkerable) {
      this._createMarker();
    }
    state.markups.push(...markups);

    forEach(element.childNodes, (node) => {
      this.parseNode(node);
    });

    if (markups.length && state.text.length && state.section.isMarkerable) {
      // create the marker started for this node
      this._createMarker();
    }

    // pop the current markups from the stack
    state.markups.splice(-markups.length, markups.length);
  }

  parseTextNode(textNode) {
    let { state } = this;
    state.text += sanitize(textNode.textContent);
  }

  _updateStateFromElement(element) {
    let { state } = this;
    state.section = this._createSectionFromElement(element);
    state.markups = this._markupsFromElement(element);
    state.text = '';
  }

  _closeCurrentSection() {
    let { sections, state } = this;
    let lastSection = sections[sections.length - 1];

    if (!state.section) {
      return;
    }

    // close a trailing text node if it exists
    if (state.text.length && state.section.isMarkerable) {
      this._createMarker();
    }

    // push listItems onto the listSection or add a new section
    if (state.section.isListItem && lastSection && lastSection.isListSection) {
      trimSectionText(state.section);
      lastSection.items.append(state.section);
    } else {
      // avoid creating empty markup sections, especially useful for indented source
      if (
        state.section.isMarkerable &&
        !state.section.text.trim() &&
        !any(state.section.markers, marker => marker.isAtom)
      ) {
        state.section = null;
        state.text = '';
        return;
      }

      // remove empty list sections before creating a new section
      if (lastSection && lastSection.isListSection && lastSection.items.length === 0) {
        sections.pop();
      }

      sections.push(state.section);
    }

    state.section = null;
    state.text = '';
  }

  _markupsFromElement(element) {
    let { builder } = this;
    let markups = [];
    if (isTextNode(element)) {
      return markups;
    }

    const tagName = normalizeTagName(element.tagName);
    if (this._isValidMarkupForElement(tagName, element)) {
      markups.push(builder.createMarkup(tagName, getAttributes(element)));
    }

    this._markupsFromElementStyle(element).forEach(
      markup => markups.push(markup)
    );

    return markups;
  }

  _isValidMarkupForElement(tagName, element) {
    if (VALID_MARKUP_TAGNAMES.indexOf(tagName) === -1) {
      return false;
    } else if (tagName === 'b') {
      // google docs add a <b style="font-weight: normal;"> that should not
      // create a "b" markup
      return element.style.fontWeight !== 'normal';
    }
    return true;
  }

  _markupsFromElementStyle(element) {
    let { builder } = this;
    let markups = [];
    let { fontStyle, fontWeight } = element.style;
    if (fontStyle === 'italic') {
      markups.push(builder.createMarkup('em'));
    }
    if (fontWeight === 'bold' || fontWeight === '700') {
      markups.push(builder.createMarkup('strong'));
    }
    return markups;
  }

  _createMarker() {
    let { state } = this;
    let text = transformHTMLText(state.text);
    let marker = this.builder.createMarker(text, state.markups);
    state.section.markers.append(marker);
    state.text = '';
  }

  _getSectionDetails(element) {
    let sectionType,
        tagName,
        inferredTagName = false;
    if (isTextNode(element)) {
      tagName = DEFAULT_TAG_NAME;
      sectionType = MARKUP_SECTION_TYPE;
      inferredTagName = true;
    } else {
      tagName = normalizeTagName(element.tagName);

      if (contains(VALID_LIST_SECTION_TAGNAMES, tagName)) {
        sectionType = LIST_SECTION_TYPE;
      } else if (contains(VALID_LIST_ITEM_TAGNAMES, tagName)) {
        sectionType = LIST_ITEM_TYPE;
      } else if (contains(VALID_MARKUP_SECTION_TAGNAMES, tagName)) {
        sectionType = MARKUP_SECTION_TYPE;
      } else {
        sectionType = MARKUP_SECTION_TYPE;
        tagName = DEFAULT_TAG_NAME;
        inferredTagName = true;
      }
    }

    return {sectionType, tagName, inferredTagName};
  }

  _createSectionFromElement(element) {
    let { builder } = this;

    let section;
    let {tagName, sectionType, inferredTagName} =
      this._getSectionDetails(element);

    switch (sectionType) {
      case LIST_SECTION_TYPE:
        section = builder.createListSection(tagName);
        break;
      case LIST_ITEM_TYPE:
        section = builder.createListItem();
        break;
      case MARKUP_SECTION_TYPE:
        section = builder.createMarkupSection(tagName);
        section._inferredTagName = inferredTagName;
        break;
      default:
        mobiledocAssert('Cannot parse section from element', false);
    }

    return section;
  }

  _isSkippable(element) {
    return isCommentNode(element) ||
           (element.nodeType === NODE_TYPES.ELEMENT &&
            contains(SKIPPABLE_ELEMENT_TAG_NAMES,
                    normalizeTagName(element.tagName)));
  }
}

const GOOGLE_DOCS_CONTAINER_ID_REGEX = /^docs\-internal\-guid/;

const NO_BREAK_SPACE_REGEX = new RegExp(NO_BREAK_SPACE, 'g');
const TAB_CHARACTER_REGEX = new RegExp(TAB_CHARACTER, 'g');
function transformHTMLText(textContent) {
  let text = textContent;
  text = text.replace(NO_BREAK_SPACE_REGEX, ' ');
  text = text.replace(TAB_CHARACTER_REGEX, TAB);
  return text;
}

function trimSectionText(section) {
  if (section.isMarkerable && section.markers.length) {
    let { head, tail } = section.markers;
    head.value = head.value.replace(/^\s+/, '');
    tail.value = tail.value.replace(/\s+$/, '');
  }
}

function isGoogleDocsContainer(element) {
  return !isTextNode(element) &&
         !isCommentNode(element) &&
         normalizeTagName(element.tagName) === normalizeTagName('b') &&
         GOOGLE_DOCS_CONTAINER_ID_REGEX.test(element.id);
}

function detectRootElement(element) {
  let childNodes = element.childNodes || [];
  let googleDocsContainer = detect(childNodes, isGoogleDocsContainer);

  if (googleDocsContainer) {
    return googleDocsContainer;
  } else {
    return element;
  }
}

const TAG_REMAPPING = {
  'b': 'strong',
  'i': 'em'
};

function remapTagName(tagName) {
  let normalized = normalizeTagName(tagName);
  let remapped = TAG_REMAPPING[normalized];
  return remapped || normalized;
}

function trim(str) {
  return str.replace(/^\s+/, '').replace(/\s+$/, '');
}

function walkMarkerableNodes(parent, callback) {
  let currentNode = parent;

  if (
    isTextNode(currentNode) ||
    (
      isElementNode(currentNode) &&
      currentNode.classList.contains(ATOM_CLASS_NAME)
    )
  ) {
    callback(currentNode);
  } else {
    currentNode = currentNode.firstChild;
    while (currentNode) {
      walkMarkerableNodes(currentNode, callback);
      currentNode = currentNode.nextSibling;
    }
  }
}

/**
 * Parses DOM element -> Post
 * @private
 */
class DOMParser {
  constructor(builder, options={}) {
    this.builder = builder;
    this.sectionParser = new SectionParser(this.builder, options);
  }

  parse(element) {
    const post = this.builder.createPost();
    let rootElement = detectRootElement(element);

    this._eachChildNode(rootElement, child => {
      let sections = this.parseSections(child);
      this.appendSections(post, sections);
    });

    // trim leading/trailing whitespace of markerable sections to avoid
    // unnessary whitespace from indented HTML input
    forEach(post.sections, section => trimSectionText(section));

    return post;
  }

  appendSections(post, sections) {
    forEach(sections, section => this.appendSection(post, section));
  }

  appendSection(post, section) {
    if (
      section.isBlank ||
      (section.isMarkerable &&
        trim(section.text) === "" &&
        !any(section.markers, marker => marker.isAtom))
    ) {
      return;
    }

    let lastSection = post.sections.tail;
    if (lastSection &&
        lastSection._inferredTagName &&
        section._inferredTagName &&
        lastSection.tagName === section.tagName) {
      lastSection.join(section);
    } else {
      post.sections.append(section);
    }
  }

  _eachChildNode(element, callback) {
    let nodes = isTextNode(element) ? [element] : element.childNodes;
    forEach(nodes, node => callback(node));
  }

  parseSections(element) {
    return this.sectionParser.parse(element);
  }

  // walk up from the textNode until the rootNode, converting each
  // parentNode into a markup
  collectMarkups(textNode, rootNode) {
    let markups = [];
    let currentNode = textNode.parentNode;
    while (currentNode && currentNode !== rootNode) {
      let markup = this.markupFromNode(currentNode);
      if (markup) {
        markups.push(markup);
      }

      currentNode = currentNode.parentNode;
    }
    return markups;
  }

  // Turn an element node into a markup
  markupFromNode(node) {
    if (Markup.isValidElement(node)) {
      let tagName = remapTagName(node.tagName);
      let attributes = getAttributes(node);
      return this.builder.createMarkup(tagName, attributes);
    }
  }

  // FIXME should move to the section parser?
  // FIXME the `collectMarkups` logic could simplify the section parser?
  reparseSection(section, renderTree) {
    switch (section.type) {
      case LIST_SECTION_TYPE:
        return this.reparseListSection(section, renderTree);
      case LIST_ITEM_TYPE:
        return this.reparseListItem(section, renderTree);
      case MARKUP_SECTION_TYPE:
        return this.reparseMarkupSection(section, renderTree);
      default:
        return; // can only parse the above types
    }
  }

  reparseMarkupSection(section, renderTree) {
    return this._reparseSectionContainingMarkers(section, renderTree);
  }

  reparseListItem(listItem, renderTree) {
    return this._reparseSectionContainingMarkers(listItem, renderTree);
  }

  reparseListSection(listSection, renderTree) {
    listSection.items.forEach(li => this.reparseListItem(li, renderTree));
  }

  _reparseSectionContainingMarkers(section, renderTree) {
    let element = section.renderNode.element;
    let seenRenderNodes = [];
    let previousMarker;

    walkMarkerableNodes(element, (node) => {
      let marker;
      let renderNode = renderTree.getElementRenderNode(node);
      if (renderNode) {
        if (renderNode.postNode.isMarker) {
          let text = transformHTMLText(node.textContent);
          let markups = this.collectMarkups(node, element);
          if (text.length) {
            marker = renderNode.postNode;
            marker.value = text;
            marker.markups = markups;
          } else {
            renderNode.scheduleForRemoval();
          }
        } else if (renderNode.postNode.isAtom) {
          let { headTextNode, tailTextNode } = renderNode;
          if (headTextNode.textContent !== ZWNJ) {
            let value = headTextNode.textContent.replace(new RegExp(ZWNJ, 'g'), '');
            headTextNode.textContent = ZWNJ;
            if (previousMarker && previousMarker.isMarker) {
              previousMarker.value += value;
              if (previousMarker.renderNode) {
                previousMarker.renderNode.markDirty();
              }
            } else {
              let postNode = renderNode.postNode;
              let newMarkups = postNode.markups.slice();
              let newPreviousMarker = this.builder.createMarker(value, newMarkups);
              section.markers.insertBefore(newPreviousMarker, postNode);

              let newPreviousRenderNode = renderTree.buildRenderNode(newPreviousMarker);
              newPreviousRenderNode.markDirty();
              section.renderNode.markDirty();

              seenRenderNodes.push(newPreviousRenderNode);
              section.renderNode.childNodes.insertBefore(newPreviousRenderNode,
                                                         renderNode);
            }
          }
          if (tailTextNode.textContent !== ZWNJ) {
            let value = tailTextNode.textContent.replace(new RegExp(ZWNJ, 'g'), '');
            tailTextNode.textContent = ZWNJ;

            if (renderNode.postNode.next && renderNode.postNode.next.isMarker) {
              let nextMarker = renderNode.postNode.next;

              if (nextMarker.renderNode) {
                let nextValue = nextMarker.renderNode.element.textContent;
                nextMarker.renderNode.element.textContent = value + nextValue;
              } else {
                let nextValue = value + nextMarker.value;
                nextMarker.value = nextValue;
              }
            } else {
              let postNode = renderNode.postNode;
              let newMarkups = postNode.markups.slice();
              let newMarker = this.builder.createMarker(value, newMarkups);

              section.markers.insertAfter(newMarker, postNode);

              let newRenderNode = renderTree.buildRenderNode(newMarker);
              seenRenderNodes.push(newRenderNode);

              newRenderNode.markDirty();
              section.renderNode.markDirty();

              section.renderNode.childNodes.insertAfter(newRenderNode, renderNode);
            }
          }
          if (renderNode) {
            marker = renderNode.postNode;
          }
        }
      } else if (isTextNode(node)) {
        let text = transformHTMLText(node.textContent);
        let markups = this.collectMarkups(node, element);
        marker = this.builder.createMarker(text, markups);

        renderNode = renderTree.buildRenderNode(marker);
        renderNode.element = node;
        renderNode.markClean();
        section.renderNode.markDirty();

        let previousRenderNode = previousMarker && previousMarker.renderNode;
        section.markers.insertAfter(marker, previousMarker);
        section.renderNode.childNodes.insertAfter(renderNode, previousRenderNode);
      }

      if (renderNode) {
        seenRenderNodes.push(renderNode);
      }
      previousMarker = marker;
    });

    let renderNode = section.renderNode.childNodes.head;
    while (renderNode) {
      if (seenRenderNodes.indexOf(renderNode) === -1) {
        renderNode.scheduleForRemoval();
      }
      renderNode = renderNode.next;
    }
  }
}

class HTMLParser {
  constructor(builder, options={}) {
    mobiledocAssert('Must pass builder to HTMLParser', builder);
    this.builder = builder;
    this.options = options;
  }

  /**
   * @param {String} html to parse
   * @return {Post} A post abstract
   */
  parse(html) {
    let dom = parseHTML(html);
    let parser = new DOMParser(this.builder, this.options);
    return parser.parse(dom);
  }
}

class RenderNode extends LinkedItem {
  constructor(postNode, renderTree) {
    super();
    this.parent = null;
    this.isDirty = true;
    this.isRemoved = false;
    this.postNode = postNode;
    this._childNodes = null;
    this._element = null;
    this._cursorElement = null; // blank render nodes need a cursor element
    this.renderTree = renderTree;

    // RenderNodes for Markers keep track of their markupElement
    this.markupElement = null;

    // RenderNodes for Atoms use these properties
    this.headTextNode = null;
    this.tailTextNode = null;
    this.atomNode = null;

    // RenderNodes for cards use this property
    this.cardNode = null;
  }
  isAttached() {
    mobiledocAssert('Cannot check if a renderNode is attached without an element.',
           !!this.element);
    return containsNode(this.renderTree.rootElement, this.element);
  }
  get childNodes() {
    if (!this._childNodes) {
      this._childNodes = new LinkedList({
        adoptItem: item => item.parent = this,
        freeItem: item => item.destroy()
      });
    }
    return this._childNodes;
  }
  scheduleForRemoval() {
    this.isRemoved = true;
    if (this.parent) { this.parent.markDirty(); }
  }
  markDirty() {
    this.isDirty = true;
    if (this.parent) { this.parent.markDirty(); }
  }
  get isRendered() {
    return !!this.element;
  }
  markClean() {
    this.isDirty = false;
  }
  set element(element) {
    const currentElement = this._element;
    this._element = element;

    if (currentElement) {
      this.renderTree.removeElementRenderNode(currentElement);
    }

    if (element) {
      this.renderTree.setElementRenderNode(element, this);
    }
  }
  get element() {
    return this._element;
  }
  set cursorElement(cursorElement) {
    this._cursorElement = cursorElement;
  }
  get cursorElement() {
    return this._cursorElement || this.element;
  }
  destroy() {
    this.element = null;
    this.parent = null;
    this.postNode = null;
    this.renderTree = null;
  }
  reparsesMutationOfChildNode(node) {
    if (this.postNode.isCardSection) {
      return !containsNode(this.cardNode.element, node);
    } else if (this.postNode.isAtom) {
      return !containsNode(this.atomNode.element, node);
    }
    return true;
  }
}

// start at one to make the falsy semantics easier
let uuidGenerator = 1;

class ElementMap {
  constructor() {
    this._map = {};
  }
  set(key, value) {
    let uuid = key._uuid;
    if (!uuid) {
      key._uuid = uuid = '' + uuidGenerator++;
    }
    this._map[uuid] = value;
  }
  get(key) {
    if (key._uuid) {
      return this._map[key._uuid];
    }
    return null;
  }
  remove(key) {
    mobiledocAssert('tried to fetch a value for an element not seen before', !!key._uuid);
    delete this._map[key._uuid];
  }

}

class RenderTree {
  constructor(rootPostNode) {
    this._rootNode = this.buildRenderNode(rootPostNode);
    this._elements = new ElementMap();
  }
  /*
   * @return {RenderNode} The root render node in this tree
   */
  get rootNode() {
    return this._rootNode;
  }
  /**
   * @return {Boolean}
   */
  get isDirty() {
    return this.rootNode && this.rootNode.isDirty;
  }
  /*
   * @return {DOMNode} The root DOM element in this tree
   */
  get rootElement() {
    return this.rootNode.element;
  }
  /*
   * @param {DOMNode} element
   * @return {RenderNode} The renderNode for this element, if any
   */
  getElementRenderNode(element) {
    return this._elements.get(element);
  }
  setElementRenderNode(element, renderNode) {
    this._elements.set(element, renderNode);
  }
  removeElementRenderNode(element) {
    this._elements.remove(element);
  }
  /**
   * @param {DOMNode} element
   * Walk up from the dom element until we find a renderNode element
   */
  findRenderNodeFromElement(element, conditionFn=()=>true) {
    let renderNode;
    while (element) {
      renderNode = this.getElementRenderNode(element);
      if (renderNode && conditionFn(renderNode)) {
        return renderNode;
      }

      // continue loop
      element = element.parentNode;

      // stop if we are at the root element
      if (element === this.rootElement) {
        if (conditionFn(this.rootNode)) {
          return this.rootNode;
        } else {
          return;
        }
      }
    }
  }
  buildRenderNode(postNode) {
    const renderNode = new RenderNode(postNode, this);
    postNode.renderNode = renderNode;
    return renderNode;
  }
}

const MOBILEDOC_VERSION$4 = MOBILEDOC_VERSION$3;

var mobiledocRenderers = {
  render(post, version) {
    switch (version) {
      case MOBILEDOC_VERSION:
        return MobiledocRenderer.render(post);
      case MOBILEDOC_VERSION$1:
        return MobiledocRenderer$1.render(post);
      case MOBILEDOC_VERSION$2:
        return MobiledocRenderer$2.render(post);
      case undefined:
      case null:
      case MOBILEDOC_VERSION$3:
        return MobiledocRenderer$3.render(post);
      default:
        mobiledocAssert(`Unknown version of mobiledoc renderer requested: ${version}`, false);
    }
  }
};

const Cursor = class Cursor {
  constructor(editor) {
    this.editor = editor;
    this.renderTree = editor._renderTree;
    this.post = editor.post;
  }

  clearSelection() {
    clearSelection();
  }

  /**
   * @return {Boolean} true when there is either a collapsed cursor in the
   * editor's element or a selection that is contained in the editor's element
   */
  hasCursor() {
    return this.editor.hasRendered &&
           (this._hasCollapsedSelection() || this._hasSelection());
  }

  hasSelection() {
    return this.editor.hasRendered &&
           this._hasSelection();
  }

  /**
   * @return {Boolean} Can the cursor be on this element?
   */
  isAddressable(element) {
    let { renderTree } = this;
    let renderNode = renderTree.findRenderNodeFromElement(element);
    if (renderNode && renderNode.postNode.isCardSection) {
      let renderedElement = renderNode.element;

      // card sections have addressable text nodes containing &zwnj;
      // as their first and last child
      if (element !== renderedElement &&
          element !== renderedElement.firstChild &&
          element !== renderedElement.lastChild) {
        return false;
      }
    }

    return !!renderNode;
  }

  /*
   * @return {Range} Cursor#Range object
   */
  get offsets() {
    if (!this.hasCursor()) { return Range.blankRange(); }

    let { selection, renderTree } = this;
    let parentNode = this.editor.element;
    selection = constrainSelectionTo(selection, parentNode);

    const {
      headNode, headOffset, tailNode, tailOffset, direction
    } = comparePosition(selection);

    const headPosition = Position$1.fromNode(renderTree, headNode, headOffset);
    const tailPosition = Position$1.fromNode(renderTree, tailNode, tailOffset);

    return new Range(headPosition, tailPosition, direction);
  }

  _findNodeForPosition(position) {
    let { section } = position;
    let node, offset;
    if (section.isCardSection) {
      offset = 0;
      if (position.offset === 0) {
        node = section.renderNode.element.firstChild;
      } else {
        node = section.renderNode.element.lastChild;
      }
    } else if (section.isBlank) {
      node = section.renderNode.cursorElement;
      offset = 0;
    } else {
      let {marker, offsetInMarker} = position;
      if (marker.isAtom) {
        if (offsetInMarker > 0) {
          // FIXME -- if there is a next marker, focus on it?
          offset = 0;
          node = marker.renderNode.tailTextNode;
        } else {
          offset = 0;
          node = marker.renderNode.headTextNode;
        }
      } else {
        node = marker.renderNode.element;
        offset = offsetInMarker;
      }
    }

    return {node, offset};
  }

  selectRange(range) {
    if (range.isBlank) {
      this.clearSelection();
      return;
    }

    const { head, tail, direction } = range;
    const { node:headNode, offset:headOffset } = this._findNodeForPosition(head),
          { node:tailNode, offset:tailOffset } = this._findNodeForPosition(tail);
    this._moveToNode(headNode, headOffset, tailNode, tailOffset, direction);

    // Firefox sometimes doesn't keep focus in the editor after adding a card
    this.editor._ensureFocus();
  }

  get selection() {
    return window.getSelection();
  }

  selectedText() {
    // FIXME remove this
    return this.selection.toString();
  }

  /**
   * @param {textNode} node
   * @param {integer} offset
   * @param {textNode} endNode
   * @param {integer} endOffset
   * @param {integer} direction forward or backward, default forward
   * @private
   */
  _moveToNode(node, offset, endNode, endOffset, direction=DIRECTION.FORWARD) {
    this.clearSelection();

    if (direction === DIRECTION.BACKWARD) {
      [node, offset, endNode, endOffset] = [ endNode, endOffset, node, offset ];
    }

    const range = document.createRange();
    range.setStart(node, offset);
    if (direction === DIRECTION.BACKWARD && !!this.selection.extend) {
      this.selection.addRange(range);
      this.selection.extend(endNode, endOffset);
    } else {
      range.setEnd(endNode, endOffset);
      this.selection.addRange(range);
    }
  }

  _hasSelection() {
    const element = this.editor.element;
    const { _selectionRange } = this;
    if (!_selectionRange || _selectionRange.collapsed) { return false; }

    return containsNode(element, this.selection.anchorNode) &&
           containsNode(element, this.selection.focusNode);
  }

  _hasCollapsedSelection() {
    const { _selectionRange } = this;
    if (!_selectionRange) { return false; }

    const element = this.editor.element;
    return containsNode(element, this.selection.anchorNode);
  }

  get _selectionRange() {
    const { selection } = this;
    if (selection.rangeCount === 0) { return null; }
    return selection.getRangeAt(0);
  }
};

var Environment = {
  hasDOM() {
    return typeof document !== 'undefined';
  }
};

const ATOM_LENGTH = 1;

class Atom extends LinkedItem {
  constructor(name, value, payload, markups=[]) {
    super();
    this.name = name;
    this.value = value;
    this.text = ''; // An atom never has text, but it does have a value
    mobiledocAssert('Atom must have value', value !== undefined && value !== null);
    this.payload = payload;
    this.type = ATOM_TYPE;
    this.isMarker = false;
    this.isAtom = true;

    this.markups = [];
    markups.forEach(m => this.addMarkup(m));
  }

  clone() {
    let clonedMarkups = this.markups.slice();
    return this.builder.createAtom(
      this.name, this.value, this.payload, clonedMarkups
    );
  }

  get isBlank() {
    return false;
  }

  get length() {
    return ATOM_LENGTH;
  }

  canJoin(/* other */) {
    return false;
  }

  textUntil(/* offset */) {
    return '';
  }

  split(offset=0, endOffset=offset) {
    let markers = [];

    if (endOffset === 0) {
      markers.push(this.builder.createMarker('', this.markups.slice()));
    }

    markers.push(this.clone());

    if (offset === ATOM_LENGTH) {
      markers.push(this.builder.createMarker('', this.markups.slice()));
    }

    return markers;
  }

  splitAtOffset(offset) {
    mobiledocAssert('Cannot split a marker at an offset > its length',
           offset <= this.length);

    let { builder } = this;
    let clone = this.clone();
    let blankMarker = builder.createMarker('');
    let pre, post;

    if (offset === 0) {
      ([pre, post] = [blankMarker, clone]);
    } else if (offset === ATOM_LENGTH) {
      ([pre, post] = [clone, blankMarker]);
    } else {
      mobiledocAssert(`Invalid offset given to Atom#splitAtOffset: "${offset}"`, false);
    }

    this.markups.forEach(markup => {
      pre.addMarkup(markup);
      post.addMarkup(markup);
    });
    return [pre, post];
  }
}

mixin(Atom, Markerupable);

/**
 * The Post is an in-memory representation of an editor's document.
 * An editor always has a single post. The post is organized into a list of
 * sections. Each section may be markerable (contains "markers", aka editable
 * text) or non-markerable (e.g., a card).
 * When persisting a post, it must first be serialized (loss-lessly) into
 * mobiledoc using {@link Editor#serialize}.
 */
class Post {
  /**
   * @private
   */
  constructor() {
    this.type = POST_TYPE;
    this.sections = new LinkedList({
      adoptItem: s => s.post = s.parent = this,
      freeItem: s => s.post = s.parent = null
    });
  }

  /**
   * @return {Position} The position at the start of the post (will be a {@link BlankPosition}
   * if the post is blank)
   * @public
   */
  headPosition() {
    if (this.isBlank) {
      return Position$1.blankPosition();
    } else {
      return this.sections.head.headPosition();
    }
  }

  /**
   * @return {Position} The position at the end of the post (will be a {@link BlankPosition}
   * if the post is blank)
   * @public
   */
  tailPosition() {
    if (this.isBlank) {
      return Position$1.blankPosition();
    } else {
      return this.sections.tail.tailPosition();
    }
  }

  /**
   * @return {Range} A range encompassing the entire post
   * @public
   */
  toRange() {
    return this.headPosition().toRange(this.tailPosition());
  }

  get isBlank() {
    return this.sections.isEmpty;
  }

  /**
   * If the post has no sections, or only has one, blank section, then it does
   * not have content and this method returns false. Otherwise it is true.
   * @return {Boolean}
   * @public
   */
  get hasContent() {
    if ((this.sections.length > 1) ||
        (this.sections.length === 1 && !this.sections.head.isBlank)) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * @param {Range} range
   * @return {Array} markers that are completely contained by the range
   */
  markersContainedByRange(range) {
    const markers = [];

    this.walkMarkerableSections(range, section => {
      section._markersInRange(
        range.trimTo(section),
        (m, {isContained}) => { if (isContained) { markers.push(m); } }
      );
    });

    return markers;
  }

  markupsInRange(range) {
    const markups = new Set();

    if (range.isCollapsed) {
      let pos = range.head;
      if (pos.isMarkerable) {
        let [back, forward] = [pos.markerIn(-1), pos.markerIn(1)];
        if (back && forward && back === forward) {
          back.markups.forEach(m => markups.add(m));
        } else {
          (back && back.markups || []).forEach(m => {
            if (m.isForwardInclusive()) {
              markups.add(m);
            }
          });
          (forward && forward.markups || []).forEach(m => {
            if (m.isBackwardInclusive()) {
              markups.add(m);
            }
          });
        }
      }
    } else {
      this.walkMarkerableSections(range, (section) => {
        forEach(
          section.markupsInRange(range.trimTo(section)),
          m => markups.add(m)
        );
      });
    }

    return markups.toArray();
  }

  walkAllLeafSections(callback) {
    let range = this.headPosition().toRange(this.tailPosition());
    return this.walkLeafSections(range, callback);
  }

  walkLeafSections(range, callback) {
    const { head, tail } = range;

    let index = 0;
    let nextSection, shouldStop;
    let currentSection = head.section;

    while (currentSection) {
      nextSection = this._nextLeafSection(currentSection);
      shouldStop = currentSection === tail.section;

      callback(currentSection, index);
      index++;

      if (shouldStop) {
        break;
      } else {
        currentSection = nextSection;
      }
    }
  }

  walkMarkerableSections(range, callback) {
    this.walkLeafSections(range, section => {
      if (section.isMarkerable) {
        callback(section);
      }
    });
  }

  // return the next section that has markers after this one,
  // possibly skipping non-markerable sections
  _nextLeafSection(section) {
    if (!section) { return null; }

    const next = section.next;
    if (next) {
      if (next.isLeafSection) {
        return next;
      } else if (next.items) {
        return next.items.head;
      } else {
        mobiledocAssert('Cannot determine next section from non-leaf-section', false);
      }
    } else if (section.isNested) {
      // if there is no section after this, but this section is a child
      // (e.g. a ListItem inside a ListSection), check for a markerable
      // section after its parent
      return this._nextLeafSection(section.parent);
    }
  }

  /**
   * @param {Range} range
   * @return {Post} A new post, constrained to {range}
   */
  trimTo(range) {
    const post = this.builder.createPost();
    const { builder } = this;

    let sectionParent = post,
        listParent = null;
    this.walkLeafSections(range, section => {
      let newSection;
      if (section.isMarkerable) {
        if (section.isListItem) {
          if (listParent) {
            sectionParent = null;
          } else {
            listParent = builder.createListSection(section.parent.tagName);
            post.sections.append(listParent);
            sectionParent = null;
          }
          newSection = builder.createListItem();
          listParent.items.append(newSection);
        } else {
          listParent = null;
          sectionParent = post;
          newSection = builder.createMarkupSection(section.tagName);
        }

        let currentRange = range.trimTo(section);
        forEach(
          section.markersFor(currentRange.headSectionOffset, currentRange.tailSectionOffset),
          m => newSection.markers.append(m)
        );
      } else {
        newSection = section.clone();
        sectionParent = post;
      }
      if (sectionParent) {
        sectionParent.sections.append(newSection);
      }
    });
    return post;
  }
}

class Image extends Section {
  constructor() {
    super(IMAGE_SECTION_TYPE);
    this.src = null;
  }

  canJoin() {
    return false;
  }

  get isBlank() {
    return false;
  }

  get length() {
    return 1;
  }
}

function shallowCopyObject(object) {
  let copy = {};
  Object.keys(object).forEach(key => {
    copy[key] = object[key];
  });
  return copy;
}

const CARD_MODES = {
  DISPLAY: 'display',
  EDIT: 'edit'
};

const CARD_LENGTH = 1;

const DEFAULT_INITIAL_MODE = CARD_MODES.DISPLAY;

class Card extends Section {
  constructor(name, payload) {
    super(CARD_TYPE);
    this.name = name;
    this.payload = payload;
    this.setInitialMode(DEFAULT_INITIAL_MODE);
    this.isCardSection = true;
  }

  get isBlank() {
    return false;
  }

  canJoin() {
    return false;
  }

  get length() {
    return CARD_LENGTH;
  }

  clone() {
    let payload = shallowCopyObject(this.payload);
    let card = this.builder.createCardSection(this.name, payload);
    // If this card is currently rendered, clone the mode it is
    // currently in as the default mode of the new card.
    let mode = this._initialMode;
    if (this.renderNode && this.renderNode.cardNode) {
      mode = this.renderNode.cardNode.mode;
    }
    card.setInitialMode(mode);
    return card;
  }

  /**
   * set the mode that this will be rendered into initially
   * @private
   */
  setInitialMode(initialMode) {
    // TODO validate initialMode
    this._initialMode = initialMode;
  }
}

function cacheKey(tagName, attributes) {
  return `${normalizeTagName(tagName)}-${objectToSortedKVArray(attributes).join('-')}`;
}

function addMarkupToCache(cache, markup) {
  cache[cacheKey(markup.tagName, markup.attributes)] = markup;
}

function findMarkupInCache(cache, tagName, attributes) {
  const key = cacheKey(tagName, attributes);
  return cache[key];
}

/**
 * The PostNodeBuilder is used to create new {@link Post} primitives, such
 * as a MarkupSection, a CardSection, a Markup, etc. Every instance of an
 * {@link Editor} has its own builder instance. The builder can be used
 * inside an {@link Editor#run} callback to programmatically create new
 * Post primitives to insert into the document.
 * A PostNodeBuilder should be read from the Editor, *not* instantiated on its own.
 */
class PostNodeBuilder {
  /**
   * @private
   */
  constructor() {
    this.markupCache = {};
  }

  /**
   * @return {Post} A new, blank post
   */
  createPost(sections=[]) {
    const post = new Post();
    post.builder = this;

    sections.forEach(s => post.sections.append(s));

    return post;
  }

  createMarkerableSection(type, tagName, markers=[]) {
    switch (type) {
      case LIST_ITEM_TYPE:
        return this.createListItem(markers);
      case MARKUP_SECTION_TYPE:
        return this.createMarkupSection(tagName, markers);
      default:
        mobiledocAssert(`Cannot create markerable section of type ${type}`, false);
    }
  }

  /**
   * @param {tagName} [tagName='P']
   * @param {Marker[]} [markers=[]]
   * @return {MarkupSection}
   */
  createMarkupSection(tagName=DEFAULT_TAG_NAME, markers=[], isGenerated=false, attributes={}) {
    tagName = normalizeTagName(tagName);
    const section = new MarkupSection(tagName, markers, attributes);
    if (isGenerated) {
      section.isGenerated = true;
    }
    section.builder = this;
    return section;
  }

  createListSection(tagName=DEFAULT_TAG_NAME$1, items=[], attributes={}) {
    tagName = normalizeTagName(tagName);
    const section = new ListSection(tagName, items, attributes);
    section.builder = this;
    return section;
  }

  createListItem(markers=[]) {
    const tagName = normalizeTagName('li');
    const item = new ListItem(tagName, markers);
    item.builder = this;
    return item;
  }

  createImageSection(url) {
    let section = new Image();
    if (url) {
      section.src = url;
    }
    return section;
  }

  /**
   * @param {String} name
   * @param {Object} [payload={}]
   * @return {CardSection}
   */
  createCardSection(name, payload={}) {
    const card = new Card(name, payload);
    card.builder = this;
    return card;
  }

  /**
   * @param {String} value
   * @param {Markup[]} [markups=[]]
   * @return {Marker}
   */
  createMarker(value, markups=[]) {
    const marker = new Marker(value, markups);
    marker.builder = this;
    return marker;
  }

  /**
   * @param {String} name
   * @param {String} [value='']
   * @param {Object} [payload={}]
   * @param {Markup[]} [markups=[]]
   * @return {Atom}
   */
  createAtom(name, value='', payload={}, markups=[]) {
    const atom = new Atom(name, value, payload, markups);
    atom.builder = this;
    return atom;
  }

  /**
   * @param {String} tagName
   * @param {Object} attributes Key-value pairs of attributes for the markup
   * @return {Markup}
   */
  createMarkup(tagName, attributes={}) {
    tagName = normalizeTagName(tagName);

    let markup = findMarkupInCache(this.markupCache, tagName, attributes);
    if (!markup) {
      markup = new Markup(tagName, attributes);
      markup.builder = this;
      addMarkupToCache(this.markupCache, markup);
    }

    return markup;
  }
}

/**
 * Convert section at the editor's cursor position into a list.
 * Does nothing if the cursor position is not at the start of the section,
 * or if the section is already a list item.
 *
 * @param {Editor} editor
 * @param {String} listTagName ("ul" or "ol")
 * @public
 */
function replaceWithListSection(editor, listTagName) {
  let { range: { head, head: { section } } } = editor;
  // Skip if cursor is not at end of section
  if (!head.isTail()) {
    return;
  }

  if (section.isListItem) {
    return;
  }

  editor.run(postEditor => {
    let { builder } = postEditor;
    let item = builder.createListItem();
    let listSection = builder.createListSection(listTagName, [item]);

    postEditor.replaceSection(section, listSection);
    postEditor.setRange(listSection.headPosition());
  });
}

/**
 * Convert section at the editor's cursor position into a header section.
 * Does nothing if the cursor position is not at the start of the section.
 *
 * @param {Editor} editor
 * @param {String} headingTagName ('h1', 'h2', 'h3', 'h4', 'h5', 'h6')
 * @public
 */
function replaceWithHeaderSection(editor, headingTagName) {
  let { range: { head, head: { section } } } = editor;
  // Skip if cursor is not at end of section
  if (!head.isTail()) {
    return;
  }

  editor.run(postEditor => {
    let { builder } = postEditor;
    let newSection = builder.createMarkupSection(headingTagName);
    postEditor.replaceSection(section, newSection);
    postEditor.setRange(newSection.headPosition());
  });
}

const DEFAULT_TEXT_INPUT_HANDLERS = [
  {
    name: 'ul',
    // "* " -> ul
    match: /^\* $/,
    run(editor) {
      replaceWithListSection(editor, 'ul');
    }
  },
  {
    name: 'ol',
    // "1" -> ol, "1." -> ol
    match: /^1\.? $/,
    run(editor) {
      replaceWithListSection(editor, 'ol');
    }
  },
  {
    name: 'heading',
    /*
     * "# " -> h1
     * "## " -> h2
     * "### " -> h3
     * "#### " -> h4
     * "##### " -> h5
     * "###### " -> h6
     */
    match: /^(#{1,6}) $/,
    run(editor, matches) {
      let capture = matches[1];
      let headingTag = 'h' + capture.length;
      replaceWithHeaderSection(editor, headingTag);
    }
  }
];

var Browser = {
  isMac() {
    return (typeof window !== 'undefined') && window.navigator && /Mac/.test(window.navigator.platform);
  },
  isWin() {
    return (typeof window !== 'undefined') && window.navigator && /Win/.test(window.navigator.platform);
  }
};

/**
 * @module UI
 */

/**
 * @callback promptCallback
 * @param {String} url The URL to pass back to the editor for linking
 *        to the selected text.
 */

/**
 * @callback showPrompt
 * @param {String} message The text of the prompt.
 * @param {String} defaultValue The initial URL to display in the prompt.
 * @param {module:UI~promptCallback} callback Once your handler has accepted a URL,
 *        it should pass it to `callback` so that the editor may link the
 *        selected text.
 */

/**
 * Exposes the core behavior for linking and unlinking text, and allows for
 * customization of the URL input handler.
 * @param {Editor} editor An editor instance to operate on. If a range is selected,
 *        either prompt for a URL and add a link or un-link the
 *        currently linked text.
 * @param {module:UI~showPrompt} [showPrompt] An optional custom input handler. Defaults
 *        to using `window.prompt`.
 * @example
 * let myPrompt = (message, defaultURL, promptCallback) => {
 *   let url = window.prompt("Overriding the defaults", "http://placekitten.com");
 *   promptCallback(url);
 * };
 *
 * editor.registerKeyCommand({
 *   str: "META+K",
 *   run(editor) {
 *     toggleLink(editor, myPrompt);
 *   }
 * });
 * @public
 */

let defaultShowPrompt = (message, defaultValue, callback) => callback(window.prompt(message, defaultValue));

function toggleLink(editor, showPrompt=defaultShowPrompt) {
  if (editor.range.isCollapsed) {
    return;
  }

  let selectedText = editor.cursor.selectedText();
  let defaultUrl = '';
  if (selectedText.indexOf('http') !== -1) { defaultUrl = selectedText; }

  let {range} = editor;
  let hasLink = editor.detectMarkupInRange(range, 'a');

  if (hasLink) {
    editor.toggleMarkup('a');
  } else {
    showPrompt('Enter a URL', defaultUrl, url => {
      if (!url) { return; }

      editor.toggleMarkup('a', {href: url});
    });
  }
}

function selectAll(editor) {
  let { post } = editor;
  editor.selectRange(post.toRange());
}

function gotoStartOfLine(editor) {
  let {range} = editor;
  let {tail: {section}} = range;
  editor.run(postEditor => {
    postEditor.setRange(section.headPosition());
  });
}

function gotoEndOfLine(editor) {
  let {range} = editor;
  let {tail: {section}} = range;
  editor.run(postEditor => {
    postEditor.setRange(section.tailPosition());
  });
}

function deleteToEndOfSection(editor) {
  let { range } = editor;
  if (range.isCollapsed) {
    let { head, head: { section } } = range;
    range = head.toRange(section.tailPosition());
  }
  editor.run(postEditor => {
    let nextPosition = postEditor.deleteRange(range);
    postEditor.setRange(nextPosition);
  });
}

const DEFAULT_KEY_COMMANDS = [{
  str: 'META+B',
  run(editor) {
    editor.toggleMarkup('strong');
  }
}, {
  str: 'CTRL+B',
  run(editor) {
    editor.toggleMarkup('strong');
  }
}, {
  str: 'META+I',
  run(editor) {
    editor.toggleMarkup('em');
  }
}, {
  str: 'CTRL+I',
  run(editor) {
    editor.toggleMarkup('em');
  }
}, {
  str: 'META+U',
  run(editor) {
    editor.toggleMarkup('u');
  }
}, {
  str: 'CTRL+U',
  run(editor) {
    editor.toggleMarkup('u');
  }
}, {
  str: 'CTRL+K',
  run(editor) {
    if (Browser.isMac()) {
      return deleteToEndOfSection(editor);
    } else if (Browser.isWin()) {
      return toggleLink(editor);
    }
  }
}, {
  str: 'CTRL+A',
  run(editor) {
    if (Browser.isMac()) {
      gotoStartOfLine(editor);
    } else {
      selectAll(editor);
    }
  }
}, {
  str: 'META+A',
  run(editor) {
    if (Browser.isMac()) {
      selectAll(editor);
    }
  }
}, {
  str: 'CTRL+E',
  run(editor) {
    if (Browser.isMac()) {
      gotoEndOfLine(editor);
    }
  }
}, {
  str: 'META+K',
  run(editor) {
    return toggleLink(editor);
  },

}, {
  str: 'META+Z',
  run(editor) {
    editor.run(postEditor => {
      postEditor.undoLastChange();
    });
  }
}, {
  str: 'META+SHIFT+Z',
  run(editor) {
    editor.run(postEditor => {
      postEditor.redoLastChange();
    });
  }
}, {
  str: 'CTRL+Z',
  run(editor) {
    if (Browser.isMac()) { return false; }
    editor.run(postEditor => postEditor.undoLastChange());
  }
}, {
  str: 'CTRL+SHIFT+Z',
  run(editor) {
    if (Browser.isMac()) { return false; }
    editor.run(postEditor => postEditor.redoLastChange());
  }
}];

function modifierNamesToMask(modiferNames) {
  let defaultVal = 0;
  return reduce(modiferNames,
                (sum, name) => {
                  let modifier = MODIFIERS[name.toUpperCase()];
                  mobiledocAssert(`No modifier named "${name}" found`, !!modifier);
                  return sum + modifier;
                },
                defaultVal);
}

function characterToCode(character) {
  const upperCharacter = character.toUpperCase();
  const special = specialCharacterToCode(upperCharacter);
  if (special) {
    return special;
  } else {
    mobiledocAssert(`Only 1 character can be used in a key command str (got "${character}")`,
           character.length === 1);
    return upperCharacter.charCodeAt(0);
  }
}

function buildKeyCommand(keyCommand) {
  let { str } = keyCommand;

  if (!str) {
    return keyCommand;
  }
  mobiledocAssert('[deprecation] Key commands no longer use the `modifier` property',
         !keyCommand.modifier);

  let [character, ...modifierNames] = str.split('+').reverse();

  keyCommand.modifierMask = modifierNamesToMask(modifierNames);
  keyCommand.code = characterToCode(character);

  return keyCommand;
}

function validateKeyCommand(keyCommand) {
  return !!keyCommand.code && !!keyCommand.run;
}

function findKeyCommands(keyCommands, keyEvent) {
  const key = Key.fromEvent(keyEvent);

  return filter(keyCommands, ({modifierMask, code}) => {
    return key.keyCode === code && key.modifierMask === modifierMask;
  });
}

const MUTATION = {
  NODES_CHANGED: 'childList',
  CHARACTER_DATA: 'characterData'
};

class MutationHandler {
  constructor(editor) {
    this.editor     = editor;
    this.logger     = editor.loggerFor('mutation-handler');
    this.renderTree = null;
    this._isObserving = false;

    this._observer = new MutationObserver((mutations) => {
      this._handleMutations(mutations);
    });
  }

  init() {
    this.startObserving();
  }

  destroy() {
    this.stopObserving();
    this._observer = null;
  }

  suspendObservation(callback) {
    this.stopObserving();
    callback();
    this.startObserving();
  }

  stopObserving() {
    if (this._isObserving) {
      this._isObserving = false;
      this._observer.disconnect();
    }
  }

  startObserving() {
    if (!this._isObserving) {
      let { editor } = this;
      mobiledocAssert('Cannot observe un-rendered editor', editor.hasRendered);

      this._isObserving = true;
      this.renderTree = editor._renderTree;

      this._observer.observe(editor.element, {
        characterData: true,
        childList: true,
        subtree: true
      });
    }
  }

  reparsePost() {
    this.editor._reparsePost();
  }

  reparseSections(sections) {
    this.editor._reparseSections(sections);
  }

  /**
   * for each mutation:
   *   * find the target nodes:
   *     * if nodes changed, target nodes are:
   *        * added nodes
   *        * the target from which removed nodes were removed
   *     * if character data changed
   *       * target node is the mutation event's target (text node)
   *     * filter out nodes that are no longer attached (parentNode is null)
   *   * for each remaining node:
   *   *  find its section, add to sections-to-reparse
   *   *  if no section, reparse all (and break)
   */
  _handleMutations(mutations) {
    let reparsePost = false;
    let sections = new Set();

    for (let i = 0; i < mutations.length; i++) {
      if (reparsePost) {
        break;
      }

      let nodes = this._findTargetNodes(mutations[i]);

      for (let j=0; j < nodes.length; j++) {
        let node = nodes[j];
        let renderNode = this._findRenderNodeFromNode(node);
        if (renderNode) {
          if (renderNode.reparsesMutationOfChildNode(node)) {
            let section = this._findSectionFromRenderNode(renderNode);
            if (section) {
              sections.add(section);
            } else {
              reparsePost = true;
            }
          }
        } else {
          reparsePost = true;
          break;
        }
      }
    }

    if (reparsePost) {
      this.logger.log(`reparsePost (${mutations.length} mutations)`);
      this.reparsePost();
    } else if (sections.length) {
      this.logger.log(`reparse ${sections.length} sections (${mutations.length} mutations)`);
      this.reparseSections(sections.toArray());
    }
  }

  _findTargetNodes(mutation) {
    let nodes = [];

    switch (mutation.type) {
      case MUTATION.CHARACTER_DATA:
        nodes.push(mutation.target);
        break;
      case MUTATION.NODES_CHANGED:
        forEach(mutation.addedNodes, n => nodes.push(n));
        if (mutation.removedNodes.length) {
          nodes.push(mutation.target);
        }
        break;
    }

    let element = this.editor.element;
    let attachedNodes = filter(nodes, node => containsNode(element, node));
    return attachedNodes;
  }

  _findSectionRenderNodeFromNode(node) {
    return this.renderTree.findRenderNodeFromElement(node, (rn) => {
      return rn.postNode.isSection;
    });
  }

  _findRenderNodeFromNode(node) {
    return this.renderTree.findRenderNodeFromElement(node);
  }

  _findSectionFromRenderNode(renderNode) {
    let sectionRenderNode = this._findSectionRenderNodeFromNode(renderNode.element);
    return sectionRenderNode && sectionRenderNode.postNode;
  }

}

class FixedQueue {
  constructor(length=0) {
    this._maxLength = length;
    this._items = [];
  }

  get length() {
    return this._items.length;
  }

  pop() {
    return this._items.pop();
  }

  push(item) {
    this._items.push(item);
    if (this.length > this._maxLength) {
      this._items.shift();
    }
  }

  clear() {
    this._items = [];
  }

  toArray() {
    return this._items;
  }
}

function findLeafSectionAtIndex(post, index) {
  let section;
  post.walkAllLeafSections((_section, _index) => {
    if (index === _index) {
      section = _section;
    }
  });
  return section;
}

class Snapshot {
  constructor(takenAt, editor, editAction=null) {
    this.mobiledoc = editor.serialize();
    this.editor = editor;
    this.editAction = editAction;
    this.takenAt = takenAt;

    this.snapshotRange();
  }

  snapshotRange() {
    let { range, cursor } = this.editor;
    if (cursor.hasCursor() && !range.isBlank) {
      let { head, tail } = range;
      this.range = {
        head: [head.leafSectionIndex, head.offset],
        tail: [tail.leafSectionIndex, tail.offset]
      };
    }
  }

  getRange(post) {
    if (this.range) {
      let { head, tail } = this.range;
      let [headLeafSectionIndex, headOffset] = head;
      let [tailLeafSectionIndex, tailOffset] = tail;
      let headSection = findLeafSectionAtIndex(post, headLeafSectionIndex);
      let tailSection = findLeafSectionAtIndex(post, tailLeafSectionIndex);

      head = headSection.toPosition(headOffset);
      tail = tailSection.toPosition(tailOffset);

      return head.toRange(tail);
    }
  }

  groupsWith(groupingTimeout, editAction, takenAt) {
    return (
      editAction !== null &&
      this.editAction === editAction &&
      this.takenAt + groupingTimeout > takenAt
    );
  }
}

class EditHistory {
  constructor(editor, queueLength, groupingTimeout) {
    this.editor = editor;
    this._undoStack = new FixedQueue(queueLength);
    this._redoStack = new FixedQueue(queueLength);

    this._pendingSnapshot = null;
    this._groupingTimeout = groupingTimeout;
  }

  snapshot() {
    // update the current snapshot with the range read from DOM
    if (this._pendingSnapshot) {
      this._pendingSnapshot.snapshotRange();
    }
  }

  storeSnapshot(editAction=null) {
    let now = Date.now();
    // store pending snapshot
    let pendingSnapshot = this._pendingSnapshot;
    if (pendingSnapshot) {
      if (!pendingSnapshot.groupsWith(this._groupingTimeout, editAction, now)) {
        this._undoStack.push(pendingSnapshot);
      }
      this._redoStack.clear();
    }

    // take new pending snapshot to store next time `storeSnapshot` is called
    this._pendingSnapshot = new Snapshot(now, this.editor, editAction);
  }

  stepBackward(postEditor) {
    // Throw away the pending snapshot
    this._pendingSnapshot = null;

    let snapshot = this._undoStack.pop();
    if (snapshot) {
      this._redoStack.push(new Snapshot(Date.now(), this.editor));
      this._restoreFromSnapshot(snapshot, postEditor);
    }
  }

  stepForward(postEditor) {
    let snapshot = this._redoStack.pop();
    if (snapshot) {
      this._undoStack.push(new Snapshot(Date.now(), this.editor));
      this._restoreFromSnapshot(snapshot, postEditor);
    }
    postEditor.cancelSnapshot();
  }

  _restoreFromSnapshot(snapshot, postEditor) {
    let { mobiledoc } = snapshot;
    let { editor } = this;
    let { builder, post } = editor;
    let restoredPost = mobiledocParsers.parse(builder, mobiledoc);

    postEditor.removeAllSections();
    postEditor.migrateSectionsFromPost(restoredPost);

    // resurrect snapshotted range if it exists
    let newRange = snapshot.getRange(post);
    if (newRange) {
      postEditor.setRange(newRange);
    }
  }
}

const UL_LI_REGEX = /^\* (.*)$/;
const OL_LI_REGEX = /^\d\.? (.*)$/;
const CR = '\r';
const LF = '\n';
const CR_REGEX = new RegExp(CR, 'g');
const CR_LF_REGEX = new RegExp(CR+LF, 'g');

const SECTION_BREAK = LF;

function normalizeLineEndings(text) {
  return text.replace(CR_LF_REGEX, LF)
             .replace(CR_REGEX, LF);
}

class TextParser {
  constructor(builder, options) {
    this.builder = builder;
    this.options = options;

    this.post = this.builder.createPost();
    this.prevSection = null;
  }

  /**
   * @param {String} text to parse
   * @return {Post} a post abstract
   */
  parse(text) {
    text = normalizeLineEndings(text);
    text.split(SECTION_BREAK).forEach(text => {
      let section = this._parseSection(text);
      this._appendSection(section);
    });

    return this.post;
  }

  _parseSection(text) {
    let tagName = DEFAULT_TAG_NAME,
        type    = MARKUP_SECTION_TYPE,
        section;

    if (UL_LI_REGEX.test(text)) {
      tagName = 'ul';
      type = LIST_SECTION_TYPE;
      text = text.match(UL_LI_REGEX)[1];
    } else if (OL_LI_REGEX.test(text)) {
      tagName = 'ol';
      type = LIST_SECTION_TYPE;
      text = text.match(OL_LI_REGEX)[1];
    }

    let markers = [this.builder.createMarker(text)];

    switch (type) {
      case LIST_SECTION_TYPE: {
        let item = this.builder.createListItem(markers);
        let list = this.builder.createListSection(tagName, [item]);
        section = list;
        break;
      }
      case MARKUP_SECTION_TYPE:
        section = this.builder.createMarkupSection(tagName, markers);
        break;
      default:
        mobiledocAssert(`Unknown type encountered ${type}`, false);
    }

    return section;
  }

  _appendSection(section) {
    let isSameListSection =
      section.isListSection &&
      this.prevSection && this.prevSection.isListSection &&
      this.prevSection.tagName === section.tagName;

    if (isSameListSection) {
      section.items.forEach(item => {
        this.prevSection.items.append(item.clone());
      });
    } else {
      this.post.sections.insertAfter(section, this.prevSection);
      this.prevSection = section;
    }
  }
}

/* global JSON */

const MIME_TEXT_PLAIN = 'text/plain';
const MIME_TEXT_HTML = 'text/html';
const NONSTANDARD_IE_TEXT_TYPE = 'Text';

const MOBILEDOC_REGEX = new RegExp(/data\-mobiledoc='(.*?)'>/);

/**
 * @return {Post}
 * @private
 */
function parsePostFromHTML(html, builder, plugins) {
  let post;

  if (MOBILEDOC_REGEX.test(html)) {
    let mobiledocString = html.match(MOBILEDOC_REGEX)[1];
    let mobiledoc = JSON.parse(mobiledocString);
    post = mobiledocParsers.parse(builder, mobiledoc);
  } else {
    post = new HTMLParser(builder, {plugins}).parse(html);
  }

  return post;
}

/**
 * @return {Post}
 * @private
 */
function parsePostFromText(text, builder, plugins) {
  let parser = new TextParser(builder, {plugins});
  let post = parser.parse(text);
  return post;
}

/**
 * @return {{html: String, text: String}}
 * @private
 */
function getContentFromPasteEvent(event, window) {
  let html = '', text = '';

  let { clipboardData } = event;

  if (clipboardData && clipboardData.getData) {
    html = clipboardData.getData(MIME_TEXT_HTML);
    text = clipboardData.getData(MIME_TEXT_PLAIN);
  } else if (window.clipboardData && window.clipboardData.getData) { // IE
    // The Internet Explorers (including Edge) have a non-standard way of interacting with the
    // Clipboard API (see http://caniuse.com/#feat=clipboard). In short, they expose a global window.clipboardData
    // object instead of the per-event event.clipboardData object on the other browsers.
    html = window.clipboardData.getData(NONSTANDARD_IE_TEXT_TYPE);
  }

  return { html, text };
}

/**
 * @return {{html: String, text: String}}
 * @private
 */
function getContentFromDropEvent(event, logger) {
  let html = '', text = '';

  try {
    html = event.dataTransfer.getData(MIME_TEXT_HTML);
    text = event.dataTransfer.getData(MIME_TEXT_PLAIN);
  } catch (e) {
    // FIXME IE11 does not include any data in the 'text/html' or 'text/plain'
    // mimetypes. It throws an error 'Invalid argument' when attempting to read
    // these properties.
    if (logger) {
      logger.log('Error getting drop data: ', e);
    }
  }

  return { html, text };
}

/**
 * @param {CopyEvent|CutEvent}
 * @param {Editor}
 * @param {Window}
 * @private
 */
function setClipboardData(event, {mobiledoc, html, text}, window) {
  if (mobiledoc && html) {
    html = `<div data-mobiledoc='${JSON.stringify(mobiledoc)}'>${html}</div>`;
  }

  let { clipboardData } = event;
  let { clipboardData: nonstandardClipboardData } = window;

  if (clipboardData && clipboardData.setData) {
    clipboardData.setData(MIME_TEXT_HTML, html);
    clipboardData.setData(MIME_TEXT_PLAIN, text);
  } else if (nonstandardClipboardData && nonstandardClipboardData.setData) {
    // The Internet Explorers (including Edge) have a non-standard way of interacting with the
    // Clipboard API (see http://caniuse.com/#feat=clipboard). In short, they expose a global window.clipboardData
    // object instead of the per-event event.clipboardData object on the other browsers.
    nonstandardClipboardData.setData(NONSTANDARD_IE_TEXT_TYPE, html);
  }
}

/**
 * @param {PasteEvent}
 * @param {{builder: Builder, _parserPlugins: Array}} options
 * @return {Post}
 * @private
 */
function parsePostFromPaste(pasteEvent, {builder, _parserPlugins: plugins}, {targetFormat}={targetFormat:'html'}) {
  let { html, text } = getContentFromPasteEvent(pasteEvent, window);

  if (targetFormat === 'html' && html && html.length) {
    return parsePostFromHTML(html, builder, plugins);
  } else if (text && text.length) {
    return parsePostFromText(text, builder, plugins);
  }
}

/**
 * @param {DropEvent}
 * @param {Editor} editor
 * @param {Object} [options={}] Can pass a logger
 * @return {Post}
 * @private
 */
function parsePostFromDrop(dropEvent, editor, {logger}={}) {
  let { builder, _parserPlugins: plugins } = editor;
  let { html, text } = getContentFromDropEvent(dropEvent, logger);

  if (html && html.length) {
    return parsePostFromHTML(html, builder, plugins);
  } else if (text && text.length) {
    return parsePostFromText(text, builder, plugins);
  }
}

class TextInputHandler {
  constructor(editor) {
    this.editor = editor;
    this._handlers = [];
  }

  register(handler) {
    mobiledocAssert(`Input Handler is not valid`, this._validateHandler(handler));
    this._handlers.push(handler);
  }

  unregister(name) {
    let handlers = this._handlers;
    for (let i=0; i<handlers.length; i++) {
      if (handlers[i].name === name) {
        handlers.splice(i, 1);
      }
    }
  }

  handle(string) {
    let { editor } = this;

    editor.insertText(string);

    let matchedHandler = this._findHandler();
    if (matchedHandler) {
      let [ handler, matches ] = matchedHandler;
      handler.run(editor, matches);
    }
  }

  handleNewLine() {
    let { editor } = this;

    let matchedHandler = this._findHandler(ENTER);
    if (matchedHandler) {
      let [ handler, matches ] = matchedHandler;
      handler.run(editor, matches);
    }
  }

  _findHandler(string = "") {
    let { editor: { range: { head, head: { section } } } } = this;
    let preText = section.textUntil(head) + string;

    for (let i=0; i < this._handlers.length; i++) {
      let handler = this._handlers[i];
      let {text, match} = handler;

      if (text && endsWith(preText, text)) {
        return [handler, [text]];
      } else if (match && match.test(preText)) {
        return [handler, match.exec(preText)];
      }
    }
  }

  _validateHandler(handler) {
    deprecate('Registered input handlers require a "name" property so that they can be unregistered', !!handler.name);
    return !!handler.run &&                        // has `run`
           (!!handler.text || !!handler.match) &&  // and `text` or `match`
           !(!!handler.text && !!handler.match);   // not both `text` and `match`
  }

  destroy() {
    this._handlers = [];
  }
}

let instance;

class SelectionChangeObserver {
  constructor() {
    this.started   = false;
    this.listeners  = [];
    this.selection = {};
  }

  static getInstance() {
    if (!instance) {
      instance = new SelectionChangeObserver();
    }
    return instance;
  }

  static addListener(listener) {
    SelectionChangeObserver.getInstance().addListener(listener);
  }

  addListener(listener) {
    if (this.listeners.indexOf(listener) === -1) {
      this.listeners.push(listener);
      this.start();
    }
  }

  static removeListener(listener) {
    SelectionChangeObserver.getInstance().removeListener(listener);
  }

  removeListener(listener) {
    let index = this.listeners.indexOf(listener);
    if (index !== -1) {
      this.listeners.splice(index, 1);
      if (this.listeners.length === 0) {
        this.stop();
      }
    }
  }

  start() {
    if (this.started) { return; }
    this.started = true;

    this.poll();
  }

  stop() {
    this.started = false;
    this.selection = {};
  }

  notifyListeners(/* newSelection, prevSelection */) {
    this.listeners.forEach(listener => {
      listener.selectionDidChange(...arguments);
    });
  }

  destroy() {
    this.stop();
    this.listeners = [];
  }

  getSelection() {
    let selection = window.getSelection();
    let { anchorNode, focusNode, anchorOffset, focusOffset } = selection;
    return { anchorNode, focusNode, anchorOffset, focusOffset };
  }

  poll() {
    if (this.started) {
      this.update();
      this.runNext(() => this.poll());
    }
  }

  runNext(fn) {
    window.requestAnimationFrame(fn);
  }

  update() {
    let prevSelection = this.selection;
    let curSelection = this.getSelection();
    if (!this.selectionIsEqual(prevSelection, curSelection)) {
      this.selection = curSelection;
      this.notifyListeners(curSelection, prevSelection);
    }
  }

  selectionIsEqual(s1, s2) {
    return s1.anchorNode === s2.anchorNode &&
      s1.anchorOffset === s2.anchorOffset &&
      s1.focusNode === s2.focusNode &&
      s1.focusOffset === s2.focusOffset;
  }
}

class SelectionManager {
  constructor(editor, callback) {
    this.editor   = editor;
    this.callback = callback;
    this.started  = false;
  }

  start() {
    if (this.started) { return; }

    SelectionChangeObserver.addListener(this);
    this.started = true;
  }

  stop() {
    this.started = false;
    SelectionChangeObserver.removeListener(this);
  }

  destroy() {
    this.stop();
  }

  selectionDidChange() {
    if (this.started) {
      this.callback(...arguments);
    }
  }
}

const ELEMENT_EVENT_TYPES = [
  'keydown', 'keyup', 'cut', 'copy', 'paste', 'keypress', 'drop'
];

class EventManager {
  constructor(editor) {
    this.editor = editor;
    this.logger = editor.loggerFor('event-manager');
    this._textInputHandler = new TextInputHandler(editor);
    this._listeners = [];
    this.modifierKeys = {
      shift: false
    };

    this._selectionManager = new SelectionManager(
      this.editor, this.selectionDidChange.bind(this));
    this.started = true;
  }

  init() {
    let { editor: { element } } = this;
    mobiledocAssert(`Cannot init EventManager without element`, !!element);

    ELEMENT_EVENT_TYPES.forEach(type => {
      this._addListener(element, type);
    });

    this._selectionManager.start();
  }

  start() {
    this.started = true;
  }

  stop() {
    this.started = false;
  }

  registerInputHandler(inputHandler) {
    this._textInputHandler.register(inputHandler);
  }

  unregisterInputHandler(name) {
    this._textInputHandler.unregister(name);
  }

  unregisterAllTextInputHandlers() {
    this._textInputHandler.destroy();
    this._textInputHandler = new TextInputHandler(this.editor);
  }

  _addListener(context, type) {
    mobiledocAssert(`Missing listener for ${type}`, !!this[type]);

    let listener = (event) => this._handleEvent(type, event);
    context.addEventListener(type, listener);
    this._listeners.push([context, type, listener]);
  }

  _removeListeners() {
    this._listeners.forEach(([context, type, listener]) => {
      context.removeEventListener(type, listener);
    });
    this._listeners = [];
  }

  // This is primarily useful for programmatically simulating events on the
  // editor from the tests.
  _trigger(context, type, event) {
    forEach(
      filter(this._listeners, ([_context, _type]) => {
        return _context === context && _type === type;
      }),
      ([context,, listener]) => {
        listener.call(context, event);
      }
    );
  }

  destroy() {
    this._textInputHandler.destroy();
    this._selectionManager.destroy();
    this._removeListeners();
  }

  _handleEvent(type, event) {
    let {target: element} = event;
    if (!this.started) {
      // abort handling this event
      return true;
    }

    if (!this.isElementAddressable(element)) {
      // abort handling this event
      return true;
    }

    this[type](event);
  }

  isElementAddressable(element) {
    return this.editor.cursor.isAddressable(element);
  }

  selectionDidChange(selection /*, prevSelection */) {
    let shouldNotify = true;
    let { anchorNode } = selection;
    if (!this.isElementAddressable(anchorNode)) {
      if (!this.editor.range.isBlank) {
        // Selection changed from something addressable to something
        // not-addressable -- e.g., blur event, user clicked outside editor,
        // etc
        shouldNotify = true;
      } else {
        // selection changes wholly outside the editor should not trigger
        // change notifications
        shouldNotify = false;
      }
    }

    if (shouldNotify) {
      this.editor._readRangeFromDOM();
    }
  }

  keypress(event) {
    let { editor, _textInputHandler } = this;
    if (!editor.hasCursor()) { return; }

    let key = Key.fromEvent(event);
    if (!key.isPrintable()) {
      return;
    } else {
      event.preventDefault();
    }

    _textInputHandler.handle(key.toString());
  }

  keydown(event) {
    let { editor } = this;
    if (!editor.hasCursor()) { return; }
    if (!editor.isEditable) { return; }

    let key = Key.fromEvent(event);
    this._updateModifiersFromKey(key, {isDown:true});

    if (editor.handleKeyCommand(event)) { return; }

    if (editor.post.isBlank) {
      editor._insertEmptyMarkupSectionAtCursor();
    }

    let range = editor.range;

    switch(true) {
      // FIXME This should be restricted to only card/atom boundaries
      case key.isHorizontalArrowWithoutModifiersOtherThanShift(): {
        let newRange;
        if (key.isShift()) {
          newRange = range.extend(key.direction * 1);
        } else {
          newRange = range.move(key.direction);
        }

        editor.selectRange(newRange);
        event.preventDefault();
        break;
      }
      case key.isDelete(): {
        let { direction } = key;
        let unit = 'char';
        if (key.altKey && Browser.isMac()) {
          unit = 'word';
        } else if (key.ctrlKey && !Browser.isMac()) {
          unit = 'word';
        }
        editor.performDelete({direction, unit});
        event.preventDefault();
        break;
      }
      case key.isEnter():
        this._textInputHandler.handleNewLine();
        editor.handleNewline(event);
        break;
      case key.isTab():
        // Handle tab here because it does not fire a `keypress` event
        event.preventDefault();
        this._textInputHandler.handle(key.toString());
        break;
    }
  }

  keyup(event) {
    let { editor } = this;
    if (!editor.hasCursor()) { return; }
    let key = Key.fromEvent(event);
    this._updateModifiersFromKey(key, {isDown:false});
  }

  cut(event) {
    event.preventDefault();

    this.copy(event);
    this.editor.performDelete();
  }

  copy(event) {
    event.preventDefault();

    let { editor, editor: { range, post } } = this;
    post = post.trimTo(range);

    let data = {
      html: editor.serializePost(post, 'html'),
      text: editor.serializePost(post, 'text'),
      mobiledoc: editor.serializePost(post, 'mobiledoc')
    };

    setClipboardData(event, data, window);
  }

  paste(event) {
    event.preventDefault();

    let { editor } = this;
    let range = editor.range;

    if (!range.isCollapsed) {
      editor.performDelete();
    }

    if (editor.post.isBlank) {
      editor._insertEmptyMarkupSectionAtCursor();
    }

    let position = editor.range.head;
    let targetFormat = this.modifierKeys.shift ? 'text' : 'html';
    let pastedPost = parsePostFromPaste(event, editor, {targetFormat});

    editor.run(postEditor => {
      let nextPosition = postEditor.insertPost(position, pastedPost);
      postEditor.setRange(nextPosition);
    });
  }

  drop(event) {
    event.preventDefault();

    let { clientX: x, clientY: y } = event;
    let { editor } = this;

    let position = editor.positionAtPoint(x, y);
    if (!position) {
      this.logger.log('Could not find drop position');
      return;
    }

    let post = parsePostFromDrop(event, editor, {logger: this.logger});
    if (!post) {
      this.logger.log('Could not determine post from drop event');
      return;
    }

    editor.run(postEditor => {
      let nextPosition = postEditor.insertPost(position, post);
      postEditor.setRange(nextPosition);
    });
  }

  _updateModifiersFromKey(key, {isDown}) {
    if (key.isShiftKey()) {
      this.modifierKeys.shift = isDown;
    }
  }

}

/**
 * Used by {@link Editor} to manage its current state (cursor, active markups
 * and active sections).
 * @private
 */
class EditState {
  constructor(editor) {
    this.editor = editor;

    let defaultState = {
      range: Range.blankRange(),
      activeMarkups: [],
      activeSections: [],
      activeSectionTagNames: [],
      activeSectionAttributes: {}
    };

    this.prevState = this.state = defaultState;
  }

  updateRange(newRange) {
    this.prevState = this.state;
    this.state = this._readState(newRange);
  }

  destroy() {
    this.editor = null;
    this.prevState = this.state = null;
  }

  /**
   * @return {Boolean}
   */
  rangeDidChange() {
    let { state: { range } , prevState: {range: prevRange} } = this;

    return !prevRange.isEqual(range);
  }

  /**
   * @return {Boolean} Whether the input mode (active markups or active section tag names)
   * has changed.
   */
  inputModeDidChange() {
    let { state, prevState } = this;
    return (!isArrayEqual(state.activeMarkups, prevState.activeMarkups) ||
            !isArrayEqual(state.activeSectionTagNames, prevState.activeSectionTagNames) ||
            !isArrayEqual(objectToSortedKVArray(state.activeSectionAttributes), objectToSortedKVArray(prevState.activeSectionAttributes)));
  }

  /**
   * @return {Range}
   */
  get range() {
    return this.state.range;
  }

  /**
   * @return {Section[]}
   */
  get activeSections() {
    return this.state.activeSections;
  }


  /**
   * @return {Object}
   */
  get activeSectionAttributes() {
    return this.state.activeSectionAttributes;
  }

  /**
   * @return {Markup[]}
   */
  get activeMarkups() {
    return this.state.activeMarkups;
  }

  /**
   * Update the editor's markup state. This is used when, e.g.,
   * a user types meta+B when the editor has a cursor but no selected text;
   * in this case the editor needs to track that it has an active "b" markup
   * and apply it to the next text the user types.
   */
  toggleMarkupState(markup) {
    if (contains(this.activeMarkups, markup)) {
      this._removeActiveMarkup(markup);
    } else {
      this._addActiveMarkup(markup);
    }
  }

  _readState(range) {
    let state = {
      range,
      activeMarkups:  this._readActiveMarkups(range),
      activeSections: this._readActiveSections(range)
    };
    // Section objects are 'live', so to check that they changed, we
    // need to map their tagNames now (and compare to mapped tagNames later).
    // In addition, to catch changes from ul -> ol, we keep track of the
    // un-nested tag names (otherwise we'd only see li -> li change)
    state.activeSectionTagNames = state.activeSections.map(s => {
      return s.isNested ? s.parent.tagName : s.tagName;
    });
    state.activeSectionAttributes = this._readSectionAttributes(state.activeSections);
    return state;
  }

  _readActiveSections(range) {
    let { head, tail } = range;
    let { editor: { post } } = this;
    if (range.isBlank) {
      return [];
    } else {
      return post.sections.readRange(head.section, tail.section);
    }
  }

  _readActiveMarkups(range) {
    let { editor: { post } } = this;
    return post.markupsInRange(range);
  }

  _readSectionAttributes(sections) {
    return sections.reduce((sectionAttributes, s) => {
      let attributes = s.isNested ? s.parent.attributes : s.attributes;
      Object.keys(attributes || {}).forEach(attrName => {
        let camelizedAttrName = attrName.replace(/^data-md-/, '');
        let attrValue = attributes[attrName];
        sectionAttributes[camelizedAttrName] = sectionAttributes[camelizedAttrName] || [];
        if (!contains(sectionAttributes[camelizedAttrName], attrValue)) {
          sectionAttributes[camelizedAttrName].push(attrValue);
        }
      });
      return sectionAttributes;
    }, {});
  }

  _removeActiveMarkup(markup) {
    let index = this.state.activeMarkups.indexOf(markup);
    this.state.activeMarkups.splice(index, 1);
  }

  _addActiveMarkup(markup) {
    this.state.activeMarkups.push(markup);
  }
}

function addHTMLSpaces(text) {
  let nbsp = '\u00A0';
  return text.replace(/  /g, ' ' + nbsp);
}

function createTextNode(dom, text) {
  return dom.createTextNode(addHTMLSpaces(text));
}

function normalizeTagName$1(tagName) {
  return tagName.toLowerCase();
}

var RENDER_TYPE = 'dom';

var ImageCard$1 = {
  name: 'image',
  type: RENDER_TYPE,
  render({payload, env: {dom}}) {
    let img = dom.createElement('img');
    img.src = payload.src;
    return img;
  }
};

const MARKUP_SECTION_TYPE$1 = 1;
const IMAGE_SECTION_TYPE$1 = 2;
const LIST_SECTION_TYPE$1 = 3;
const CARD_SECTION_TYPE = 10;

const MARKUP_SECTION_TAG_NAMES = [
  'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pull-quote', 'aside'
].map(normalizeTagName$1);

const MARKUP_SECTION_ELEMENT_NAMES$1 = [
  'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'aside'
].map(normalizeTagName$1);

const LIST_SECTION_TAG_NAMES = [
  'ul', 'ol'
].map(normalizeTagName$1);

const MARKUP_TYPES = [
  'b', 'i', 'strong', 'em', 'a', 'u', 'sub', 'sup', 's', 'code'
].map(normalizeTagName$1);

function contains$1(array, item) {
  return array.indexOf(item) !== -1;
}

function isValidSectionTagName(tagName, sectionType) {
  tagName = normalizeTagName$1(tagName);

  switch (sectionType) {
    case MARKUP_SECTION_TYPE$1:
      return contains$1(MARKUP_SECTION_TAG_NAMES, tagName);
    case LIST_SECTION_TYPE$1:
      return contains$1(LIST_SECTION_TAG_NAMES, tagName);
    default:
      throw new Error(`Cannot validate tagName for unknown section type "${sectionType}"`);
  }
}

function isMarkupSectionElementName(tagName) {
  tagName = normalizeTagName$1(tagName);
  return contains$1(MARKUP_SECTION_ELEMENT_NAMES$1, tagName);
}

function isValidMarkerType(type) {
  type = normalizeTagName$1(type);
  return contains$1(MARKUP_TYPES, type);
}

function includes(array, detectValue) {
  for (let i=0;i < array.length;i++) {
    let value = array[i];
    if (value === detectValue) {
      return true;
    }
  }
  return false;
}

const PROTOCOL_REGEXP = /^([a-z0-9.+-]+:)/i;

const badProtocols = [
  'javascript:', // jshint ignore:line
  'vbscript:' // jshint ignore:line
];

function getProtocol(url) {
  let matches = url && url.match(PROTOCOL_REGEXP);
  let protocol = (matches && matches[0]) || ':';
  return protocol;
}

function sanitizeHref(url) {
  let protocol = getProtocol(url).toLowerCase();
  if (includes(badProtocols, protocol)) {
    return `unsafe:${url}`;
  }
  return url;
}

/**
 * @param attributes array
 * @return obj with normalized attribute names (lowercased)
 */
function reduceAttributes(attributes) {
  let obj = {};
  for (let i = 0; i < attributes.length; i += 2) {
    let key = attributes[i];
    let val = attributes[i+1];
    obj[key.toLowerCase()] = val;
  }
  return obj;
}

const VALID_ATTRIBUTES$2 = [
  'data-md-text-align'
];

function _isValidAttribute(attr) {
  return VALID_ATTRIBUTES$2.indexOf(attr) !== -1;
}

function handleMarkupSectionAttribute(element, attributeKey, attributeValue) {
  if (!_isValidAttribute(attributeKey)) {
    throw new Error(`Cannot use attribute: ${attributeKey}`);
  }

  element.setAttribute(attributeKey, attributeValue);
}

function defaultSectionElementRenderer(tagName, dom, attrsObj = {}) {
  let element;
  if (isMarkupSectionElementName(tagName)) {
    element = dom.createElement(tagName);

    Object.keys(attrsObj).forEach(k => {
      handleMarkupSectionAttribute(element, k, attrsObj[k]);
    });
  } else {
    element = dom.createElement('div');
    element.setAttribute('class', tagName);
  }

  return element;
}

function sanitizeAttribute(tagName, attrName, attrValue) {
  if (tagName === 'a' && attrName === 'href') {
    return sanitizeHref(attrValue);
  } else {
    return attrValue;
  }
}

function defaultMarkupElementRenderer(tagName, dom, attrsObj) {
  let element = dom.createElement(tagName);
  Object.keys(attrsObj).forEach(attrName => {
    let attrValue = attrsObj[attrName];
    attrValue = sanitizeAttribute(tagName, attrName, attrValue);
    element.setAttribute(attrName, attrValue);
  });
  return element;
}

const MOBILEDOC_VERSION$5 = '0.2.0';

const IMAGE_SECTION_TAG_NAME = 'img';

function validateVersion(version) {
  if (version !== MOBILEDOC_VERSION$5) {
    throw new Error(`Unexpected Mobiledoc version "${version}"`);
  }
}

class Renderer$1 {
  constructor(mobiledoc, options) {
    let {
      cards,
      cardOptions,
      unknownCardHandler,
      markupElementRenderer,
      sectionElementRenderer,
      dom
    } = options;
    let {
      version,
      sections: sectionData
    } = mobiledoc;
    validateVersion(version);

    const [markerTypes, sections] = sectionData;

    this.dom                = dom;
    this.root               = dom.createDocumentFragment();
    this.markerTypes        = markerTypes;
    this.sections           = sections;
    this.cards              = cards;
    this.cardOptions        = cardOptions;
    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;

    this.sectionElementRenderer = {
      '__default__': defaultSectionElementRenderer
    };
    Object.keys(sectionElementRenderer).forEach(key => {
      this.sectionElementRenderer[key.toLowerCase()] = sectionElementRenderer[key];
    });

    this.markupElementRenderer = {
      '__default__': defaultMarkupElementRenderer
    };
    Object.keys(markupElementRenderer).forEach(key => {
      this.markupElementRenderer[key.toLowerCase()] = markupElementRenderer[key];
    });

    this._renderCallbacks    = [];
    this._teardownCallbacks  = [];
    this._renderedChildNodes = [];
  }

  get _defaultUnknownCardHandler() {
    return ({env: {name}}) => {
      throw new Error(`Card "${name}" not found but no unknownCardHandler was registered`);
    };
  }

  render() {
    this.sections.forEach(section => {
      let rendered = this.renderSection(section);
      if (rendered) {
        this.root.appendChild(rendered);
      }
    });
    for (let i = 0; i < this._renderCallbacks.length; i++) {
      this._renderCallbacks[i]();
    }
    // maintain a reference to child nodes so they can be cleaned up later by teardown
    this._renderedChildNodes = [];
    let node = this.root.firstChild;
    while (node) {
      this._renderedChildNodes.push(node);
      node = node.nextSibling;
    }
    return { result: this.root, teardown: () => this.teardown() };
  }

  teardown() {
    for (let i=0; i < this._teardownCallbacks.length; i++) {
      this._teardownCallbacks[i]();
    }
    for (let i=0; i < this._renderedChildNodes.length; i++) {
      let node = this._renderedChildNodes[i];
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }

  renderSection(section) {
    const [type] = section;
    switch (type) {
      case MARKUP_SECTION_TYPE$1:
        return this.renderMarkupSection(section);
      case IMAGE_SECTION_TYPE$1:
        return this.renderImageSection(section);
      case LIST_SECTION_TYPE$1:
        return this.renderListSection(section);
      case CARD_SECTION_TYPE:
        return this.renderCardSection(section);
      default:
        throw new Error(`Cannot render mobiledoc section of type "${type}"`);
    }
  }

  renderMarkersOnElement(element, markers) {
    let elements = [element];
    let currentElement = element;

    let pushElement = (openedElement) => {
      currentElement.appendChild(openedElement);
      elements.push(openedElement);
      currentElement = openedElement;
    };

    for (let i=0, l=markers.length; i<l; i++) {
      let marker = markers[i];
      let [openTypes, closeCount, text] = marker;

      for (let j=0, m=openTypes.length; j<m; j++) {
        let markerType = this.markerTypes[openTypes[j]];
        let [tagName, attrs=[]] = markerType;
        if (isValidMarkerType(tagName)) {
          pushElement(this.renderMarkupElement(tagName, attrs));
        } else {
          closeCount--;
        }
      }

      currentElement.appendChild(createTextNode(this.dom, text));

      for (let j=0, m=closeCount; j<m; j++) {
        elements.pop();
        currentElement = elements[elements.length - 1];
      }
    }
  }

  /**
   * @param attrs Array
   */
  renderMarkupElement(tagName, attrs) {
    tagName = tagName.toLowerCase();
    attrs   = reduceAttributes(attrs);

    let renderer = this.markupElementRendererFor(tagName);
    return renderer(tagName, this.dom, attrs);
  }

  markupElementRendererFor(tagName) {
    return this.markupElementRenderer[tagName] ||
      this.markupElementRenderer.__default__;
  }

  renderListItem(markers) {
    const element = this.dom.createElement('li');
    this.renderMarkersOnElement(element, markers);
    return element;
  }

  renderListSection([type, tagName, listItems]) {
    if (!isValidSectionTagName(tagName, LIST_SECTION_TYPE$1)) {
      return;
    }
    const element = this.dom.createElement(tagName);
    listItems.forEach(li => {
      element.appendChild(this.renderListItem(li));
    });
    return element;
  }

  renderImageSection([type, src]) {
    let element = this.dom.createElement(IMAGE_SECTION_TAG_NAME);
    element.src = src;
    return element;
  }

  findCard(name) {
    for (let i=0; i < this.cards.length; i++) {
      if (this.cards[i].name === name) {
        return this.cards[i];
      }
    }
    if (name === ImageCard$1.name) {
      return ImageCard$1;
    }
    return this._createUnknownCard(name);
  }

  _createUnknownCard(name) {
    return {
      name,
      type: RENDER_TYPE,
      render: this.unknownCardHandler
    };
  }

  _createCardArgument(card, payload={}) {
    let env = {
      name: card.name,
      isInEditor: false,
      dom: this.dom,
      didRender: (callback) => this._registerRenderCallback(callback),
      onTeardown: (callback) => this._registerTeardownCallback(callback)
    };

    let options = this.cardOptions;

    return { env, options, payload };
  }

  _registerRenderCallback(callback) {
    this._renderCallbacks.push(callback);
  }

  _registerTeardownCallback(callback) {
    this._teardownCallbacks.push(callback);
  }

  renderCardSection([type, name, payload]) {
    let card = this.findCard(name);

    let cardArg = this._createCardArgument(card, payload);
    let rendered = card.render(cardArg);

    this._validateCardRender(rendered, card.name);

    return rendered;
  }

  _validateCardRender(rendered, cardName) {
    if (!rendered) {
      return;
    }

    if (typeof rendered !== 'object') {
      throw new Error(`Card "${cardName}" must render ${RENDER_TYPE}, but result was "${rendered}"`);
    }
  }

  renderMarkupSection([type, tagName, markers]) {
    tagName = tagName.toLowerCase();
    if (!isValidSectionTagName(tagName, MARKUP_SECTION_TYPE$1)) {
      return;
    }

    let renderer = this.sectionElementRendererFor(tagName);
    let element = renderer(tagName, this.dom);

    this.renderMarkersOnElement(element, markers);
    return element;
  }

  sectionElementRendererFor(tagName) {
    return this.sectionElementRenderer[tagName] ||
      this.sectionElementRenderer.__default__;
  }
}

const MARKUP_MARKER_TYPE = 0;
const ATOM_MARKER_TYPE = 1;

const MOBILEDOC_VERSION_0_3_0 = '0.3.0';
const MOBILEDOC_VERSION_0_3_1 = '0.3.1';
const MOBILEDOC_VERSION_0_3_2 = '0.3.2';

const IMAGE_SECTION_TAG_NAME$1 = 'img';

function validateVersion$1(version) {
  switch (version) {
    case MOBILEDOC_VERSION_0_3_0:
    case MOBILEDOC_VERSION_0_3_1:
    case MOBILEDOC_VERSION_0_3_2:
      return;
    default:
      throw new Error(`Unexpected Mobiledoc version "${version}"`);
  }
}

class Renderer$2 {
  constructor(mobiledoc, state) {

    let {
      cards,
      cardOptions,
      atoms,
      unknownCardHandler,
      unknownAtomHandler,
      markupElementRenderer,
      sectionElementRenderer,
      dom
    } = state;
    let {
      version,
      sections,
      atoms: atomTypes,
      cards: cardTypes,
      markups: markerTypes
    } = mobiledoc;
    validateVersion$1(version);

    this.dom                = dom;
    this.root               = this.dom.createDocumentFragment();
    this.sections           = sections;
    this.atomTypes          = atomTypes;
    this.cardTypes          = cardTypes;
    this.markerTypes        = markerTypes;
    this.cards              = cards;
    this.atoms              = atoms;
    this.cardOptions        = cardOptions;
    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;
    this.unknownAtomHandler = unknownAtomHandler || this._defaultUnknownAtomHandler;

    this.sectionElementRenderer = {
      '__default__': defaultSectionElementRenderer
    };
    Object.keys(sectionElementRenderer).forEach(key => {
      this.sectionElementRenderer[key.toLowerCase()] = sectionElementRenderer[key];
    });

    this.markupElementRenderer = {
      '__default__': defaultMarkupElementRenderer
    };
    Object.keys(markupElementRenderer).forEach(key => {
      this.markupElementRenderer[key.toLowerCase()] = markupElementRenderer[key];
    });

    this._renderCallbacks = [];
    this._teardownCallbacks  = [];
  }

  get _defaultUnknownCardHandler() {
    return ({env: {name}}) => {
      throw new Error(`Card "${name}" not found but no unknownCardHandler was registered`);
    };
  }

  get _defaultUnknownAtomHandler() {
    return ({env: {name}}) => {
      throw new Error(`Atom "${name}" not found but no unknownAtomHandler was registered`);
    };
  }

  render() {
    this.sections.forEach(section => {
      let rendered = this.renderSection(section);
      if (rendered) {
        this.root.appendChild(rendered);
      }
    });
    for (let i=0; i < this._renderCallbacks.length; i++) {
      this._renderCallbacks[i]();
    }
    // maintain a reference to child nodes so they can be cleaned up later by teardown
    this._renderedChildNodes = Array.prototype.slice.call(this.root.childNodes);
    return { result: this.root, teardown: () => this.teardown() };
  }

  teardown() {
    for (let i=0; i < this._teardownCallbacks.length; i++) {
      this._teardownCallbacks[i]();
    }
    for (let i=0; i < this._renderedChildNodes.length; i++) {
      let node = this._renderedChildNodes[i];
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
  }

  renderSection(section) {
    const [type] = section;
    switch (type) {
      case MARKUP_SECTION_TYPE$1:
        return this.renderMarkupSection(section);
      case IMAGE_SECTION_TYPE$1:
        return this.renderImageSection(section);
      case LIST_SECTION_TYPE$1:
        return this.renderListSection(section);
      case CARD_SECTION_TYPE:
        return this.renderCardSection(section);
      default:
        throw new Error(`Cannot render mobiledoc section of type "${type}"`);
    }
  }

  renderMarkersOnElement(element, markers) {
    let elements = [element];
    let currentElement = element;

    let pushElement = (openedElement) => {
      currentElement.appendChild(openedElement);
      elements.push(openedElement);
      currentElement = openedElement;
    };

    for (let i=0, l=markers.length; i<l; i++) {
      let marker = markers[i];
      let [type, openTypes, closeCount, value] = marker;

      for (let j=0, m=openTypes.length; j<m; j++) {
        let markerType = this.markerTypes[openTypes[j]];
        let [tagName, attrs=[]] = markerType;

        if (isValidMarkerType(tagName)) {
          pushElement(this.renderMarkupElement(tagName, attrs));
        } else {
          closeCount--;
        }
      }

      switch (type) {
        case MARKUP_MARKER_TYPE:
          currentElement.appendChild(createTextNode(this.dom, value));
          break;
        case ATOM_MARKER_TYPE:
          currentElement.appendChild(this._renderAtom(value));
          break;
        default:
          throw new Error(`Unknown markup type (${type})`);
      }

      for (let j=0, m=closeCount; j<m; j++) {
        elements.pop();
        currentElement = elements[elements.length - 1];
      }
    }
  }

  /**
   * @param attrs Array
   */
  renderMarkupElement(tagName, attrs) {
    tagName = tagName.toLowerCase();
    attrs   = reduceAttributes(attrs);

    let renderer = this.markupElementRendererFor(tagName);
    return renderer(tagName, this.dom, attrs);
  }

  markupElementRendererFor(tagName) {
    return this.markupElementRenderer[tagName] ||
      this.markupElementRenderer.__default__;
  }

  renderListItem(markers) {
    const element = this.dom.createElement('li');
    this.renderMarkersOnElement(element, markers);
    return element;
  }

  renderListSection([type, tagName, listItems]) {
    if (!isValidSectionTagName(tagName, LIST_SECTION_TYPE$1)) {
      return;
    }
    const element = this.dom.createElement(tagName);
    listItems.forEach(li => {
      element.appendChild(this.renderListItem(li));
    });
    return element;
  }

  renderImageSection([type, src]) {
    let element = this.dom.createElement(IMAGE_SECTION_TAG_NAME$1);
    element.src = src;
    return element;
  }

  findCard(name) {
    for (let i=0; i < this.cards.length; i++) {
      if (this.cards[i].name === name) {
        return this.cards[i];
      }
    }
    if (name === ImageCard$1.name) {
      return ImageCard$1;
    }
    return this._createUnknownCard(name);
  }

  _findCardByIndex(index) {
    let cardType = this.cardTypes[index];
    if (!cardType) {
      throw new Error(`No card definition found at index ${index}`);
    }

    let [ name, payload ] = cardType;
    let card = this.findCard(name);

    return {
      card,
      payload
    };
  }

  _createUnknownCard(name) {
    return {
      name,
      type: RENDER_TYPE,
      render: this.unknownCardHandler
    };
  }

  _createCardArgument(card, payload={}) {
    let env = {
      name: card.name,
      isInEditor: false,
      dom: this.dom,
      didRender: (callback) => this._registerRenderCallback(callback),
      onTeardown: (callback) => this._registerTeardownCallback(callback)
    };

    let options = this.cardOptions;

    return { env, options, payload };
  }

  _registerTeardownCallback(callback) {
    this._teardownCallbacks.push(callback);
  }

  _registerRenderCallback(callback) {
    this._renderCallbacks.push(callback);
  }

  renderCardSection([type, index]) {
    let { card, payload } = this._findCardByIndex(index);

    let cardArg = this._createCardArgument(card, payload);
    let rendered = card.render(cardArg);

    this._validateCardRender(rendered, card.name);

    return rendered;
  }

  _validateCardRender(rendered, cardName) {
    if (!rendered) {
      return;
    }

    if (typeof rendered !== 'object') {
      throw new Error(`Card "${cardName}" must render ${RENDER_TYPE}, but result was "${rendered}"`);
    }
  }

  findAtom(name) {
    for (let i=0; i < this.atoms.length; i++) {
      if (this.atoms[i].name === name) {
        return this.atoms[i];
      }
    }
    return this._createUnknownAtom(name);
  }

  _createUnknownAtom(name) {
    return {
      name,
      type: RENDER_TYPE,
      render: this.unknownAtomHandler
    };
  }

  _createAtomArgument(atom, value, payload) {
    let env = {
      name: atom.name,
      isInEditor: false,
      dom: this.dom,
      onTeardown: (callback) => this._registerTeardownCallback(callback)
    };

    let options = this.cardOptions;

    return { env, options, value, payload };
  }

  _validateAtomRender(rendered, atomName) {
    if (!rendered) {
      return;
    }

    if (typeof rendered !== 'object') {
      throw new Error(`Atom "${atomName}" must render ${RENDER_TYPE}, but result was "${rendered}"`);
    }
  }

  _findAtomByIndex(index) {
    let atomType = this.atomTypes[index];
    if (!atomType) {
      throw new Error(`No atom definition found at index ${index}`);
    }

    let [ name, value, payload ] = atomType;
    let atom = this.findAtom(name);

    return {
      atom,
      value,
      payload
    };
  }

  _renderAtom(index) {
    let { atom, value, payload } = this._findAtomByIndex(index);

    let atomArg = this._createAtomArgument(atom, value, payload);
    let rendered = atom.render(atomArg);

    this._validateAtomRender(rendered, atom.name);

    return rendered || createTextNode(this.dom, '');
  }

  renderMarkupSection([type, tagName, markers, attributes = []]) {
    tagName = tagName.toLowerCase();
    if (!isValidSectionTagName(tagName, MARKUP_SECTION_TYPE$1)) {
      return;
    }

    let attrsObj = reduceAttributes(attributes);
    let renderer = this.sectionElementRendererFor(tagName);
    let element = renderer(tagName, this.dom, attrsObj);

    this.renderMarkersOnElement(element, markers);
    return element;
  }

  sectionElementRendererFor(tagName) {
    return this.sectionElementRenderer[tagName] ||
      this.sectionElementRenderer.__default__;
  }
}

/**
 * runtime DOM renderer
 * renders a mobiledoc to DOM
 *
 * input: mobiledoc
 * output: DOM
 */

 function validateCards$1(cards) {
   if (!Array.isArray(cards)) {
     throw new Error('`cards` must be passed as an array');
   }
   for (let i=0; i < cards.length; i++) {
     let card = cards[i];
     if (card.type !== RENDER_TYPE) {
       throw new Error(`Card "${card.name}" must be of type "${RENDER_TYPE}", was "${card.type}"`);
     }
     if (!card.render) {
       throw new Error(`Card "${card.name}" must define \`render\``);
     }
   }
 }

 function validateAtoms$1(atoms) {
   if (!Array.isArray(atoms)) {
     throw new Error('`atoms` must be passed as an array');
   }
   for (let i=0; i < atoms.length; i++) {
     let atom = atoms[i];
     if (atom.type !== RENDER_TYPE) {
       throw new Error(`Atom "${atom.name}" must be type "${RENDER_TYPE}", was "${atom.type}"`);
     }
     if (!atom.render) {
       throw new Error(`Atom "${atom.name}" must define \`render\``);
     }
   }
 }

 class RendererFactory {
   constructor({
     cards=[],
     atoms=[],
     cardOptions={},
     unknownCardHandler,
     unknownAtomHandler,
     markupElementRenderer={},
     sectionElementRenderer={},
     dom,
     markupSanitizer=null
   }={}) {
     validateCards$1(cards);
     validateAtoms$1(atoms);

     if (!dom) {
       if (typeof window === 'undefined') {
         throw new Error('A `dom` option must be provided to the renderer when running without window.document');
       }
       dom = window.document;
     }

     this.options = {
       cards,
       atoms,
       cardOptions,
       unknownCardHandler,
       unknownAtomHandler,
       markupElementRenderer,
       sectionElementRenderer,
       dom,
       markupSanitizer
     };
   }

   render(mobiledoc) {
     let { version } = mobiledoc;
     switch (version) {
       case MOBILEDOC_VERSION$5:
       case undefined:
       case null:
         return new Renderer$1(mobiledoc, this.options).render();
       case MOBILEDOC_VERSION_0_3_0:
       case MOBILEDOC_VERSION_0_3_1:
       case MOBILEDOC_VERSION_0_3_2:
         return new Renderer$2(mobiledoc, this.options).render();
       default:
         throw new Error(`Unexpected Mobiledoc version "${version}"`);
     }
   }
 }

var ImageCard$2 = {
  name: 'image-card',
  type: 'text',
  render() {}
};

var RENDER_TYPE$1 = 'text';

const MARKUP_SECTION_TYPE$2 = 1;
const IMAGE_SECTION_TYPE$2 = 2;
const LIST_SECTION_TYPE$2 = 3;
const CARD_SECTION_TYPE$1 = 10;

/**
 * runtime Text renderer
 * renders a mobiledoc to Text
 *
 * input: mobiledoc
 * output: Text (string)
 */

const LINE_BREAK = '\n';

const MOBILEDOC_VERSION$6 = '0.2.0';

function validateVersion$2(version) {
  if (version !== MOBILEDOC_VERSION$6) {
    throw new Error(`Unexpected Mobiledoc version "${version}"`);
  }
}

class Renderer$3 {
  constructor(mobiledoc, state) {
    let { cards, cardOptions, atoms, unknownCardHandler } = state;
    let { version, sections: sectionData } = mobiledoc;
    validateVersion$2(version);

    let [, sections] = sectionData;

    this.root               = [];
    this.sections           = sections;
    this.cards              = cards;
    this.atoms              = atoms;
    this.cardOptions        = cardOptions;
    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;

    this._teardownCallbacks  = [];
  }

  render() {
    this.sections.forEach(section => {
      this.root.push(this.renderSection(section));
    });

    let result = this.root.join(LINE_BREAK);
    return { result, teardown: () => this.teardown() };
  }

  teardown() {
    for (let i=0; i < this._teardownCallbacks.length; i++) {
      this._teardownCallbacks[i]();
    }
  }

  get _defaultUnknownCardHandler() {
    return () => {
      // for the text renderer, a missing card is a no-op
    };
  }

  renderSection(section) {
    const [type] = section;
    switch (type) {
      case MARKUP_SECTION_TYPE$2:
        return  this.renderMarkupSection(section);
      case IMAGE_SECTION_TYPE$2:
        return this.renderImageSection(section);
      case LIST_SECTION_TYPE$2:
        return this.renderListSection(section);
      case CARD_SECTION_TYPE$1:
        return this.renderCardSection(section);
      default:
        throw new Error('Unimplemented renderer for type ' + type);
    }
  }

  renderImageSection() {
    return '';
  }

  renderListSection([type, tagName, items]) {
    return items.map(
      li => this.renderListItem(li)
    ).join(LINE_BREAK);
  }

  renderListItem(markers) {
    return this.renderMarkers(markers);
  }

  findCard(name) {
    for (let i=0; i < this.cards.length; i++) {
      if (this.cards[i].name === name) {
        return this.cards[i];
      }
    }
    if (name === ImageCard$2.name) {
      return ImageCard$2;
    }
    return this._createUnknownCard(name);
  }

  _createUnknownCard(name) {
    return {
      name,
      type: RENDER_TYPE$1,
      render: this.unknownCardHandler
    };
  }

  renderCardSection([type, name, payload]) {
    let card = this.findCard(name);

    let cardArg = this._createCardArgument(card, payload);
    let rendered = card.render(cardArg);

    this._validateCardRender(rendered, card.name);

    return rendered || '';
  }

  _validateCardRender(rendered, cardName) {
    if (!rendered) {
      return;
    }

    if (typeof rendered !== 'string') {
      throw new Error(`Card "${cardName}" must render ${RENDER_TYPE$1}, but result was ${typeof rendered}"`);
    }
  }

  _registerTeardownCallback(callback) {
    this._teardownCallbacks.push(callback);
  }

  _createCardArgument(card, payload={}) {
    let env = {
      name: card.name,
      isInEditor: false,
      onTeardown: (callback) => this._registerTeardownCallback(callback)
    };

    let options = this.cardOptions;

    return { env, options, payload };
  }

  renderMarkupSection([type, tagName, markers]) {
    return this.renderMarkers(markers);
  }

  renderMarkers(markers) {
    let str = '';
    markers.forEach(m => {
      let [, , text] = m;
      str += text;
    });
    return str;
  }
}

const MARKUP_MARKER_TYPE$1 = 0;
const ATOM_MARKER_TYPE$1 = 1;

/**
 * runtime Text renderer
 * renders a mobiledoc to Text
 *
 * input: mobiledoc
 * output: Text (string)
 */

const LINE_BREAK$1 = '\n';

const MOBILEDOC_VERSION_0_3 = '0.3.0';
const MOBILEDOC_VERSION_0_3_1$1 = '0.3.1';
const MOBILEDOC_VERSION_0_3_2$1 = '0.3.2';

function validateVersion$3(version) {
  if (
    version !== MOBILEDOC_VERSION_0_3 &&
    version !== MOBILEDOC_VERSION_0_3_1$1 &&
    version !== MOBILEDOC_VERSION_0_3_2$1
  ) {
    throw new Error(`Unexpected Mobiledoc version "${version}"`);
  }
}

class Renderer$4 {
  constructor(mobiledoc, state) {

    let { cards, cardOptions, atoms, unknownCardHandler, unknownAtomHandler } = state;
    let { version, sections, atoms: atomTypes, cards: cardTypes } = mobiledoc;
    validateVersion$3(version);

    this.root               = [];
    this.sections           = sections;
    this.atomTypes          = atomTypes;
    this.cardTypes          = cardTypes;
    this.cards              = cards;
    this.atoms              = atoms;
    this.cardOptions        = cardOptions;
    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;
    this.unknownAtomHandler = unknownAtomHandler || this._defaultUnknownAtomHandler;

    this._teardownCallbacks  = [];
  }

  render() {
    this.sections.forEach(section => {
      this.root.push(this.renderSection(section));
    });

    let result = this.root.join(LINE_BREAK$1);
    return { result, teardown: () => this.teardown() };
  }

  teardown() {
    for (let i=0; i < this._teardownCallbacks.length; i++) {
      this._teardownCallbacks[i]();
    }
  }

  get _defaultUnknownCardHandler() {
    return () => {
      // for the text renderer, a missing card is a no-op
    };
  }

  get _defaultUnknownAtomHandler() {
    return ({ value }) => {
      return value || '';
    };
  }

  renderSection(section) {
    const [type] = section;
    switch (type) {
      case MARKUP_SECTION_TYPE$2:
        return  this.renderMarkupSection(section);
      case IMAGE_SECTION_TYPE$2:
        return this.renderImageSection(section);
      case LIST_SECTION_TYPE$2:
        return this.renderListSection(section);
      case CARD_SECTION_TYPE$1:
        return this.renderCardSection(section);
      default:
        throw new Error('Unimplemented renderer for type ' + type);
    }
  }

  renderImageSection() {
    return '';
  }

  renderListSection([type, tagName, items]) {
    return items.map(
      li => this.renderListItem(li)
    ).join(LINE_BREAK$1);
  }

  renderListItem(markers) {
    return this.renderMarkers(markers);
  }

  findCard(name) {
    for (let i=0; i < this.cards.length; i++) {
      if (this.cards[i].name === name) {
        return this.cards[i];
      }
    }
    if (name === ImageCard$2.name) {
      return ImageCard$2;
    }
    return this._createUnknownCard(name);
  }

  _findCardByIndex(index) {
    let cardType = this.cardTypes[index];
    if (!cardType) {
      throw new Error(`No card definition found at index ${index}`);
    }

    let [ name, payload ] = cardType;
    let card = this.findCard(name);

    return {
      card,
      payload
    };
  }

  _createUnknownCard(name) {
    return {
      name,
      type: RENDER_TYPE$1,
      render: this.unknownCardHandler
    };
  }

  renderCardSection([type, index]) {
    let { card, payload } = this._findCardByIndex(index);

    let cardArg = this._createCardArgument(card, payload);
    let rendered = card.render(cardArg);

    this._validateCardRender(rendered, card.name);

    return rendered || '';
  }

  _validateCardRender(rendered, cardName) {
    if (!rendered) {
      return;
    }

    if (typeof rendered !== 'string') {
      throw new Error(`Card "${cardName}" must render ${RENDER_TYPE$1}, but result was ${typeof rendered}"`);
    }
  }

  _registerTeardownCallback(callback) {
    this._teardownCallbacks.push(callback);
  }

  _createCardArgument(card, payload={}) {
    let env = {
      name: card.name,
      isInEditor: false,
      onTeardown: (callback) => this._registerTeardownCallback(callback)
    };

    let options = this.cardOptions;

    return { env, options, payload };
  }

  renderMarkupSection([type, tagName, markers]) {
    return this.renderMarkers(markers);
  }

  findAtom(name) {
    for (let i=0; i < this.atoms.length; i++) {
      if (this.atoms[i].name === name) {
        return this.atoms[i];
      }
    }
    return this._createUnknownAtom(name);
  }

  _createUnknownAtom(name) {
    return {
      name,
      type: RENDER_TYPE$1,
      render: this.unknownAtomHandler
    };
  }

  _createAtomArgument(atom, value, payload) {
    let env = {
      name: atom.name,
      onTeardown: (callback) => this._registerTeardownCallback(callback)
    };

    let options = this.cardOptions;

    return { env, options, value, payload };
  }

  _validateAtomRender(rendered, atomName) {
    if (!rendered) {
      return;
    }

    if (typeof rendered !== 'string') {
      throw new Error(`Atom "${atomName}" must render ${RENDER_TYPE$1}, but result was ${typeof rendered}"`);
    }
  }

  _findAtomByIndex(index) {
    let atomType = this.atomTypes[index];
    if (!atomType) {
      throw new Error(`No atom definition found at index ${index}`);
    }

    let [ name, value, payload ] = atomType;
    let atom = this.findAtom(name);

    return {
      atom,
      value,
      payload
    };
  }

  _renderAtom(index) {
    let { atom, value, payload } = this._findAtomByIndex(index);

    let atomArg = this._createAtomArgument(atom, value, payload);
    let rendered = atom.render(atomArg);

    this._validateAtomRender(rendered, atom.name);

    return rendered || '';
  }

  renderMarkers(markers) {
    let str = '';
    markers.forEach(m => {
      let [type, , , value] = m;
      switch (type) {
        case MARKUP_MARKER_TYPE$1:
          str += value;
          break;
        case ATOM_MARKER_TYPE$1:
          str += this._renderAtom(value);
          break;
        default:
          throw new Error(`Unknown markup type (${type})`);
      }
    });
    return str;
  }
}

/**
 * runtime Text renderer
 * renders a mobiledoc to Text
 *
 * input: mobiledoc
 * output: Text (string)
 */

function validateCards$2(cards) {
  if (!Array.isArray(cards)) {
    throw new Error('`cards` must be passed as an array');
  }
  for (let i=0; i < cards.length; i++) {
    let card = cards[i];
    if (card.type !== RENDER_TYPE$1) {
      throw new Error(`Card "${card.name}" must be type "${RENDER_TYPE$1}", was "${card.type}"`);
    }
    if (!card.render) {
      throw new Error(`Card "${card.name}" must define \`render\``);
    }
  }
}

function validateAtoms$2(atoms) {
  if (!Array.isArray(atoms)) {
    throw new Error('`atoms` must be passed as an array');
  }
  for (let i=0; i < atoms.length; i++) {
    let atom = atoms[i];
    if (atom.type !== RENDER_TYPE$1) {
      throw new Error(`Atom "${atom.name}" must be type "${RENDER_TYPE$1}", was "${atom.type}"`);
    }
    if (!atom.render) {
      throw new Error(`Atom "${atom.name}" must define \`render\``);
    }
  }
}

class RendererFactory$1 {
  constructor({cards, atoms, cardOptions, unknownCardHandler, unknownAtomHandler}={}) {
    cards = cards || [];
    validateCards$2(cards);
    atoms = atoms || [];
    validateAtoms$2(atoms);
    cardOptions = cardOptions || {};

    this.state = {cards, atoms, cardOptions, unknownCardHandler, unknownAtomHandler};
  }

  render(mobiledoc) {
    let { version } = mobiledoc;
    switch (version) {
      case MOBILEDOC_VERSION$6:
        return new Renderer$3(mobiledoc, this.state).render();
      case undefined:
      case null:
      case MOBILEDOC_VERSION_0_3:
      case MOBILEDOC_VERSION_0_3_1$1:
      case MOBILEDOC_VERSION_0_3_2$1:
        return new Renderer$4(mobiledoc, this.state).render();
      default:
        throw new Error(`Unexpected Mobiledoc version "${version}"`);
    }
  }
}

class Logger {
  constructor(type, manager) {
    this.type = type;
    this.manager = manager;
  }

  isEnabled() {
    return this.manager.isEnabled(this.type);
  }

  log(...args) {
    args.unshift(`[${this.type}]`);
    if (this.isEnabled()) {
      window.console.log(...args);
    }
  }
}

class LogManager {
  constructor() {
    this.enabledTypes = [];
    this.allEnabled = false;
  }

  for(type) {
    return new Logger(type, this);
  }

  enableAll() {
    this.allEnabled = true;
  }

  enableTypes(types) {
    this.enabledTypes = this.enabledTypes.concat(types);
  }

  disable() {
    this.enabledTypes = [];
    this.allEnabled = false;
  }

  isEnabled(type) {
    return this.allEnabled || this.enabledTypes.indexOf(type) !== -1;
  }
}

const defaults = {
  placeholder: 'Write here...',
  spellcheck: true,
  autofocus: true,
  showLinkTooltips: true,
  undoDepth: 5,
  undoBlockTimeout: 5000, // ms for an undo event
  cards: [],
  atoms: [],
  cardOptions: {},
  unknownCardHandler: ({env}) => {
    throw new MobiledocError(`Unknown card encountered: ${env.name}`);
  },
  unknownAtomHandler: ({env}) => {
    throw new MobiledocError(`Unknown atom encountered: ${env.name}`);
  },
  mobiledoc: null,
  html: null
};

const CALLBACK_QUEUES$1 = {
  DID_UPDATE: 'didUpdate',
  WILL_RENDER: 'willRender',
  DID_RENDER: 'didRender',
  WILL_DELETE: 'willDelete',
  DID_DELETE: 'didDelete',
  WILL_HANDLE_NEWLINE: 'willHandleNewline',
  CURSOR_DID_CHANGE: 'cursorDidChange',
  DID_REPARSE: 'didReparse',
  POST_DID_CHANGE: 'postDidChange',
  INPUT_MODE_DID_CHANGE: 'inputModeDidChange'
};

/**
 * The Editor is a core component of mobiledoc-kit. After instantiating
 * an editor, use {@link Editor#render} to display the editor on the web page.
 *
 * An editor uses a {@link Post} internally to represent the displayed document.
 * The post can be serialized as mobiledoc using {@link Editor#serialize}. Mobiledoc
 * is the transportable "over-the-wire" format (JSON) that is suited for persisting
 * and sharing between editors and renderers (for display, e.g.), whereas the Post
 * model is better suited for programmatic editing.
 *
 * The editor will call registered callbacks for certain state changes. These are:
 *   * {@link Editor#cursorDidChange} -- The cursor position or selection changed.
 *   * {@link Editor#postDidChange} -- The contents of the post changed due to user input or
 *     programmatic editing. This hook can be used with {@link Editor#serialize}
 *     to auto-save a post as it is being edited.
 *   * {@link Editor#inputModeDidChange} -- The active section(s) or markup(s) at the current cursor
 *     position or selection have changed. This hook can be used with
 *     {@link Editor#activeMarkups} and {@link Editor#activeSections} to implement
 *     a custom toolbar.
 *   * {@link Editor#onTextInput} -- Register callbacks when the user enters text
 *     that matches a given string or regex.
 *   * {@link Editor#beforeToggleMarkup} -- Register callbacks that will be run before
 *     applying changes from {@link Editor#toggleMarkup}
 */
class Editor {
  /**
   * @param {Object} [options]
   * @param {Object} [options.mobiledoc] The mobiledoc to load into the editor.
   *        Supersedes `options.html`.
   * @param {String|DOM} [options.html] The html (as a string or DOM fragment)
   *        to parse and load into the editor.
   *        Will be ignored if `options.mobiledoc` is also passed.
   * @param {Array} [options.parserPlugins=[]]
   * @param {Array} [options.cards=[]] The cards that the editor may render.
   * @param {Array} [options.atoms=[]] The atoms that the editor may render.
   * @param {Function} [options.unknownCardHandler] Invoked by the editor's renderer
   *        whenever it encounters an unknown card.
   * @param {Function} [options.unknownAtomHandler] Invoked by the editor's renderer
   *        whenever it encounters an unknown atom.
   * @param {String} [options.placeholder] Default text to show before user starts typing.
   * @param {Boolean} [options.spellcheck=true] Whether to enable spellcheck
   * @param {Boolean} [options.autofocus=true] Whether to focus the editor when it is first rendered.
   * @param {Boolean} [options.showLinkTooltips=true] Whether to show the url tooltip for links
   * @param {number} [options.undoDepth=5] How many undo levels will be available.
   *        Set to 0 to disable undo/redo functionality.
   * @return {Editor}
   * @public
   */
  constructor(options={}) {
    mobiledocAssert('editor create accepts an options object. For legacy usage passing an element for the first argument, consider the `html` option for loading DOM or HTML posts. For other cases call `editor.render(domNode)` after editor creation',
          (options && !options.nodeType));
    this._views = [];
    this.isEditable = true;
    this._parserPlugins = options.parserPlugins || [];

    // FIXME: This should merge onto this.options
    mergeWithOptions(this, defaults, options);
    this.cards.push(ImageCard);

    DEFAULT_KEY_COMMANDS.forEach(kc => this.registerKeyCommand(kc));

    this._logManager = new LogManager();
    this._parser   = new DOMParser(this.builder);
    let {cards, atoms, unknownCardHandler, unknownAtomHandler, cardOptions} = this;
    this._renderer = new Renderer(this, cards, atoms, unknownCardHandler, unknownAtomHandler, cardOptions);

    this.post = this.loadPost();
    this._renderTree = new RenderTree(this.post);

    this._editHistory = new EditHistory(this, this.undoDepth, this.undoBlockTimeout);
    this._eventManager = new EventManager(this);
    this._mutationHandler = new MutationHandler(this);
    this._editState = new EditState(this);
    this._callbacks = new LifecycleCallbacks(values(CALLBACK_QUEUES$1));
    this._beforeHooks = { toggleMarkup: [] };

    DEFAULT_TEXT_INPUT_HANDLERS.forEach(handler => this.onTextInput(handler));

    this.hasRendered = false;
  }

  /**
   * Turns on verbose logging for the editor.
   * @param {Array} [logTypes=[]] If present, only the given log types will be logged.
   * @public
   */
  enableLogging(logTypes=[]) {
    if (logTypes.length === 0) {
      this._logManager.enableAll();
    } else {
      this._logManager.enableTypes(logTypes);
    }
  }

  /**
   * Disable all logging
   * @public
   */
  disableLogging() {
    this._logManager.disable();
  }

  /**
   * @private
   */
  loggerFor(type) {
    return this._logManager.for(type);
  }

  /**
   * The editor's instance of a post node builder.
   * @type {PostNodeBuilder}
   */
  get builder() {
    if (!this._builder) { this._builder = new PostNodeBuilder(); }
    return this._builder;
  }

  loadPost() {
    let {mobiledoc, html} = this;
    if (mobiledoc) {
      return mobiledocParsers.parse(this.builder, mobiledoc);
    } else if (html) {
      if (typeof html === 'string') {
        let options = {plugins: this._parserPlugins};
        return new HTMLParser(this.builder, options).parse(this.html);
      } else {
        let dom = html;
        return this._parser.parse(dom);
      }
    } else {
      return this.builder.createPost();
    }
  }

  rerender() {
    let postRenderNode = this.post.renderNode;

    // if we haven't rendered this post's renderNode before, mark it dirty
    if (!postRenderNode.element) {
      mobiledocAssert('Must call `render` before `rerender` can be called',
             this.hasRendered);
      postRenderNode.element = this.element;
      postRenderNode.markDirty();
    }

    this.runCallbacks(CALLBACK_QUEUES$1.WILL_RENDER);
    this._mutationHandler.suspendObservation(() => {
      this._renderer.render(this._renderTree);
    });
    this.runCallbacks(CALLBACK_QUEUES$1.DID_RENDER);
  }

  /**
   * @param {Element} element The DOM element to render into.
   *        Its contents will be replaced by the editor's rendered post.
   * @public
   */
  render(element) {
    mobiledocAssert('Cannot render an editor twice. Use `rerender` to update the ' +
           'rendering of an existing editor instance.',
           !this.hasRendered);

    element.spellcheck = this.spellcheck;

    clearChildNodes(element);

    this.element = element;

    if (this.showLinkTooltips) {
      this._addTooltip();
    }

    // A call to `run` will trigger the didUpdatePostCallbacks hooks with a
    // postEditor.
    this.run(() => {});

    // Only set `hasRendered` to true after calling `run` to ensure that
    // no cursorDidChange or other callbacks get fired before the editor is
    // done rendering
    this.hasRendered = true;
    this.rerender();

    this._mutationHandler.init();
    this._eventManager.init();

    if (this.isEditable === false) {
      this.disableEditing();
    } else {
      this.enableEditing();
    }

    if (this.autofocus) {
      this.selectRange(this.post.headPosition());
    }
  }

  _addTooltip() {
    this.addView(new Tooltip({
      rootElement: this.element,
      showForTag: 'a'
    }));
  }

  get keyCommands() {
    if (!this._keyCommands) { this._keyCommands = []; }
    return this._keyCommands;
  }

  /**
   * @param {Object} keyCommand The key command to register. It must specify a
   * modifier key (meta, ctrl, etc), a string representing the ascii key, and
   * a `run` method that will be passed the editor instance when the key command
   * is invoked
   * @public
   */
  registerKeyCommand(rawKeyCommand) {
    const keyCommand = buildKeyCommand(rawKeyCommand);
    mobiledocAssert('Key Command is not valid', validateKeyCommand(keyCommand));
    this.keyCommands.unshift(keyCommand);
  }

  /**
   * @param {String} name If the keyCommand event has a name attribute it can be removed.
   * @public
   */
  unregisterKeyCommands(name) {
    for(let i = this.keyCommands.length-1; i > -1; i--) {
      let keyCommand = this.keyCommands[i];

      if(keyCommand.name === name) {
        this.keyCommands.splice(i,1);
      }
    }
  }

  /**
   * Convenience for {@link PostEditor#deleteAtPosition}. Deletes and puts the
   * cursor in the new position.
   * @public
   */
  deleteAtPosition(position, direction, {unit}) {
    this.run(postEditor => {
      let nextPosition = postEditor.deleteAtPosition(position, direction, {unit});
      postEditor.setRange(nextPosition);
    });
  }

  /**
   * Convenience for {@link PostEditor#deleteRange}. Deletes and puts the
   * cursor in the new position.
   * @param {Range} range
   * @public
   */
  deleteRange(range) {
    this.run(postEditor => {
      let nextPosition = postEditor.deleteRange(range);
      postEditor.setRange(nextPosition);
    });
  }

  /**
   * @private
   */
  performDelete({direction, unit}={direction: DIRECTION.BACKWARD, unit: 'char'}) {
    let { range } = this;

    this.runCallbacks(CALLBACK_QUEUES$1.WILL_DELETE, [range, direction, unit]);
    if (range.isCollapsed) {
      this.deleteAtPosition(range.head, direction, {unit});
    } else {
      this.deleteRange(range);
    }
    this.runCallbacks(CALLBACK_QUEUES$1.DID_DELETE, [range, direction, unit]);
  }

  handleNewline(event) {
    if (!this.hasCursor()) { return; }

    event.preventDefault();

    let { range } = this;
    this.run(postEditor => {
      let cursorSection;
      if (!range.isCollapsed) {
        let nextPosition  = postEditor.deleteRange(range);
        cursorSection = nextPosition.section;
        if (cursorSection && cursorSection.isBlank) {
          postEditor.setRange(cursorSection.headPosition());
          return;
        }
      }

      // Above logic might delete redundant range, so callback must run after it.
      let defaultPrevented = false;
      const event = { preventDefault() { defaultPrevented = true; } };
      this.runCallbacks(CALLBACK_QUEUES$1.WILL_HANDLE_NEWLINE, [event]);
      if (defaultPrevented) { return; }

      cursorSection = postEditor.splitSection(range.head)[1];
      postEditor.setRange(cursorSection.headPosition());
    });
  }

  /**
   * Notify the editor that the post did change, and run associated
   * callbacks.
   * @private
   */
  _postDidChange() {
    this.runCallbacks(CALLBACK_QUEUES$1.POST_DID_CHANGE);
  }

  /**
   * Selects the given range or position. If given a collapsed range or a position, this positions the cursor
   * at the range's position. Otherwise a selection is created in the editor
   * surface encompassing the range.
   * @param {Range|Position} range
   */
  selectRange(range) {
    range = toRange(range);

    this.cursor.selectRange(range);
    this.range = range;
  }

  get cursor() {
    return new Cursor(this);
  }

  /**
   * Return the current range for the editor (may be cached).
   * @return {Range}
   */
  get range() {
    return this._editState.range;
  }

  set range(newRange) {
    this._editState.updateRange(newRange);

    if (this._editState.rangeDidChange()) {
      this._rangeDidChange();
    }

    if (this._editState.inputModeDidChange()) {
      this._inputModeDidChange();
    }
  }

  _readRangeFromDOM() {
    this.range = this.cursor.offsets;
  }

  setPlaceholder(placeholder) {
    setData(this.element, 'placeholder', placeholder);
  }

  _reparsePost() {
    let post = this._parser.parse(this.element);
    this.run(postEditor => {
      postEditor.removeAllSections();
      postEditor.migrateSectionsFromPost(post);
      postEditor.setRange(Range.blankRange());
    });

    this.runCallbacks(CALLBACK_QUEUES$1.DID_REPARSE);
    this._postDidChange();
  }

  _reparseSections(sections=[]) {
    let currentRange;
    sections.forEach(section => {
      this._parser.reparseSection(section, this._renderTree);
    });
    this._removeDetachedSections();

    if (this._renderTree.isDirty) {
      currentRange = this.range;
    }

    // force the current snapshot's range to remain the same rather than
    // rereading it from DOM after the new character is applied and the browser
    // updates the cursor position
    let range = this._editHistory._pendingSnapshot.range;
    this.run(() => {
      this._editHistory._pendingSnapshot.range = range;
    });
    this.rerender();
    if (currentRange) {
      this.selectRange(currentRange);
    }

    this.runCallbacks(CALLBACK_QUEUES$1.DID_REPARSE);
    this._postDidChange();
  }

  // FIXME this should be able to be removed now -- if any sections are detached,
  // it's due to a bug in the code.
  _removeDetachedSections() {
    forEach(
      filter(this.post.sections, s => !s.renderNode.isAttached()),
      s => s.renderNode.scheduleForRemoval()
    );
  }

  /**
   * The sections from the cursor's selection start to the selection end
   * @type {Section[]}
   */
  get activeSections() {
    return this._editState.activeSections;
  }

  get activeSection() {
    const { activeSections } = this;
    return activeSections[activeSections.length - 1];
  }

  get activeSectionAttributes() {
    return this._editState.activeSectionAttributes;
  }

  detectMarkupInRange(range, markupTagName) {
    let markups = this.post.markupsInRange(range);
    return detect(markups, markup => {
      return markup.hasTag(markupTagName);
    });
  }

  /**
   * @type {Markup[]}
   * @public
   */
  get activeMarkups() {
    return this._editState.activeMarkups;
  }

  /**
   * @param {Markup|String} markup A markup instance, or a string (e.g. "b")
   * @return {boolean}
   */
  hasActiveMarkup(markup) {
    let matchesFn;
    if (typeof markup === 'string') {
      let tagName = normalizeTagName(markup);
      matchesFn = (m) => m.tagName === tagName;
    } else {
      matchesFn = (m) => m === markup;
    }

    return !!detect(this.activeMarkups, matchesFn);
  }

  /**
   * @param {String} version The mobiledoc version to serialize to.
   * @return {Mobiledoc} Serialized mobiledoc
   * @public
   */
  serialize(version=MOBILEDOC_VERSION$4) {
    return this.serializePost(this.post, 'mobiledoc', {version});
  }

  /**
   * Serialize the editor's post to the requested format.
   * Note that only mobiledoc format is lossless. If cards or atoms are present
   * in the post, the html and text formats will omit them in output because
   * the editor does not have access to the html and text versions of the
   * cards/atoms.
   * @param {string} format The format to serialize ('mobiledoc', 'text', 'html')
   * @return {Object|String} The editor's post, serialized to {format}
   * @public
   */
  serializeTo(format) {
    let post = this.post;
    return this.serializePost(post, format);
  }

  /**
   * @param {Post}
   * @param {String} format Same as {serializeTo}
   * @param {Object} [options]
   * @param {String} [options.version=MOBILEDOC_VERSION] version to serialize to
   * @return {Object|String}
   * @private
   */
  serializePost(post, format, options={}) {
    const validFormats = ['mobiledoc', 'html', 'text'];
    mobiledocAssert(`Unrecognized serialization format ${format}`,
           contains(validFormats, format));

    if (format === 'mobiledoc') {
      let version = options.version || MOBILEDOC_VERSION$4;
      return mobiledocRenderers.render(post, version);
    } else {
      let rendered;
      let mobiledoc = this.serializePost(post, 'mobiledoc');
      let unknownCardHandler = () => {};
      let unknownAtomHandler = () => {};
      let rendererOptions = { unknownCardHandler, unknownAtomHandler };

      switch (format) {
        case 'html': {
          let result;
          if (Environment.hasDOM()) {
            rendered = new RendererFactory(rendererOptions).render(mobiledoc);
            result = `<div>${serializeHTML(rendered.result)}</div>`;
          } else {
            // Fallback to text serialization
            result = this.serializePost(post, 'text', options);
          }
          return result;
        }
        case 'text':
          rendered = new RendererFactory$1(rendererOptions).render(mobiledoc);
          return rendered.result;
      }
    }
  }

  addView(view) {
    this._views.push(view);
  }

  removeAllViews() {
    this._views.forEach((v) => v.destroy());
    this._views = [];
  }

  /**
   * Whether the editor has a cursor (or a selected range).
   * It is possible for the editor to be focused but not have a selection.
   * In this case, key events will fire but the editor will not be able to
   * determine a cursor position, so they will be ignored.
   * @return {boolean}
   * @public
   */
  hasCursor() {
    return this.cursor.hasCursor();
  }

  /**
   * Tears down the editor's attached event listeners and views.
   * @public
   */
  destroy() {
    this.isDestroyed = true;
    if (this._hasSelection()) {
      this.cursor.clearSelection();
    }
    if (this._hasFocus()) {
      this.element.blur(); // FIXME This doesn't blur the element on IE11
    }
    this._mutationHandler.destroy();
    this._eventManager.destroy();
    this.removeAllViews();
    this._renderer.destroy();
    this._editState.destroy();
  }

  /**
   * Keep the user from directly editing the post using the keyboard and mouse.
   * Modification via the programmatic API is still permitted.
   * @see Editor#enableEditing
   * @public
   */
  disableEditing() {
    this.isEditable = false;
    if (this.hasRendered) {
      this._eventManager.stop();
      this.element.setAttribute('contentEditable', false);
      this.setPlaceholder('');
      this.selectRange(Range.blankRange());
    }
  }

  /**
   * Allow the user to directly interact with editing a post via keyboard and mouse input.
   * Editor instances are editable by default. Use this method to re-enable
   * editing after disabling it.
   * @see Editor#disableEditing
   * @public
   */
  enableEditing() {
    this.isEditable = true;
    if (this.hasRendered) {
      this._eventManager.start();
      this.element.setAttribute('contentEditable', true);
      this.setPlaceholder(this.placeholder);
    }
  }

  /**
   * Change a cardSection into edit mode
   * If called before the card has been rendered, it will be marked so that
   * it is rendered in edit mode when it gets rendered.
   * @param {CardSection} cardSection
   * @public
   */
  editCard(cardSection) {
    this._setCardMode(cardSection, CARD_MODES.EDIT);
  }

  /**
   * Change a cardSection into display mode
   * If called before the card has been rendered, it will be marked so that
   * it is rendered in display mode when it gets rendered.
   * @param {CardSection} cardSection
   * @return undefined
   * @public
   */
  displayCard(cardSection) {
    this._setCardMode(cardSection, CARD_MODES.DISPLAY);
  }

  /**
   * Run a new post editing session. Yields a block with a new {@link PostEditor}
   * instance. This instance can be used to interact with the post abstract.
   * Rendering will be deferred until after the callback is completed.
   *
   * Usage:
   * ```
   *   let markerRange = this.range;
   *   editor.run((postEditor) => {
   *     postEditor.deleteRange(markerRange);
   *     // editing surface not updated yet
   *     postEditor.schedule(() => {
   *       console.log('logs during rerender flush');
   *     });
   *     // logging not yet flushed
   *   });
   *   // editing surface now updated.
   *   // logging now flushed
   * ```
   *
   * @param {Function} callback Called with an instance of
   *        {@link PostEditor} as its argument.
   * @return {Mixed} The return value of `callback`.
   * @public
   */
  run(callback) {
    const postEditor = new PostEditor(this);
    postEditor.begin();
    this._editHistory.snapshot();
    const result = callback(postEditor);
    this.runCallbacks(CALLBACK_QUEUES$1.DID_UPDATE, [postEditor]);
    postEditor.complete();
    this._readRangeFromDOM();

    if (postEditor._shouldCancelSnapshot) {
      this._editHistory._pendingSnapshot = null;
    }
    this._editHistory.storeSnapshot(postEditor.editActionTaken);

    return result;
  }

  /**
   * @param {Function} callback Called with `postEditor` as its argument.
   * @public
   */
  didUpdatePost(callback) {
    this.addCallback(CALLBACK_QUEUES$1.DID_UPDATE, callback);
  }

  /**
   * @param {Function} callback Called when the post has changed, either via
   *        user input or programmatically. Use with {@link Editor#serialize} to
   *        retrieve the post in portable mobiledoc format.
   */
  postDidChange(callback) {
    this.addCallback(CALLBACK_QUEUES$1.POST_DID_CHANGE, callback);
  }

  /**
   * Register a handler that will be invoked by the editor after the user enters
   * matching text.
   * @param {Object} inputHandler
   * @param {String} inputHandler.name Required. Used by identifying handlers.
   * @param {String} [inputHandler.text] Required if `match` is not provided
   * @param {RegExp} [inputHandler.match] Required if `text` is not provided
   * @param {Function} inputHandler.run This callback is invoked with the {@link Editor}
   *                   instance and an array of matches. If `text` was provided,
   *                   the matches array will equal [`text`], and if a `match`
   *                   regex was provided the matches array will be the result of
   *                   `match.exec` on the matching text. The callback is called
   *                   after the matching text has been inserted.
   * @public
   */
  onTextInput(inputHandler) {
    this._eventManager.registerInputHandler(inputHandler);
  }

  /**
   * Unregister all text input handlers
   *
   * @public
   */
  unregisterAllTextInputHandlers() {
    this._eventManager.unregisterAllTextInputHandlers();
  }

  /**
   * Unregister text input handler by name
   * @param {String} name The name of handler to be removed
   *
   * @public
   */
  unregisterTextInputHandler(name) {
    this._eventManager.unregisterInputHandler(name);
  }

  /**
   * @param {Function} callback Called when the editor's state (active markups or
   * active sections) has changed, either via user input or programmatically
   */
  inputModeDidChange(callback) {
    this.addCallback(CALLBACK_QUEUES$1.INPUT_MODE_DID_CHANGE, callback);
  }

  /**
   * @param {Function} callback This callback will be called before the editor
   *        is rendered.
   * @public
   */
  willRender(callback) {
    this.addCallback(CALLBACK_QUEUES$1.WILL_RENDER, callback);
  }

  /**
   * @param {Function} callback This callback will be called after the editor
   *        is rendered.
   * @public
   */
  didRender(callback) {
    this.addCallback(CALLBACK_QUEUES$1.DID_RENDER, callback);
  }

  /**
   * @param {Function} callback This callback will be called before deleting.
   * @public
   */
  willDelete(callback) {
    this.addCallback(CALLBACK_QUEUES$1.WILL_DELETE, callback);
  }

  /**
   * @param {Function} callback This callback will be called after deleting.
   * @public
   */
  didDelete(callback) {
    this.addCallback(CALLBACK_QUEUES$1.DID_DELETE, callback);
  }

  /**
   * @param {Function} callback This callback will be called before handling new line.
   * @public
   */
  willHandleNewline(callback) {
    this.addCallback(CALLBACK_QUEUES$1.WILL_HANDLE_NEWLINE, callback);
  }

  /**
   * @param {Function} callback This callback will be called every time the cursor
   *        position (or selection) changes.
   * @public
   */
  cursorDidChange(callback) {
    this.addCallback(CALLBACK_QUEUES$1.CURSOR_DID_CHANGE, callback);
  }

  _rangeDidChange() {
    if (this.hasRendered) {
      this.runCallbacks(CALLBACK_QUEUES$1.CURSOR_DID_CHANGE);
    }
  }

  _inputModeDidChange() {
    this.runCallbacks(CALLBACK_QUEUES$1.INPUT_MODE_DID_CHANGE);
  }

  _insertEmptyMarkupSectionAtCursor() {
    this.run(postEditor => {
      const section = postEditor.builder.createMarkupSection('p');
      postEditor.insertSectionBefore(this.post.sections, section);
      postEditor.setRange(section.toRange());
    });
  }

  /**
   * @callback editorBeforeCallback
   * @param { Object } details
   * @param { Markup } details.markup
   * @param { Range } details.range
   * @param { boolean } details.willAdd Whether the markup will be applied
   */

  /**
   * Register a callback that will be run before {@link Editor#toggleMarkup} is applied.
   * If any callback returns literal `false`, the toggling of markup will be canceled.
   * Note this only applies to calling `editor#toggleMarkup`. Using `editor.run` and
   * modifying markup with the `postEditor` will skip any `beforeToggleMarkup` callbacks.
   * @param {editorBeforeCallback}
   */
  beforeToggleMarkup(callback) {
    this._beforeHooks.toggleMarkup.push(callback);
  }

  /**
   * Toggles the given markup at the editor's current {@link Range}.
   * If the range is collapsed this changes the editor's state so that the
   * next characters typed will be affected. If there is text selected
   * (aka a non-collapsed range), the selections' markup will be toggled.
   * If the editor is not focused and has no active range, nothing happens.
   * Hooks added using #beforeToggleMarkup will be run before toggling,
   * and if any of them returns literal false, toggling the markup will be canceled
   * and no change will be applied.
   * @param {String} markup E.g. "b", "em", "a"
   * @param {Object} [attributes={}] E.g. {href: "http://bustle.com"}
   * @public
   * @see PostEditor#toggleMarkup
   */
  toggleMarkup(markup, attributes={}) {
    markup = this.builder.createMarkup(markup, attributes);
    let { range } = this;
    let willAdd = !this.detectMarkupInRange(range, markup.tagName);
    let shouldCancel = this._runBeforeHooks('toggleMarkup', {markup, range, willAdd});
    if (shouldCancel) { return; }

    if (range.isCollapsed) {
      this._editState.toggleMarkupState(markup);
      this._inputModeDidChange();

      // when clicking a button to toggle markup, the button can end up being focused,
      // so ensure the editor is focused
      this._ensureFocus();
    } else {
      this.run(postEditor => postEditor.toggleMarkup(markup, range));
    }
  }

  // If the editor has a selection but is not focused, focus it
  _ensureFocus() {
    if (this._hasSelection() && !this._hasFocus()) {
      this.focus();
    }
  }

  focus() {
    this.element.focus();
  }

  /**
   * Whether there is a selection inside the editor's element.
   * It's possible to have a selection but not have focus.
   * @see #_hasFocus
   * @return {Boolean}
   */
  _hasSelection() {
    let { cursor } = this;
    return this.hasRendered && (cursor._hasCollapsedSelection() || cursor._hasSelection());
  }

  /**
   * Whether the editor's element is focused
   * It's possible to be focused but have no selection
   * @see #_hasSelection
   * @return {Boolean}
   */
  _hasFocus() {
    return document.activeElement === this.element;
  }

  /**
   * Toggles the tagName for the current active section(s). This will skip
   * non-markerable sections. E.g. if the editor's range includes a "P" MarkupSection
   * and a CardSection, only the MarkupSection will be toggled.
   * @param {String} tagName The new tagname to change to.
   * @public
   * @see PostEditor#toggleSection
   */
  toggleSection(tagName) {
    this.run(postEditor => postEditor.toggleSection(tagName, this.range));
  }

  /**
   * Sets an attribute for the current active section(s).
   *
   * @param {String} key The attribute. The only valid attribute is 'text-align'.
   * @param {String} value The value of the attribute.
   * @public
   * @see PostEditor#setAttribute
   */
  setAttribute(key, value) {
    this.run(postEditor => postEditor.setAttribute(key, value, this.range));
  }

  /**
   * Removes an attribute from the current active section(s).
   *
   * @param {String} key The attribute. The only valid attribute is 'text-align'.
   * @public
   * @see PostEditor#removeAttribute
   */
  removeAttribute(key) {
    this.run(postEditor => postEditor.removeAttribute(key, this.range));
  }

  /**
   * Finds and runs the first matching key command for the event
   *
   * If multiple commands are bound to a key combination, the
   * first matching one is run.
   *
   * If a command returns `false` then the next matching command
   * is run instead.
   *
   * @param {Event} event The keyboard event triggered by the user
   * @return {Boolean} true when a command was successfully run
   * @private
   */
  handleKeyCommand(event) {
    const keyCommands = findKeyCommands(this.keyCommands, event);
    for (let i=0; i<keyCommands.length; i++) {
      let keyCommand = keyCommands[i];
      if (keyCommand.run(this) !== false) {
        event.preventDefault();
        return true;
      }
    }
    return false;
  }

  /**
   * Inserts the text at the current cursor position. If the editor has
   * no current cursor position, nothing will be inserted. If the editor's
   * range is not collapsed, it will be deleted before insertion.
   *
   * @param {String} text
   * @public
   */
  insertText(text) {
    if (!this.hasCursor()) { return; }
    if (this.post.isBlank) {
      this._insertEmptyMarkupSectionAtCursor();
    }
    let { activeMarkups, range, range: { head: position } } = this;

    this.run(postEditor => {
      if (!range.isCollapsed) {
        position = postEditor.deleteRange(range);
      }

      postEditor.insertTextWithMarkup(position, text, activeMarkups);
    });
  }

  /**
   * Inserts an atom at the current cursor position. If the editor has
   * no current cursor position, nothing will be inserted. If the editor's
   * range is not collapsed, it will be deleted before insertion.
   * @param {String} atomName
   * @param {String} [atomText='']
   * @param {Object} [atomPayload={}]
   * @return {Atom} The inserted atom.
   * @public
   */
  insertAtom(atomName, atomText='', atomPayload={}) {
    if (!this.hasCursor()) { return; }
    if (this.post.isBlank) {
      this._insertEmptyMarkupSectionAtCursor();
    }

    let atom;
    let { range } = this;
    this.run(postEditor => {
      let position = range.head;

      atom = postEditor.builder.createAtom(atomName, atomText, atomPayload);
      if (!range.isCollapsed) {
        position = postEditor.deleteRange(range);
      }

      postEditor.insertMarkers(position, [atom]);
    });
    return atom;
  }

  /**
   * Inserts a card at the section after the current cursor position. If the editor has
   * no current cursor position, nothing will be inserted. If the editor's
   * range is not collapsed, it will be deleted before insertion. If the cursor is in
   * a blank section, it will be replaced with a card section.
   * The editor's cursor will be placed at the end of the inserted card.
   * @param {String} cardName
   * @param {Object} [cardPayload={}]
   * @param {Boolean} [inEditMode=false] Whether the card should be inserted in edit mode.
   * @return {Card} The inserted Card section.
   * @public
   */
  insertCard(cardName, cardPayload={}, inEditMode=false) {
    if (!this.hasCursor()) { return; }
    if (this.post.isBlank) {
      this._insertEmptyMarkupSectionAtCursor();
    }

    let card;
    let { range } = this;
    this.run(postEditor => {
      let position = range.tail;
      card = postEditor.builder.createCardSection(cardName, cardPayload);
      if (inEditMode) {
        this.editCard(card);
      }

      if (!range.isCollapsed) {
        position = postEditor.deleteRange(range);
      }

      let section = position.section;
      if (section.isNested) { section = section.parent; }

      if (section.isBlank) {
        postEditor.replaceSection(section, card);
      } else {
        let collection = this.post.sections;
        postEditor.insertSectionBefore(collection, card, section.next);
      }

      // It is important to explicitly set the range to the end of the card.
      // Otherwise it is possible to create an inconsistent state in the
      // browser. For instance, if the user clicked a button that
      // called `editor.insertCard`, the editor surface may retain
      // the selection but lose focus, and the next keystroke by the user
      // will cause an unexpected DOM mutation (which can wipe out the
      // card).
      // See: https://github.com/bustle/mobiledoc-kit/issues/286
      postEditor.setRange(card.tailPosition());
    });
    return card;
  }

  /**
   * @param {integer} x x-position in viewport
   * @param {integer} y y-position in viewport
   * @return {Position|null}
   */
  positionAtPoint(x, y) {
    return Position$1.atPoint(x, y, this);
  }

  /**
   * @private
   */
  _setCardMode(cardSection, mode) {
    const renderNode = cardSection.renderNode;
    if (renderNode && renderNode.isRendered) {
      const cardNode = renderNode.cardNode;
      cardNode[mode]();
    } else {
      cardSection.setInitialMode(mode);
    }
  }

  triggerEvent(context, eventName, event) {
    this._eventManager._trigger(context, eventName, event);
  }

  addCallback(...args) {
    this._callbacks.addCallback(...args);
  }

  addCallbackOnce(...args) {
    this._callbacks.addCallbackOnce(...args);
  }

  runCallbacks(...args) {
    if (this.isDestroyed) {
      // TODO warn that callback attempted after editor was destroyed
      return;
    }
    this._callbacks.runCallbacks(...args);
  }

  /**
   * Runs each callback for the given hookName.
   * Only the hookName 'toggleMarkup' is currently supported
   * @return {Boolean} shouldCancel Whether the action in `hookName` should be canceled
   * @private
   */
  _runBeforeHooks(hookName, ...args) {
    let hooks = this._beforeHooks[hookName] || [];
    for (let i = 0; i < hooks.length; i++) {
      if (hooks[i](...args) === false) {
        return true;
      }
    }
  }
}

function assertEditor(editor) {
  if (!(editor instanceof Editor)) {
    throw new Error('Must pass editor as first argument');
  }
}

// walks DOWN the dom from node to childNodes, returning the element
// for which `conditionFn(element)` is true
function walkDOMUntil(topNode, conditionFn=() => {}) {
  if (!topNode) { throw new Error('Cannot call walkDOMUntil without a node'); }
  let stack = [topNode];
  let currentElement;

  while (stack.length) {
    currentElement = stack.pop();

    if (conditionFn(currentElement)) {
      return currentElement;
    }

    forEach(currentElement.childNodes, el => stack.push(el));
  }
}

function findTextNode(parentElement, text) {
  return walkDOMUntil(parentElement, node => {
    return isTextNode(node) && node.textContent.indexOf(text) !== -1;
  });
}

function selectRange(startNode, startOffset, endNode, endOffset) {
  clearSelection();

  const range = document.createRange();
  range.setStart(startNode, startOffset);
  range.setEnd(endNode, endOffset);

  const selection = window.getSelection();
  selection.addRange(range);
}

function selectText(editor,
                    startText,
                    startContainingElement=editor.element,
                    endText=startText,
                    endContainingElement=startContainingElement) {

  assertEditor(editor);
  let startTextNode = findTextNode(startContainingElement, startText);
  let endTextNode = findTextNode(endContainingElement, endText);

  if (!startTextNode) {
    throw new Error(`Could not find a starting textNode containing "${startText}"`);
  }
  if (!endTextNode) {
    throw new Error(`Could not find an ending textNode containing "${endText}"`);
  }

  const startOffset = startTextNode.textContent.indexOf(startText),
        endOffset   = endTextNode.textContent.indexOf(endText) + endText.length;
  selectRange(startTextNode, startOffset, endTextNode, endOffset);
  editor._readRangeFromDOM();
}

function moveCursorWithoutNotifyingEditorTo(editor, node, offset=0, endNode=node, endOffset=offset) {
  selectRange(node, offset, endNode, endOffset);
}

function moveCursorTo(editor, node, offset=0, endNode=node, endOffset=offset) {
  assertEditor(editor);
  if (!node) { throw new Error('Cannot moveCursorTo node without node'); }
  moveCursorWithoutNotifyingEditorTo(editor, node, offset, endNode, endOffset);
  editor._readRangeFromDOM();
}

function triggerEvent(node, eventType) {
  if (!node) { throw new Error(`Attempted to trigger event "${eventType}" on undefined node`); }

  let clickEvent = document.createEvent('MouseEvents');
  clickEvent.initEvent(eventType, true, true);
  return node.dispatchEvent(clickEvent);
}

function _triggerEditorEvent(editor, event) {
  editor.triggerEvent(editor.element, event.type, event);
}

function _buildDOM(tagName, attributes={}, children=[]) {
  const el = document.createElement(tagName);
  Object.keys(attributes).forEach(k => el.setAttribute(k, attributes[k]));
  children.forEach(child => el.appendChild(child));
  return el;
}

_buildDOM.text = (string) => {
  return document.createTextNode(string);
};

/**
 * Usage:
 * build(t =>
 *   t('div', attributes={}, children=[
 *     t('b', {}, [
 *       t.text('I am a bold text node')
 *     ])
 *   ])
 * );
 */
function build(tree) {
  return tree(_buildDOM);
}

function getSelectedText() {
  const selection = window.getSelection();
  if (selection.rangeCount === 0) {
    return null;
  } else if (selection.rangeCount > 1) {
    // FIXME?
    throw new Error('Unable to get selected text for multiple ranges');
  } else {
    return selection.toString();
  }
}

// returns the node and the offset that the cursor is on
function getCursorPosition() {
  const selection = window.getSelection();
  return {
    node:   selection.anchorNode,
    offset: selection.anchorOffset
  };
}

function createMockEvent(eventName, element, options={}) {
  let event = {
    type: eventName,
    preventDefault() {},
    target: element
  };
  merge(event, options);
  return event;
}

// options is merged into the mocked `KeyboardEvent` data.
// Useful for simulating modifier keys, eg:
// triggerDelete(editor, DIRECTION.BACKWARD, {altKey: true})
function triggerDelete(editor, direction=DIRECTION.BACKWARD, options={}) {
  assertEditor(editor);
  const keyCode = direction === DIRECTION.BACKWARD ? Keycodes.BACKSPACE :
                                                     Keycodes.DELETE;
  let eventOptions = merge({keyCode}, options);
  let event = createMockEvent('keydown', editor.element, eventOptions);
  _triggerEditorEvent(editor, event);
}

function triggerForwardDelete(editor, options) {
  return triggerDelete(editor, DIRECTION.FORWARD, options);
}

function triggerEnter(editor) {
  assertEditor(editor);
  let event = createMockEvent('keydown', editor.element, { keyCode: Keycodes.ENTER});
  _triggerEditorEvent(editor, event);
}

// keyCodes and charCodes are similar but not the same.
function keyCodeForChar(letter) {
  let keyCode;
  switch (letter) {
    case '.':
      keyCode = Keycodes['.'];
      break;
    case '\n':
      keyCode = Keycodes.ENTER;
      break;
    default:
      keyCode = letter.charCodeAt(0);
  }
  return keyCode;
}

function insertText(editor, string) {
  if (!string && editor) { throw new Error('Must pass `editor` to `insertText`'); }

  string.split('').forEach(letter => {
    let stop = false;
    let keyCode = keyCodeForChar(letter);
    let charCode = letter.charCodeAt(0);
    let preventDefault = () => stop = true;
    let keydown = createMockEvent('keydown', editor.element, {
      keyCode,
      charCode,
      preventDefault
    });
    let keypress = createMockEvent('keypress', editor.element, {
      keyCode,
      charCode,
    });
    let keyup = createMockEvent('keyup', editor.element, {
      keyCode,
      charCode,
      preventDefault
    });

    _triggerEditorEvent(editor, keydown);
    if (stop) {
      return;
    }
    _triggerEditorEvent(editor, keypress);
    if (stop) {
      return;
    }
    _triggerEditorEvent(editor, keyup);
  });
}

function triggerKeyEvent(editor, type, options) {
  let event = createMockEvent(type, editor.element, options);
  _triggerEditorEvent(editor, event);
}

// triggers a key sequence like cmd-B on the editor, to test out
// registered keyCommands
function triggerKeyCommand(editor, string, modifiers=[]) {
  if (typeof modifiers === "number") {
    modifiers = [modifiers]; // convert singular to array
  }
  let charCode = (Keycodes[string] || string.toUpperCase().charCodeAt(0));
  let keyCode = charCode;
  let keyEvent = createMockEvent('keydown', editor.element, {
    charCode,
    keyCode,
    shiftKey: contains(modifiers, MODIFIERS.SHIFT),
    metaKey: contains(modifiers, MODIFIERS.META),
    ctrlKey: contains(modifiers, MODIFIERS.CTRL)
  });
  _triggerEditorEvent(editor, keyEvent);
}

function triggerRightArrowKey(editor, modifier) {
  if (!(editor instanceof Editor)) {
    throw new Error('Must pass editor to triggerRightArrowKey');
  }
  let keydown = createMockEvent('keydown', editor.element, {
    keyCode: Keycodes.RIGHT,
    shiftKey: modifier === MODIFIERS.SHIFT
  });
  let keyup = createMockEvent('keyup', editor.element, {
    keyCode: Keycodes.RIGHT,
    shiftKey: modifier === MODIFIERS.SHIFT
  });
  _triggerEditorEvent(editor, keydown);
  _triggerEditorEvent(editor, keyup);
}

function triggerLeftArrowKey(editor, modifier) {
  assertEditor(editor);
  let keydown = createMockEvent('keydown', editor.element, {
    keyCode: Keycodes.LEFT,
    shiftKey: modifier === MODIFIERS.SHIFT
  });
  let keyup = createMockEvent('keyup', editor.element, {
    keyCode: Keycodes.LEFT,
    shiftKey: modifier === MODIFIERS.SHIFT
  });
  _triggerEditorEvent(editor, keydown);
  _triggerEditorEvent(editor, keyup);
}

// Allows our fake copy and paste events to communicate with each other.
const lastCopyData = {};
function triggerCopyEvent(editor) {
  let eventData = {
    clipboardData: {
      setData(type, value) {
        lastCopyData[type] = value;
      }
    }
  };

  let event = createMockEvent('copy', editor.element, eventData);
  _triggerEditorEvent(editor, event);
}

function triggerCutEvent(editor) {
  let event = createMockEvent('cut', editor.element, {
    clipboardData: {
      setData(type, value) { lastCopyData[type] = value; }
    }
  });
  _triggerEditorEvent(editor, event);
}

function triggerPasteEvent(editor) {
  let eventData = {
    clipboardData: {
      getData(type) { return lastCopyData[type]; }
    }
  };

  let event = createMockEvent('paste', editor.element, eventData);
  _triggerEditorEvent(editor, event);
}

function triggerDropEvent(editor, {html, text, clientX, clientY}) {
  if (!clientX || !clientY) { throw new Error('Must pass clientX, clientY'); }
  let event = createMockEvent('drop', editor.element, {
    clientX,
    clientY,
    dataTransfer: {
      getData(mimeType) {
        switch(mimeType) {
          case MIME_TEXT_HTML:
            return html;
          case MIME_TEXT_PLAIN:
            return text;
          default:
            throw new Error('invalid mime type ' + mimeType);
        }
      }
    }
  });

  _triggerEditorEvent(editor, event);
}

function getCopyData(type) {
  return lastCopyData[type];
}

function setCopyData(type, value) {
  lastCopyData[type] = value;
}

function clearCopyData() {
  Object.keys(lastCopyData).forEach(key => {
    delete lastCopyData[key];
  });
}

function fromHTML(html) {
  html = $.trim(html);
  let div = document.createElement('div');
  div.innerHTML = html;
  return div;
}

/**
 * Tests fail in IE when using `element.blur`, so remove focus by refocusing
 * on another item instead of blurring the editor element
 */
function blur() {
  let input = $('<input>');
  input.appendTo('#qunit-fixture');
  input.focus();
}

function getData(element, name) {
  if (element.dataset) {
    return element.dataset[name];
  } else {
    return element.getAttribute(dasherize(name));
  }
}

const DOMHelper = {
  moveCursorTo,
  moveCursorWithoutNotifyingEditorTo,
  selectRange,
  selectText,
  clearSelection,
  triggerEvent,
  build,
  fromHTML,
  KEY_CODES: Keycodes,
  getCursorPosition,
  getSelectedText,
  triggerDelete,
  triggerForwardDelete,
  triggerEnter,
  insertText,
  triggerKeyEvent,
  triggerKeyCommand,
  triggerRightArrowKey,
  triggerLeftArrowKey,
  triggerCopyEvent,
  triggerCutEvent,
  triggerPasteEvent,
  triggerDropEvent,
  getCopyData,
  setCopyData,
  clearCopyData,
  createMockEvent,
  findTextNode,
  blur,
  getData
};

/* global QUnit, $ */

function compareMarkers(actual, expected, assert, path, deepCompare) {
  if (actual.value !== expected.value) {
    assert.equal(actual.value, expected.value, `wrong value at ${path}`);
  }
  if (actual.markups.length !== expected.markups.length) {
    assert.equal(actual.markups.length, expected.markups.length,
                 `wrong markups at ${path}`);
  }
  if (deepCompare) {
    actual.markups.forEach((markup, index) => {
      comparePostNode(markup, expected.markups[index],
                      assert, `${path}:${index}`, deepCompare);
    });
  }
}

/* eslint-disable complexity */
function comparePostNode(actual, expected, assert, path='root', deepCompare=false) {
  if (!actual || !expected) {
    assert.ok(!!actual, `missing actual post node at ${path}`);
    assert.ok(!!expected, `missing expected post node at ${path}`);
    return;
  }
  if (actual.type !== expected.type) {
    assert.pushResult({
      result: false,
      actual: actual.type,
      expected: expected.type,
      message: `wrong type at ${path}`
    });
  }

  switch (actual.type) {
    case POST_TYPE:
      if (actual.sections.length !== expected.sections.length) {
        assert.equal(actual.sections.length, expected.sections.length,
                     `wrong sections for post`);
      }
      if (deepCompare) {
        actual.sections.forEach((section, index) => {
          comparePostNode(section, expected.sections.objectAt(index),
                          assert, `${path}:${index}`, deepCompare);
        });
      }
      break;
    case ATOM_TYPE:
      if (actual.name !== expected.name) {
        assert.equal(actual.name, expected.name, `wrong atom name at ${path}`);
      }
      compareMarkers(actual, expected, assert, path, deepCompare);
      break;
    case MARKER_TYPE:
      compareMarkers(actual, expected, assert, path, deepCompare);
      break;
    case MARKUP_SECTION_TYPE:
    case LIST_ITEM_TYPE:
      if (actual.tagName !== expected.tagName) {
        assert.equal(actual.tagName, expected.tagName, `wrong tagName at ${path}`);
      }
      if (actual.markers.length !== expected.markers.length) {
        assert.equal(actual.markers.length, expected.markers.length,
                     `wrong markers at ${path}`);
      }
      if (deepCompare) {
        actual.markers.forEach((marker, index) => {
          comparePostNode(marker, expected.markers.objectAt(index),
                          assert, `${path}:${index}`, deepCompare);
        });
      }
      break;
    case CARD_TYPE:
      if (actual.name !== expected.name) {
        assert.equal(actual.name, expected.name, `wrong card name at ${path}`);
      }
      if (!QUnit.equiv(actual.payload, expected.payload)) {
        assert.deepEqual(actual.payload, expected.payload,
                         `wrong card payload at ${path}`);
      }
      break;
    case LIST_SECTION_TYPE:
      if (actual.items.length !== expected.items.length) {
        assert.equal(actual.items.length, expected.items.length,
                     `wrong items at ${path}`);
      }
      if (deepCompare) {
        actual.items.forEach((item, index) => {
          comparePostNode(item, expected.items.objectAt(index),
                          assert, `${path}:${index}`, deepCompare);
        });
      }
      break;
    case IMAGE_SECTION_TYPE:
      if (actual.src !== expected.src) {
        assert.equal(actual.src, expected.src, `wrong image src at ${path}`);
      }
      break;
    case MARKUP_TYPE:
      if (actual.tagName !== expected.tagName) {
        assert.equal(actual.tagName, expected.tagName,
                     `wrong tagName at ${path}`);
      }
      if (!QUnit.equiv(actual.attributes, expected.attributes)) {
        assert.deepEqual(actual.attributes, expected.attributes,
                         `wrong attributes at ${path}`);
      }
      break;
    default:
      throw new Error('wrong type :' + actual.type);
  }
}
/* eslint-enable complexity */

function registerAssertions(QUnit) {
  QUnit.assert.isBlank = function(val, message=`value is blank`) {
    this.pushResult({
      result: val === null || val === undefined || val === '' || val === false,
      actual: `${val} (typeof ${typeof val})`,
      expected: `null|undefined|''|false`,
      message
    });
  };

  QUnit.assert.hasElement = function(selector,
                                     message=`hasElement "${selector}"`) {
    let found = $('#qunit-fixture').find(selector);
    this.pushResult({
      result: found.length > 0,
      actual: `${found.length} matches for '${selector}'`,
      expected: `>0 matches for '${selector}'`,
      message: message
    });
    return found;
  };

  QUnit.assert.hasNoElement = function(selector,
                                       message=`hasNoElement "${selector}"`) {
    let found = $(selector);
    this.pushResult({
      result: found.length === 0,
      actual: `${found.length} matches for '${selector}'`,
      expected: `0 matches for '${selector}'`,
      message: message
    });
    return found;
  };

  QUnit.assert.hasClass = function(element, className,
                               message=`element has class "${className}"`) {
    this.pushResult({
      result: element.classList.contains(className),
      actual: element.classList,
      expected: className,
      message
    });
  };

  QUnit.assert.notHasClass = function(element, className,
                               message=`element has class "${className}"`) {
    this.pushResult({
      result: !element.classList.contains(className),
      actual: element.classList,
      expected: className,
      message
    });
  };

  QUnit.assert.selectedText = function(text, message=`selectedText "${text}"`) {
    const selected = DOMHelper.getSelectedText();
    this.pushResult({
      result: selected === text,
      actual: selected,
      expected: text,
      message: message
    });
  };

  QUnit.assert.inArray = function(element, array,
                                  message=`has "${element}" in "${array}"`) {
    QUnit.assert.ok(array.indexOf(element) !== -1, message);
  };

  QUnit.assert.postIsSimilar = function(post, expected, postName='post') {
    comparePostNode(post, expected, this, postName, true);
    let mobiledoc         = mobiledocRenderers.render(post),
        expectedMobiledoc = mobiledocRenderers.render(expected);
    this.deepEqual(mobiledoc, expectedMobiledoc,
                   `${postName} is similar to expected`);
  };

  QUnit.assert.renderTreeIsEqual = function(renderTree, expectedPost) {
    if (renderTree.rootNode.isDirty) {
      this.ok(false, 'renderTree is dirty');
      return;
    }

    expectedPost.sections.forEach((section, index) => {
      let renderNode = renderTree.rootNode.childNodes.objectAt(index);
      let path = `post:${index}`;

      let compareChildren = (parentPostNode, parentRenderNode, path) => {
        let children = parentPostNode.markers ||
                       parentPostNode.items ||
                       [];

        if (children.length !== parentRenderNode.childNodes.length) {
          this.equal(parentRenderNode.childNodes.length, children.length,
                     `wrong child render nodes at ${path}`);
          return;
        }

        children.forEach((child, index) => {
          let renderNode = parentRenderNode.childNodes.objectAt(index);

          comparePostNode(child, renderNode && renderNode.postNode,
                          this, `${path}:${index}`, false);
          compareChildren(child, renderNode, `${path}:${index}`);
        });
      };

      comparePostNode(section, renderNode.postNode, this, path, false);
      compareChildren(section, renderNode, path);
    });

    this.ok(true, 'renderNode is similar');
  };

  QUnit.assert.positionIsEqual = function(position, expected,
                                          message=`position is equal`) {
    if (position.section !== expected.section) {
      this.pushResult({
        result: false,
        actual: `${position.section.type}:${position.section.tagName}`,
        expected: `${expected.section.type}:${expected.section.tagName}`,
        message: `incorrect position section (${message})`
      });
    } else if (position.offset !== expected.offset) {
      this.pushResult({
        result: false,
        actual: position.offset,
        expected: expected.offset,
        message: `incorrect position offset (${message})`
      });
    } else {
      this.pushResult({
        result: true,
        actual: position,
        expected: expected,
        message: message
      });
    }
  };

  QUnit.assert.rangeIsEqual = function(range, expected,
                                          message=`range is equal`) {
    let { head, tail, isCollapsed, direction } = range;
    let {
      head: expectedHead,
      tail: expectedTail,
      isCollapsed: expectedIsCollapsed,
      direction: expectedDirection
    } = expected;

    let failed = false;

    if (!head.isEqual(expectedHead)) {
      failed = true;
      this.pushResult({
        result: false,
        actual: `${head.section.type}:${head.section.tagName}`,
        expected: `${expectedHead.section.type}:${expectedHead.section.tagName}`,
        message: 'incorrect head position'
      });
    }

    if (!tail.isEqual(expectedTail)) {
      failed = true;
      this.pushResult({
        result: false,
        actual: `${tail.section.type}:${tail.section.tagName}`,
        expected: `${expectedTail.section.type}:${expectedTail.section.tagName}`,
        message: 'incorrect tail position'
      });
    }

    if (isCollapsed !== expectedIsCollapsed) {
      failed = true;
      this.pushResult({
        result: false,
        actual: isCollapsed,
        expected: expectedIsCollapsed,
        message: 'wrong value for isCollapsed'
      });
    }

    if (direction !== expectedDirection) {
      failed = true;
      this.pushResult({
        result: false,
        actual: direction,
        expected: expectedDirection,
        message: 'wrong value for direction'
      });
    }

    if (!failed) {
      this.pushResult({
        result: true,
        actual: range,
        expected: expected,
        message: message
      });
    }
  };
}

/*
 * usage:
 *  Helpers.postAbstract.build(({post, section, marker, markup}) =>
 *    post([
 *      section('P', [
 *        marker('some text', [markup('B')])
 *      ])
 *    })
 *  )
 */
function build$1(treeFn) {
  let builder = new PostNodeBuilder();

  const simpleBuilder = {
    post          : (...args) => builder.createPost(...args),
    markupSection : (...args) => builder.createMarkupSection(...args),
    markup        : (...args) => builder.createMarkup(...args),
    marker        : (...args) => builder.createMarker(...args),
    listSection   : (...args) => builder.createListSection(...args),
    listItem      : (...args) => builder.createListItem(...args),
    cardSection   : (...args) => builder.createCardSection(...args),
    imageSection  : (...args) => builder.createImageSection(...args),
    atom          : (...args) => builder.createAtom(...args)
  };

  return treeFn(simpleBuilder);
}

let cardRegex = /\[(.*)\]/;
let markupRegex = /\*/g;
let listStartRegex = /^\* /;
let cursorRegex = /<|>|\|/g;

function parsePositionOffsets(text) {
  let offsets = {};

  if (cardRegex.test(text)) {
    [['|','solo'],['<','start'],['>','end']].forEach(([char, type]) => {
      if (text.indexOf(char) !== -1) {
        offsets[type] = text.indexOf(char) === 0 ? 0 : 1;
      }
    });
  } else {
    if (listStartRegex.test(text)) {
      text = text.replace(listStartRegex, '');
    }
    text = text.replace(markupRegex,'');
    if (text.indexOf('|') !== -1) {
      offsets.solo = text.indexOf('|');
    } else if (text.indexOf('<') !== -1 || text.indexOf('>') !== -1) {
      let hasStart = text.indexOf('<') !== -1;
      let hasEnd = text.indexOf('>') !== -1;
      if (hasStart) {
        offsets.start = text.indexOf('<');
        text = text.replace(/</g,'');
      }
      if (hasEnd) {
        offsets.end = text.indexOf('>');
      }
    }
  }

  return offsets;
}

const DEFAULT_ATOM_NAME = 'some-atom';
const DEFAULT_ATOM_VALUE = '@atom';

const MARKUP_CHARS = {
  '*': 'b',
  '_': 'em'
};

function parseTextIntoAtom(text, builder) {
  let markers = [];
  let atomIndex = text.indexOf('@');
  let afterAtomIndex = atomIndex + 1;
  let atomName = DEFAULT_ATOM_NAME,
      atomValue = DEFAULT_ATOM_VALUE,
      atomPayload = {};

  // If "@" is followed by "( ... json ... )", parse the json data
  if (text[atomIndex+1] === "(") {
    let jsonStartIndex = atomIndex+1;
    let jsonEndIndex = text.indexOf(")",jsonStartIndex);
    afterAtomIndex = jsonEndIndex + 1;
    if (jsonEndIndex === -1) {
      throw new Error('Atom JSON data had unmatched "(": ' + text);
    }
    let jsonString = text.slice(jsonStartIndex+1, jsonEndIndex);
    jsonString = "{" + jsonString + "}";
    try {
      let json = JSON.parse(jsonString);
      if (json.name) { atomName = json.name; }
      if (json.value) { atomValue = json.value; }
      if (json.payload) { atomPayload = json.payload; }
    } catch(e) {
      throw new Error('Failed to parse atom JSON data string: ' + jsonString + ', ' + e);
    }
  }

  // create the atom
  let atom = builder.atom(atomName, atomValue, atomPayload);

  // recursively parse the remaining text pieces
  let pieces = [text.slice(0, atomIndex), atom, text.slice(afterAtomIndex)];

  // join the markers together
  pieces.forEach((piece, index) => {
    if (index === 1) { // atom
      markers.push(piece);
    } else if (piece.length) {
      markers = markers.concat(parseTextIntoMarkers(piece, builder));
    }
  });

  return markers;
}

function parseTextWithMarkup(text, builder) {
  let markers = [];
  let markup, char;
  Object.keys(MARKUP_CHARS).forEach(key => {
    if (markup) { return; }
    if (text.indexOf(key) !== -1) {
      markup = builder.markup(MARKUP_CHARS[key]);
      char = key;
    }
  });
  if (!markup) { throw new Error(`Failed to find markup in text: ${text}`); }

  let startIndex = text.indexOf(char);
  let endIndex = text.indexOf(char, startIndex+1);
  if (endIndex === -1) { throw new Error(`Malformed text: char ${char} do not match`); }

  let pieces = [text.slice(0, startIndex),
                text.slice(startIndex+1, endIndex),
                text.slice(endIndex+1)];
  pieces.forEach((piece, index) => {
    if (index === 1) { // marked-up text
      markers.push(builder.marker(piece, [markup]));
    } else {
      markers = markers.concat(parseTextIntoMarkers(piece, builder));
    }
  });

  return markers;
}

function parseTextIntoMarkers(text, builder) {
  text = text.replace(cursorRegex,'');
  let markers = [];

  let hasAtom = text.indexOf('@') !== -1;
  let hasMarkup = false;
  Object.keys(MARKUP_CHARS).forEach(key => {
    if (text.indexOf(key) !== -1) { hasMarkup = true; }
  });

  if (hasAtom) {
    markers = markers.concat(parseTextIntoAtom(text, builder));
  } else if (hasMarkup) {
    markers = markers.concat(parseTextWithMarkup(text, builder));
  } else if (text.length) {
    markers.push(builder.marker(text));
  }

  return markers;
}

function parseSingleText(text, builder) {
  let section, positions = {};

  let offsets = parsePositionOffsets(text);

  if (cardRegex.test(text)) {
    section = builder.cardSection(cardRegex.exec(text)[1]);
  } else {
    let type = 'p';
    if (listStartRegex.test(text)) {
      text = text.replace(listStartRegex,'');
      type = 'ul';
    }

    let markers = parseTextIntoMarkers(text, builder);

    switch (type) {
      case 'p':
        section = builder.markupSection('p', markers);
        break;
      case 'ul':
        section = builder.listItem(markers);
        break;
    }
  }

  ['start','end','solo'].forEach(type => {
    if (offsets[type] !== undefined) {
      positions[type] = section.toPosition(offsets[type]);
    }
  });

  return { section, positions };
}

/**
 * Shorthand to create a mobiledoc simply.
 * Pass a string or an array of strings.
 *
 * Returns { post, range }, a post built from the mobiledoc and a range.
 *
 * Use "|" to indicate the cursor position or "<" and ">" to indicate a range.
 * Use "[card-name]" to indicate a card
 * Use asterisks to indicate bold text: "abc *bold* def"
 * Use "@" to indicate an atom, default values for name,value,payload are DEFAULT_ATOM_NAME,DEFAULT_ATOM_VALUE,{}
 * Use "@(name, value, payload)" to specify name,value and/or payload for an atom. The string from `(` to `)` is parsed as
 *   JSON, e.g.: '@("name": "my-atom", "value": "abc", "payload": {"foo": "bar"})' -> atom named "my-atom" with value 'abc', payload {foo: 'bar'}
 * Use "* " at the start of the string to indicate a list item ("ul")
 *
 * Examples:
 * buildFromText("abc") -> { post } with 1 markup section ("p") with text "abc"
 * buildFromText(["abc","def"]) -> { post } with 2 markups sections ("p") with texts "abc" and "def"
 * buildFromText("abc|def") -> { post, range } where range is collapsed at offset 3 (after the "c")
 * buildFromText(["abcdef","[some-card]","def"]) -> { post } with [MarkupSection, Card, MarkupSection] sections
 * buildFromText(["* item 1", "* item 2"]) -> { post } with a ListSection with 2 ListItems
 * buildFromText(["<abc", "def", "ghi>"]) -> { post, range } where range is the entire post (before the "a" to after the "i")
 */
function buildFromText(texts) {
  if (!Array.isArray(texts)) { texts = [texts]; }
  let positions = {};

  let post = build$1(builder => {
    let sections = [];
    let curList;
    texts.forEach((text, index) => {
      let { section, positions: _positions } = parseSingleText(text, builder);
      let lastText = index === texts.length - 1;

      if (curList) {
        if (section.isListItem) {
          curList.items.append(section);
        } else {
          sections.push(curList);
          sections.push(section);
          curList = null;
        }
      } else if (section.isListItem) {
        curList = builder.listSection('ul', [section]);
      } else {
        sections.push(section);
      }

      if (lastText && curList) {
        sections.push(curList);
      }

      if (_positions.start) { positions.start = _positions.start; }
      if (_positions.end) { positions.end = _positions.end; }
      if (_positions.solo) { positions.solo = _positions.solo; }
    });

    return builder.post(sections);
  });

  let range;
  if (positions.start) {
    if (!positions.end) { throw new Error(`startPos but no endPos ${texts.join('\n')}`); }
    range = positions.start.toRange(positions.end);
  } else if (positions.solo) {
    range = positions.solo.toRange();
  }

  return { post, range };
}


var PostAbstract = {
  build: build$1,
  buildFromText,
  DEFAULT_ATOM_NAME
};

/*
 * usage:
 *  build(({post, section, marker, markup}) =>
 *    post([
 *      section('P', [
 *        marker('some text', [markup('B')])
 *      ])
 *    })
 *  )
 *  @return Mobiledoc
 */
function build$2(treeFn, version) {
  let post = PostAbstract.build(treeFn);
  switch (version) {
    case MOBILEDOC_VERSION:
      return MobiledocRenderer.render(post);
    case MOBILEDOC_VERSION$1:
      return MobiledocRenderer$1.render(post);
    case MOBILEDOC_VERSION$2:
      return MobiledocRenderer$2.render(post);
    case MOBILEDOC_VERSION$3:
      return MobiledocRenderer$3.render(post);
    case undefined:
    case null:
      return mobiledocRenderers.render(post);
    default:
      throw new Error(`Unknown version of mobiledoc renderer requested: ${version}`);
  }
}

function renderPostInto(element, post, editorOptions={}) {
  let mobiledoc = mobiledocRenderers.render(post);
  mergeWithOptions(editorOptions, {mobiledoc});
  let editor = new Editor(editorOptions);
  editor.render(element);
  return editor;
}

function renderInto(element, treeFn, editorOptions={}) {
  let mobiledoc = build$2(treeFn);
  mergeWithOptions(editorOptions, {mobiledoc});
  let editor = new Editor(editorOptions);
  editor.render(element);
  return editor;
}

// In Firefox, if the window isn't active (which can happen when running tests
// at SauceLabs), the editor element won't have the selection. This helper method
// ensures that it has a cursor selection.
// See https://github.com/bustle/mobiledoc-kit/issues/388
function renderIntoAndFocusTail(editorElement, treeFn, options={}) {
  let editor = renderInto(editorElement, treeFn, options);
  editor.selectRange(new Range(editor.post.tailPosition()));
  return editor;
}

var MobiledocHelpers = {
  build: build$2,
  renderInto,
  renderPostInto,
  renderIntoAndFocusTail
};

function detectIE() {
  let userAgent = navigator.userAgent;
  return userAgent.indexOf("MSIE ") !== -1 || userAgent.indexOf("Trident/") !== -1 || userAgent.indexOf('Edge/') !== -1;
}

function detectIE11() {
  return detectIE() && navigator.userAgent.indexOf("rv:11.0") !== -1;
}

function supportsSelectionExtend() {
  let selection = window.getSelection();
  return !!selection.extend;
}

let wait = (callback) => {
  window.requestAnimationFrame(callback);
};

class MockEditor {
  constructor(builder) {
    this.builder = builder;
    this.range = Range.blankRange();
  }
  run(callback) {
    let postEditor = new PostEditor(this);
    postEditor.begin();
    let result = callback(postEditor);
    postEditor.end();
    return result;
  }
  rerender() {}
  _postDidChange() {}
  selectRange(range) {
    this._renderedRange = range;
  }
  _readRangeFromDOM() {}
}

function renderBuiltAbstract(post, editor) {
  editor.post = post;
  let unknownCardHandler = () => {};
  let unknownAtomHandler = () => {};
  let renderer = new Renderer(
    editor, [], [], unknownCardHandler, unknownAtomHandler);
  let renderTree = new RenderTree(post);
  renderer.render(renderTree);
  return editor;
}

function run(post, callback) {
  let builder = new PostNodeBuilder();
  let editor = new MockEditor(builder);

  renderBuiltAbstract(post, editor);

  let postEditor = new PostEditor(editor);
  postEditor.begin();
  let result = callback(postEditor);
  postEditor.complete();
  return result;
}

function retargetPosition(position, toPost) {
  let fromPost = position.section.post;
  let sectionIndex;
  let retargetedPosition;
  fromPost.walkAllLeafSections((section,index) => {
    if (sectionIndex !== undefined) { return; }
    if (section === position.section) { sectionIndex = index; }
  });
  if (sectionIndex === undefined) {
    throw new Error('`retargetPosition` could not find section index');
  }
  toPost.walkAllLeafSections((section, index) => {
    if (retargetedPosition) { return; }
    if (index === sectionIndex) {
      retargetedPosition = section.toPosition(position.offset);
    }
  });
  if (!retargetedPosition) {
    throw new Error('`retargetPosition` could not find target section');
  }
  return retargetedPosition;
}

function retargetRange(range, toPost) {
  let newHead = retargetPosition(range.head, toPost);
  let newTail = retargetPosition(range.tail, toPost);

  return newHead.toRange(newTail);
}

function buildFromText$1(texts, editorOptions={}) {
  let renderElement = editorOptions.element;
  delete editorOptions.element;

  let beforeRender = editorOptions.beforeRender || function() {};
  delete editorOptions.beforeRender;

  let {post, range} = PostAbstract.buildFromText(texts);
  let mobiledoc = MobiledocRenderer$2.render(post);
  editorOptions.mobiledoc = mobiledoc;
  let editor = new Editor(editorOptions);
  if (renderElement) {
    beforeRender(editor);
    editor.render(renderElement);
    if (range) {
      range = retargetRange(range, editor.post);
      editor.selectRange(range);
    }
  }
  return editor;
}

var EditorHelpers = /*#__PURE__*/Object.freeze({
	__proto__: null,
	buildFromText: buildFromText$1,
	retargetRange: retargetRange,
	retargetPosition: retargetPosition
});

/* global QUnit */
registerAssertions(QUnit);

const { test:qunitTest, module, skip } = QUnit;

QUnit.config.urlConfig.push({
  id: 'debugTest',
  label: 'Debug Test'
});

const test = (msg, callback) => {
  let originalCallback = callback;
  callback = (...args) => {
    if (QUnit.config.debugTest) {
      // eslint-disable-next-line no-debugger
      debugger;
    }
    originalCallback(...args);
  };
  qunitTest(msg, callback);
};

const skipInIE11 = (msg, callback) => {
  if (detectIE11()) {
    skip('SKIPPED IN IE11: ' + msg, callback);
  } else {
    test(msg, callback);
  }
};

QUnit.testStart(() => {
  // The fixture is cleared between tests, clearing this
  $('<div id="editor"></div>').appendTo('#qunit-fixture');
});

let sauceLog = [];

QUnit.done(function (test_results) {
  var tests = [];
  for(var i = 0, len = sauceLog.length; i < len; i++) {
    var details = sauceLog[i];
    tests.push({
      name: details.name,
      result: details.result,
      expected: details.expected,
      actual: details.actual,
      source: details.source
    });
  }
  test_results.tests = tests;

  window.global_test_results = test_results;
});

QUnit.testStart(function(testDetails){
  QUnit.log(function(details){
    if (!details.result) {
      details.name = testDetails.name;
      sauceLog.push(details);
    }
  });
});

var Helpers = {
  dom: DOMHelper,
  mobiledoc: MobiledocHelpers,
  postAbstract: PostAbstract,
  editor: EditorHelpers,
  test,
  module,
  skipInIE11,
  skip,
  wait,
  postEditor: { run, renderBuiltAbstract, MockEditor }
};

let editorElement, editor;

const { module: module$1, test: test$1 } = Helpers;
const { postAbstract: { DEFAULT_ATOM_NAME: DEFAULT_ATOM_NAME$1 } } = Helpers;

module$1('Unit: Editor: Atom Lifecycle', {
  beforeEach() {
    editorElement = $('#editor')[0];
  },
  afterEach() {
    if (editor && !editor.isDestroyed) {
      editor.destroy();
      editor = null;
    }
  }
});

function makeEl(id, text='@atom') {
  let el = document.createElement('span');
  el.id = id;
  text = document.createTextNode(text);
  el.appendChild(text);
  return el;
}

// Default version is 0.2 for the moment
function build$3(fn) {
  return Helpers.mobiledoc.build(fn, MOBILEDOC_VERSION$2);
}

function assertRenderArguments(assert, args, expected) {
  let {env, options, payload} = args;

  assert.deepEqual(payload, expected.payload, 'correct payload');
  assert.deepEqual(options, expected.options, 'correct options');

  // basic env
  let {name, onTeardown} = env;
  assert.equal(name, expected.name, 'correct name');
  assert.ok(!!onTeardown, 'has onTeardown');
}

test$1('rendering a mobiledoc with atom calls atom#render', (assert) => {
  const atomPayload = { foo: 'bar' };
  const atomValue = "@bob";
  const cardOptions = { boo: 'baz' };
  const atomName = 'test-atom';

  let renderArg;

  const atom = {
    name: atomName,
    type: 'dom',
    render(_renderArg) {
      renderArg = _renderArg;
    }
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, atomValue, atomPayload)])])
  );

  editor = new Editor({mobiledoc, atoms: [atom], cardOptions});
  editor.render(editorElement);

  let expected = {
    name: atomName,
    payload: atomPayload,
    options: cardOptions
  };
  assertRenderArguments(assert, renderArg, expected);
});

test$1('rendering a mobiledoc with atom appends result of atom#render', (assert) => {
  const atomName = 'test-atom';

  const atom = {
    name: atomName,
    type: 'dom',
    render() {
      return makeEl('the-atom');
    }
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );
  editor = new Editor({mobiledoc, atoms: [atom]});
  assert.hasNoElement('#editor #the-atom', 'precond - atom not rendered');
  editor.render(editorElement);
  assert.hasElement('#editor #the-atom');
});

test$1('returning wrong type from render throws', (assert) => {
  const atomName = 'test-atom';

  const atom = {
    name: atomName,
    type: 'dom',
    render() {
      return 'string';
    }
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );
  editor = new Editor({mobiledoc, atoms: [atom]});

  assert.throws(() => {
    editor.render(editorElement);
  }, new RegExp(`Atom "${atomName}" must return a DOM node`));
});

test$1('returning undefined from render is ok', (assert) => {
  const atomName = 'test-atom';

  const atom = {
    name: atomName,
    type: 'dom',
    render() {}
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );
  editor = new Editor({mobiledoc, atoms: [atom]});
  editor.render(editorElement);
  assert.ok(true, 'no errors are thrown');
});

test$1('rendering atom with wrong type throws', (assert) => {
  const atomName = 'test-atom';
  const atom = {
    name: atomName,
    type: 'other',
    render() {}
  };
  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );

  assert.throws(() => {
    editor = new Editor({mobiledoc, atoms: [atom]});
    editor.render(editorElement);
  }, new RegExp(`Atom "${atomName}.* must define type`));
});

test$1('rendering atom without render method throws', (assert) => {
  const atomName = 'test-atom';
  const atom = {
    name: atomName,
    type: 'dom'
  };
  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );

  assert.throws(() => {
    editor = new Editor({mobiledoc, atoms: [atom]});
    editor.render(editorElement);
  }, new RegExp(`Atom "${atomName}.* must define.*render`));
});

test$1('rendering unknown atom calls #unknownAtomHandler', (assert) => {
  const payload = { foo: 'bar' };
  const cardOptions = { boo: 'baz' };
  const atomName = 'test-atom';
  const atomValue = '@bob';

  let unknownArg;
  const unknownAtomHandler = (_unknownArg) => {
    unknownArg = _unknownArg;
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, atomValue, payload)])])
  );

  editor = new Editor({mobiledoc, unknownAtomHandler, cardOptions});
  editor.render(editorElement);

  let expected = {
    name: atomName,
    value: atomValue,
    options: cardOptions,
    payload
  };
  assertRenderArguments(assert, unknownArg, expected);
});

test$1('rendering unknown atom without unknownAtomHandler throws', (assert) => {
  const atomName = 'test-atom';

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );

  editor = new Editor({mobiledoc, unknownAtomHandler: undefined});

  assert.throws(() => {
    editor.render(editorElement);
  }, new RegExp(`Unknown atom "${atomName}".*no unknownAtomHandler`));
});

test$1('onTeardown hook is called when editor is destroyed', (assert) => {
  const atomName = 'test-atom';

  let teardown;

  const atom = {
    name: atomName,
    type: 'dom',
    render({env}) {
      env.onTeardown(() => teardown = true);
    }
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );
  editor = new Editor({mobiledoc, atoms: [atom]});
  editor.render(editorElement);

  assert.ok(!teardown, 'nothing torn down yet');

  editor.destroy();

  assert.ok(teardown, 'onTeardown hook called');
});

test$1('onTeardown hook is called when atom is destroyed', (assert) => {
  let teardown;

  let atom = {
    name: DEFAULT_ATOM_NAME$1,
    type: 'dom',
    render({env}) {
      env.onTeardown(() => teardown = true);
      return makeEl('atom-id','atom-text');
    }
  };
  editor = Helpers.editor.buildFromText('abc@d|ef', {autofocus: true, atoms:[atom], element: editorElement});
  assert.hasElement('#editor #atom-id:contains(atom-text)', 'precond - shows atom');
  assert.ok(!teardown, 'precond - no teardown yet');
  Helpers.dom.triggerDelete(editor);

  assert.hasElement('#editor #atom-id:contains(atom-text)', 'precond - still shows atom');
  assert.ok(!teardown, 'precond - no teardown yet');
  Helpers.dom.triggerDelete(editor);

  assert.hasNoElement('*:contains(atom-text)', 'atom destroyed');
  assert.ok(teardown, 'calls teardown');
});

// See https://github.com/bustle/mobiledoc-kit/issues/421
test$1('render is not called again when modifying other parts of the section', (assert) => {
  let renderCount = 0;
  let atom = {
    name: DEFAULT_ATOM_NAME$1,
    type: 'dom',
    render() {
      renderCount++;
      return makeEl('the-atom');
    }
  };
  editor = Helpers.editor.buildFromText('abc|@def', {autofocus: true, atoms:[atom], element: editorElement});
  assert.equal(renderCount, 1, 'renders the atom initially');
  editor.insertText('123');
  assert.hasElement('#editor *:contains(abc123)', 'precond - inserts text');
  assert.equal(renderCount, 1, 'does not rerender the atom');
});

test$1('mutating the content of an atom does not trigger an update', (assert) => {
  assert.expect(5);
  const done = assert.async();

  const atomName = 'test-atom';

  let renderCount = 0;
  let teardown;

  const atom = {
    name: atomName,
    type: 'dom',
    render({env}) {
      renderCount++;
      env.onTeardown(() => teardown = true);
      return makeEl('the-atom');
    }
  };

  const mobiledoc = build$3(({markupSection, post, atom}) =>
    post([markupSection('p', [atom(atomName, '@bob', {})])])
  );
  editor = new Editor({mobiledoc, atoms: [atom]});

  let updateTriggered = false;
  editor.postDidChange(() => updateTriggered = true);

  assert.hasNoElement('#editor #the-atom', 'precond - atom not rendered');
  editor.render(editorElement);
  assert.equal(renderCount, 1, 'renders atom');

  $("#the-atom").html("updated");

  // ensure the mutations have had time to trigger
  Helpers.wait(function(){
    assert.ok(!updateTriggered);
    assert.equal(renderCount, 1, 'does not rerender atom');
    assert.ok(!teardown, 'does not teardown atom');
    done();
  });
});

test$1('atom env has "save" method, rerenders atom', (assert) => {
  let atomArgs = {};
  let render = 0;
  let teardown = 0;
  let postDidChange = 0;
  let save;

  const atom = {
    name: DEFAULT_ATOM_NAME$1,
    type: 'dom',
    render({env, value, payload}) {
      render++;
      atomArgs.value = value;
      atomArgs.payload = payload;
      save = env.save;

      env.onTeardown(() => teardown++);

      return makeEl('the-atom', value);
    }
  };

  editor = Helpers.editor.buildFromText('abc|@("value": "initial-value", "payload": {"foo": "bar"})def', {autofocus: true, atoms:[atom], element: editorElement});
  editor.postDidChange(() => postDidChange++);

  assert.equal(render, 1, 'precond - renders atom');
  assert.equal(teardown, 0, 'precond - did not teardown');
  assert.ok(!!save, 'precond - save hook');
  assert.deepEqual(atomArgs, {value:'initial-value', payload:{foo: "bar"}}, 'args initially empty');
  assert.hasElement(`#the-atom`, 'precond - displays atom');

  let value = 'new-value';
  let payload = {foo: 'baz'};
  postDidChange = 0;

  save(value, payload);

  assert.equal(render, 2, 'rerenders atom');
  assert.equal(teardown, 1, 'tears down atom');
  assert.deepEqual(atomArgs, {value, payload}, 'updates atom values');
  assert.ok(postDidChange, 'post changed when saving atom');
  assert.hasElement(`#the-atom:contains(${value})`);
});

let editorElement$1, editor$1;

const { module: module$2, test: test$2 } = Helpers;

module$2('Unit: Editor: Card Lifecycle', {
  beforeEach() {
    editorElement$1 = $('#editor')[0];
  },
  afterEach() {
    if (editor$1 && !editor$1.isDestroyed) {
      editor$1.destroy();
      editor$1 = null;
    }
  }
});


function makeEl$1(id) {
  let el = document.createElement('div');
  el.id = id;
  return el;
}

function assertRenderArguments$1(assert, args, expected) {
  let {env, options, payload} = args;

  assert.deepEqual(payload, expected.payload, 'correct payload');
  assert.deepEqual(options, expected.options, 'correct options');

  // basic env
  let {name, isInEditor, onTeardown, didRender} = env;
  assert.equal(name, expected.name, 'correct name');
  assert.equal(isInEditor, expected.isInEditor, 'correct isInEditor');
  assert.ok(!!onTeardown, 'has onTeardown');
  assert.ok(!!didRender, 'has didRender');

  // editor env hooks
  let {save, cancel, edit, remove} = env;
  assert.ok(!!save && !!cancel && !!edit && !!remove,
            'has save, cancel, edit, remove hooks');

  // postModel
  let {postModel} = env;
  assert.ok(postModel && postModel === expected.postModel,
            'correct postModel');
}

test$2('rendering a mobiledoc with card calls card#render', (assert) => {
  const payload = { foo: 'bar' };
  const cardOptions = { boo: 'baz' };
  const cardName = 'test-card';

  let renderArg;

  const card = {
    name: cardName,
    type: 'dom',
    render(_renderArg) {
      renderArg = _renderArg;
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection('test-card', payload)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card], cardOptions});
  editor$1.render(editorElement$1);

  let expected = {
    name: cardName,
    payload,
    options: cardOptions,
    isInEditor: true,
    postModel: editor$1.post.sections.head
  };
  assertRenderArguments$1(assert, renderArg, expected);
});

test$2('rendering a mobiledoc with card appends result of card#render', (assert) => {
  const cardName = 'test-card';

  const card = {
    name: cardName,
    type: 'dom',
    render() {
      return makeEl$1('the-card');
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  assert.hasNoElement('#editor #the-card', 'precond - card not rendered');
  editor$1.render(editorElement$1);
  assert.hasElement('#editor #the-card');
});

test$2('returning wrong type from render throws', (assert) => {
  const cardName = 'test-card';

  const card = {
    name: cardName,
    type: 'dom',
    render() {
      return 'string';
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});

  assert.throws(() => {
    editor$1.render(editorElement$1);
  }, new RegExp(`Card "${cardName}" must render dom`));
});

test$2('returning undefined from render is ok', (assert) => {
  const cardName = 'test-card';

  const card = {
    name: cardName,
    type: 'dom',
    render() {}
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection('test-card')])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  editor$1.render(editorElement$1);
  assert.ok(true, 'no errors are thrown');
});

test$2('returning undefined from render is ok', (assert) => {
  const cardName = 'test-card';
  let currentMode;
  let editHook;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      currentMode = 'display';
      editHook = env.edit;
    },
    edit() {
      currentMode = 'edit';
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  editor$1.render(editorElement$1);

  assert.equal(currentMode, 'display', 'precond - display');
  editHook();
  assert.equal(currentMode, 'edit', 'edit mode, no errors when returning undefined');
});

test$2('rendering card with wrong type throws', (assert) => {
  const cardName = 'test-card';
  const card = {
    name: cardName,
    type: 'other',
    render() {}
  };
  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );

  assert.throws(() => {
    editor$1 = new Editor({mobiledoc, cards: [card]});
    editor$1.render(editorElement$1);
  }, new RegExp(`Card "${cardName}.* must define type`));
});

test$2('rendering card without render method throws', (assert) => {
  const cardName = 'test-card';
  const card = {
    name: cardName,
    type: 'dom'
  };
  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );

  assert.throws(() => {
    editor$1 = new Editor({mobiledoc, cards: [card]});
    editor$1.render(editorElement$1);
  }, new RegExp(`Card "${cardName}.* must define.*render`));
});


test$2('card can call `env.edit` to render in edit mode', (assert) => {
  const payload = { foo: 'bar' };
  const cardOptions = { boo: 'baz' };
  const cardName = 'test-card';

  let editArg;
  let editHook;
  let currentMode;
  let displayId = 'the-display-card';
  let editId = 'the-edit-card';

  const card = {
    name: cardName,
    type: 'dom',
    render(_renderArg) {
      currentMode = 'display';
      editHook = _renderArg.env.edit;
      return makeEl$1(displayId);
    },
    edit(_editArg) {
      currentMode = 'edit';
      editArg = _editArg;
      return makeEl$1(editId);
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName, payload)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card], cardOptions});
  editor$1.render(editorElement$1);

  assert.hasElement(`#editor #${displayId}`, 'precond - display card');
  assert.hasNoElement(`#editor #${editId}`, 'precond - no edit card');
  assert.equal(currentMode, 'display');

  editHook();

  assert.equal(currentMode, 'edit');
  assert.hasNoElement(`#editor #${displayId}`, 'no display card');
  assert.hasElement(`#editor #${editId}`, 'renders edit card');

  let expected = {
    name: cardName,
    payload,
    options: cardOptions,
    isInEditor: true,
    postModel: editor$1.post.sections.head
  };
  assertRenderArguments$1(assert, editArg, expected);
});


test$2('save hook updates payload when in display mode', (assert) => {
  const cardName = 'test-card';
  let saveHook;
  let postModel;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      saveHook = env.save;
      postModel = env.postModel;
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({ mobiledoc, cards: [card] });
  editor$1.render(editorElement$1);

  let newPayload = {newPayload: true};
  saveHook(newPayload);
  assert.deepEqual(postModel.payload, newPayload,
                   'save updates payload when called without transition param');

  let otherNewPayload = {otherNewPayload: true};
  saveHook(otherNewPayload, false);
  assert.deepEqual(postModel.payload, otherNewPayload,
                   'save updates payload when called with transition=false');
});


test$2('save hook updates payload when in edit mode', (assert) => {
  const cardName = 'test-card';
  let saveHook;
  let editHook;
  let postModel;
  let currentMode;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      currentMode = 'display';
      editHook = env.edit;
      postModel = env.postModel;
    },
    edit({env}) {
      currentMode = 'edit';
      saveHook = env.save;
      postModel = env.postModel;
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({ mobiledoc, cards: [card] });
  editor$1.render(editorElement$1);

  assert.equal(currentMode, 'display', 'precond - display mode');

  editHook();

  assert.equal(currentMode, 'edit', 'precond - edit mode');
  let newPayload = {newPayload: true};
  saveHook(newPayload, false);

  assert.equal(currentMode, 'edit', 'save with false does not transition');
  assert.deepEqual(postModel.payload, newPayload, 'updates payload');

  let otherNewPayload = {otherNewPayload: true};
  saveHook(otherNewPayload);
  assert.equal(currentMode, 'display', 'save hook transitions');
  assert.deepEqual(postModel.payload, otherNewPayload, 'updates payload');
});


test$2('#cancel hook changes from edit->display, does not change payload', (assert) => {
  const cardName = 'test-card';
  let cancelHook;
  let editHook;
  let postModel;
  let currentMode;
  let currentPayload;
  let originalPayload = {foo: 'bar'};

  const card = {
    name: cardName,
    type: 'dom',
    render({env, payload}) {
      currentMode = 'display';
      editHook = env.edit;
      postModel = env.postModel;
      currentPayload = payload;
    },
    edit({env}) {
      currentMode = 'edit';
      cancelHook = env.cancel;
      postModel = env.postModel;
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName, originalPayload)])
  );
  editor$1 = new Editor({ mobiledoc, cards: [card] });
  editor$1.render(editorElement$1);

  assert.equal(currentMode, 'display', 'precond - display mode');

  editHook();

  assert.equal(currentMode, 'edit', 'precond - edit mode');

  cancelHook();

  assert.equal(currentMode, 'display', 'cancel hook transitions');
  assert.deepEqual(currentPayload, originalPayload, 'payload is the same');
});


test$2('#remove hook destroys card when in display mode, removes it from DOM and AT', (assert) => {
  const cardName = 'test-card';
  let removeHook;
  let elId = 'the-card';

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      removeHook = env.remove;
      return makeEl$1(elId);
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({ mobiledoc, cards: [card] });
  editor$1.render(editorElement$1);

  assert.hasElement(`#editor #${elId}`, 'precond - renders card');
  assert.ok(!!editor$1.post.sections.head, 'post has head section');

  removeHook();

  assert.hasNoElement(`#editor #${elId}`, 'removes rendered card');
  assert.ok(!editor$1.post.sections.head, 'post has no head section');
});


test$2('#remove hook destroys card when in edit mode, removes it from DOM and AT', (assert) => {
  const cardName = 'test-card';
  let removeHook;
  let editHook;
  let currentMode;
  let displayId = 'the-display-card';
  let editId = 'the-edit-card';

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      currentMode = 'display';
      editHook = env.edit;
      return makeEl$1(displayId);
    },
    edit({env}) {
      currentMode = 'edit';
      removeHook = env.remove;
      return makeEl$1(editId);
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({ mobiledoc, cards: [card] });
  editor$1.render(editorElement$1);

  assert.equal(currentMode, 'display', 'precond - display mode');
  assert.hasElement(`#editor #${displayId}`, 'precond - renders card in display');

  editHook();

  assert.equal(currentMode, 'edit', 'precond - edit mode');

  assert.hasElement(`#editor #${editId}`, 'precond - renders card in edit');
  assert.hasNoElement(`#editor #${displayId}`, 'display card is removed');
  assert.ok(!!editor$1.post.sections.head, 'post has head section');

  removeHook();

  assert.hasNoElement(`#editor #${editId}`, 'removes rendered card');
  assert.hasNoElement(`#editor #${displayId}`, 'display card is not present');
  assert.ok(!editor$1.post.sections.head, 'post has no head section');
});

test$2('rendering unknown card calls #unknownCardHandler', (assert) => {
  const payload = { foo: 'bar' };
  const cardOptions = { boo: 'baz' };
  const cardName = 'test-card';

  let unknownArg;
  const unknownCardHandler = (_unknownArg) => {
    unknownArg = _unknownArg;
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName, payload)])
  );

  editor$1 = new Editor({mobiledoc, unknownCardHandler, cardOptions});
  editor$1.render(editorElement$1);

  let expected = {
    name: cardName,
    payload,
    options: cardOptions,
    isInEditor: true,
    postModel: editor$1.post.sections.head
  };
  assertRenderArguments$1(assert, unknownArg, expected);
});

test$2('rendering unknown card without unknownCardHandler throws', (assert) => {
  const cardName = 'test-card';

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );

  editor$1 = new Editor({mobiledoc, unknownCardHandler: undefined});

  assert.throws(() => {
    editor$1.render(editorElement$1);
  }, new RegExp(`Unknown card "${cardName}".*no unknownCardHandler`));
});

test$2('onTeardown hook is called when moving from display->edit and back', (assert) => {
  const cardName = 'test-card';

  let editHook;
  let saveHook;
  let currentMode;
  let teardown;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      currentMode = 'display';
      editHook = env.edit;
      env.onTeardown(() => teardown = 'display');
    },
    edit({env}) {
      currentMode = 'edit';
      saveHook = env.save;
      env.onTeardown(() => teardown = 'edit');
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  editor$1.render(editorElement$1);

  assert.equal(currentMode, 'display', 'precond - display mode');
  assert.ok(!teardown, 'no teardown called yet');

  editHook();

  assert.equal(currentMode, 'edit', 'edit mode');
  assert.equal(teardown, 'display', 'display onTeardown hook called');

  saveHook();

  assert.equal(currentMode, 'display', 'display mode');
  assert.equal(teardown, 'edit', 'edit onTeardown hook called');
});

test$2('onTeardown hook is called when card removes itself', (assert) => {
  const cardName = 'test-card';

  let removeHook;
  let teardown;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      removeHook = env.remove;
      env.onTeardown(() => teardown = true);
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  editor$1.render(editorElement$1);

  assert.ok(!teardown, 'nothing torn down yet');

  removeHook();

  assert.ok(teardown, 'onTeardown hook called');
});

test$2('onTeardown hook is called when editor is destroyed', (assert) => {
  const cardName = 'test-card';

  let teardown;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      env.onTeardown(() => teardown = true);
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  editor$1.render(editorElement$1);

  assert.ok(!teardown, 'nothing torn down yet');

  editor$1.destroy();

  assert.ok(teardown, 'onTeardown hook called');
});

test$2('didRender hook is called when moving from display->edit and back', (assert) => {
  const cardName = 'test-card';

  let editHook;
  let saveHook;
  let currentMode;
  let rendered;

  const card = {
    name: cardName,
    type: 'dom',
    render({env}) {
      currentMode = 'display';
      editHook = env.edit;
      env.didRender(() => rendered = 'display');
      return makeEl$1('display-card');
    },
    edit({env}) {
      currentMode = 'edit';
      saveHook = env.save;
      env.didRender(() => rendered = 'edit');
      return makeEl$1('edit-card');
    }
  };

  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) =>
    post([cardSection(cardName)])
  );
  editor$1 = new Editor({mobiledoc, cards: [card]});
  editor$1.render(editorElement$1);

  assert.equal(currentMode, 'display', 'precond - display mode');
  assert.ok(rendered, 'didRender called on instantiation');

  editHook();

  assert.equal(currentMode, 'edit', 'edit mode');
  assert.equal(rendered, 'edit', 'display didRender hook called');

  saveHook();

  assert.equal(currentMode, 'display', 'display mode');
  assert.equal(rendered, 'display', 'edit didRender hook called');
});

const { module: module$3, test: test$3 } = Helpers;

let editor$2, editorElement$2;

const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
  return post([markupSection('p', [marker('this is the editor')])]);
});

module$3('Unit: Editor: events and lifecycle callbacks', {
  beforeEach() {
    editorElement$2 = $('#editor')[0];
    editor$2 = new Editor({mobiledoc});
    editor$2.render(editorElement$2);

    // Tests in FF can fail if the window is not front-most and
    // we don't explicitly render the range
    editor$2.selectRange(new Range(editor$2.post.tailPosition()));
  },

  afterEach() {
    if (editor$2 && !editor$2.isDestroyed) {
      editor$2.destroy();
      editor$2 = null;
    }
  }
});

test$3('cursorDidChange callback does not fire when selection is set to the same value', (assert) => {
  assert.expect(1);
  let done = assert.async();

  let cursorChanged = 0;
  editor$2.cursorDidChange(() => cursorChanged++);

  let node = Helpers.dom.findTextNode(editorElement$2, 'this is the editor');
  Helpers.dom.selectRange(node, 0, node, 0);

  Helpers.wait(() => {
    cursorChanged = 0;

    Helpers.dom.selectRange(node, 0, node, 0);

    Helpers.wait(() => {
      assert.equal(cursorChanged, 0, 'cursor did not change when selection is set to same value');

      done();
    });
  });
});

test$3('cursorDidChange callback fires when editor loses focus', (assert) => {
  assert.expect(1);
  let done = assert.async();

  Helpers.wait(() => {
    // Tests in FF can fail if the window is not front-most and
    // we don't explicitly render the range
    let node = Helpers.dom.findTextNode(editor$2.element, 'this is the editor');
    Helpers.dom.selectRange(node, 0, node, 0);

    Helpers.wait(() => {
      let cursorChanged = 0;
      editor$2.cursorDidChange(() => cursorChanged++);

      Helpers.dom.clearSelection();

      Helpers.wait(() => {
        assert.equal(cursorChanged, 1, 'cursor changed after clearing selection');

        done();
      });
    });
  });
});

test$3('cursorDidChange callback not fired if editor is destroyed', (assert) => {
  assert.expect(2);
  let done = assert.async();

  let cursorChanged = 0;
  editor$2.cursorDidChange(() => cursorChanged++);

  Helpers.dom.clearSelection();

  Helpers.wait(() => {
    cursorChanged = 0;
    let node = Helpers.dom.findTextNode(editor$2.element, 'this is the editor');
    Helpers.dom.selectRange(node, 0, node, 0);

    Helpers.wait(() => {
      assert.equal(cursorChanged, 1, 'precond - cursor change fires');

      cursorChanged = 0;
      editor$2.destroy();
      Helpers.dom.clearSelection();

      Helpers.wait(() => {
        assert.equal(cursorChanged, 0, 'callback not fired');

        done();
      });
    });
  });
});

test$3('cursorChanged callback fired after editor.run sets range', (assert) => {
  assert.expect(2);
  let done = assert.async();

  let cursorChanged = 0;
  editor$2.cursorDidChange(() => cursorChanged++);

  Helpers.wait(() => {
    assert.equal(cursorChanged, 0, 'precond - no cursor change');

    editor$2.run(postEditor => {
      let position = editor$2.post.headPosition();
      postEditor.insertText(position, 'blah');
      postEditor.setRange(new Range(editor$2.post.tailPosition()));
    });

    Helpers.wait(() => {
      assert.equal(cursorChanged, 1, 'cursor changes after editor.run sets position');

      done();
    });
  });
});

test$3('postDidChange callback fired when post is programmatically modified', (assert) => {
  assert.expect(1);

  let postChanged = 0;
  editor$2.postDidChange(() => postChanged++);
  editor$2.run(postEditor => {
    let position = editor$2.post.headPosition();
    postEditor.insertText(position, 'blah');
  });

  assert.equal(postChanged, 1, 'postDidChange fired once');
});

test$3('postDidChange callback fired when post is modified via user input', (assert) => {
  assert.expect(1);

  let postChanged = 0;
  editor$2.postDidChange(() => postChanged++);

  Helpers.dom.selectText(editor$2, "this is the editor", editorElement$2);
  Helpers.dom.triggerDelete(editor$2);

  assert.equal(postChanged, 1, 'postDidChange fired once');
});

test$3('postDidChange callback fired when card payload changes', (assert) => {
  let env;
  let cards = [{
    name: 'simple-card',
    type: 'dom',
    render({env: _env}) {
      env = _env;
      return $('<div id="my-simple-card">simple-card (display)</div>')[0];
    },
    edit({env: _env}) {
      env = _env;
      return $('<div id="my-simple-card">simple-card (edit)</div>')[0];
    }
  }];
  let editor = Helpers.mobiledoc.renderInto(editorElement$2, ({post, cardSection}) => {
    return post([cardSection('simple-card')]);
  }, { cards });

  let postDidChange = 0;
  editor.postDidChange(() => postDidChange++);

  env.save({});
  assert.equal(postDidChange, 1, 'postDidChange called after save');

  postDidChange = 0;
  env.edit();
  assert.equal(postDidChange, 0, 'postDidChange not called after edit');

  postDidChange = 0;
  env.cancel();
  assert.equal(postDidChange, 0, 'postDidChange not called after cancel');

  postDidChange = 0;
  env.remove();
  assert.equal(postDidChange, 1, 'postDidChange called after remove');

  editor.destroy();
});

test$3('inputModeDidChange callback fired when markup is toggled and there is a selection', (assert) => {
  let done = assert.async();
  assert.expect(1);

  Helpers.dom.selectText(editor$2, "this is the editor", editorElement$2);

  Helpers.wait(() => {
    let inputChanged = 0;
    editor$2.inputModeDidChange(() => inputChanged++);

    editor$2.toggleMarkup('b');

    Helpers.wait(() => {
      assert.equal(inputChanged, 1, 'inputModeDidChange fired once');
      done();
    });
  });
});

test$3('inputModeDidChange callback fired when markup is toggled and selection is collapsed', (assert) => {
  let done = assert.async();
  assert.expect(2);

  editor$2.selectRange(new Range(editor$2.post.headPosition()));

  assert.ok(editor$2.range.isCollapsed, 'precond - range is collapsed');

  Helpers.wait(() => {
    let inputChanged = 0;
    editor$2.inputModeDidChange(() => inputChanged++);

    editor$2.toggleMarkup('b');

    Helpers.wait(() => {
      assert.equal(inputChanged, 1, 'inputModeDidChange fired once');
      done();
    });
  });
});

test$3('inputModeDidChange callback fired when moving cursor into markup', (assert) => {
  let done = assert.async();
  assert.expect(1);

  // setup - turn text bold
  Helpers.dom.selectText(editor$2, 'this is', editorElement$2);
  editor$2.toggleMarkup('b');
  editor$2.selectRange(Range.create(editor$2.post.sections.head, 'this is'.length));

  Helpers.wait(() => {
    let inputChanged = 0;
    editor$2.inputModeDidChange(() => inputChanged++);

    editor$2.selectRange(editor$2.range.move(1));

    Helpers.wait(() => {
      assert.equal(inputChanged, 1, 'inputModeDidChange fired once');
      done();
    });
  });
});

test$3('after #toggleMarkup, editor refocuses if it had selection', (assert) => {
  let done = assert.async();
  assert.expect(3);

  let button =
    $('<button>BOLD</button>')
      .appendTo('#qunit-fixture')
      .click(() => {
        Helpers.dom.selectText(editor$2, 'this', editorElement$2); // necessary for Safari to detect a selection in the editor
        button.focus();

        assert.ok(document.activeElement !== editor$2.element, 'precond - editor element is not focused');
        editor$2.toggleMarkup('b');
      });

  editor$2.selectRange(new Range(editor$2.post.headPosition()));

  Helpers.wait(() => {
    let inputChanged = 0;
    editor$2.inputModeDidChange(() => inputChanged++);

    button.click();

    Helpers.wait(() => {
      assert.equal(inputChanged, 1, 'inputModeDidChange fired once');
      assert.ok(document.activeElement === editor$2.element, 'editor element is focused');

      done();
    });
  });
});

test$3('inputModeDidChange callback fired when toggling section', (assert) => {
  let done = assert.async();
  assert.expect(1);

  Helpers.dom.selectText(editor$2, 'this is', editorElement$2);

  let inputChanged = 0;
  editor$2.inputModeDidChange(() => inputChanged++);

  editor$2.toggleSection('h2');

  Helpers.wait(() => {
    assert.equal(inputChanged, 1, 'inputModeDidChange fired once');
    done();
  });
});

test$3('inputModeDidChange callback not fired when toggle is no-op', (assert) => {
  let done = assert.async();
  assert.expect(1);

  Helpers.dom.selectText(editor$2, 'this is', editorElement$2);

  let inputChanged = 0;
  editor$2.inputModeDidChange(() => inputChanged++);

  editor$2.toggleSection('p'); // toggling to same section is no-op

  Helpers.wait(() => {
    assert.equal(inputChanged, 0, 'inputModeDidChange not fired');
    done();
  });
});

test$3('inputModeDidChange callback fired when moving cursor into section', (assert) => {
  let done = assert.async();
  assert.expect(2);

  editor$2.run(postEditor => {
    let marker = postEditor.builder.createMarker('abc');
    let newSection = postEditor.builder.createMarkupSection('h2', [marker]);
    postEditor.insertSectionAtEnd(newSection);
  });

  let inputChanged = 0;
  editor$2.inputModeDidChange(() => {
    inputChanged++;
  });

  assert.hasElement('h2:contains(abc)', 'precond - inserted h2');
  editor$2.selectRange(new Range(editor$2.post.sections.tail.headPosition()));

  Helpers.wait(() => {
    inputChanged = 0;

    editor$2.selectRange(new Range(editor$2.post.sections.head.tailPosition()));

    Helpers.wait(() => {
      assert.equal(inputChanged, 1, 'inputModeDidChange fired once');
      done();
    });
  });
});

test$3('inputModeDidChange callback not fired when moving cursor into same section', (assert) => {
  let done = assert.async();
  assert.expect(2);

  editor$2.run(postEditor => {
    let marker = postEditor.builder.createMarker('abc');
    let newSection = postEditor.builder.createMarkupSection('p', [marker]);
    postEditor.insertSectionAtEnd(newSection);
  });

  assert.hasElement('p:contains(abc)', 'precond - inserted p');
  editor$2.selectRange(new Range(editor$2.post.sections.tail.headPosition()));

  let inputChanged = 0;
  editor$2.inputModeDidChange(() => inputChanged++);

  Helpers.dom.triggerLeftArrowKey(editor$2);

  Helpers.wait(() => {
    assert.equal(inputChanged, 0, 'inputModeDidChange not fired');
    done();
  });
});

test$3('inputModeDidChange called when changing from ul to ol', (assert) => {
  assert.expect(4);

  editor$2.selectRange(new Range(editor$2.post.headPosition(), editor$2.post.tailPosition()));

  let inputChanged = 0;
  editor$2.inputModeDidChange(() => inputChanged++);

  editor$2.toggleSection('ul');

  assert.hasElement('#editor ul li', 'created ul');
  assert.equal(inputChanged, 1, 'precond - changed to ul');

  editor$2.toggleSection('ol');

  assert.hasElement('#editor ol li', 'created ol');
  assert.equal(inputChanged, 2, 'inputModeDidChange fired after ul->ol');
});

const { module: module$4, test: test$4 } = Helpers;

let editorElement$3, editor$3;

module$4('Unit: Editor', {
  beforeEach() {
    editorElement$3 = $('#editor')[0];
  },

  afterEach() {
    if (editor$3 && !editor$3.isDestroyed) {
      editor$3.destroy();
      editor$3 = null;
    }
  }
});

test$4('can render an editor via dom node reference', (assert) => {
  editor$3 = new Editor();
  editor$3.render(editorElement$3);
  assert.equal(editor$3.element, editorElement$3);
  assert.ok(editor$3.post);
});

test$4('autofocused editor hasCursor and has non-blank range after rendering', (assert) => {
  let done = assert.async();
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection}) => {
    return post([markupSection('p')]);
  });
  editor$3 = new Editor({autofocus: true, mobiledoc});
  assert.ok(!editor$3.hasCursor(), 'precond - editor has no cursor');
  assert.ok(editor$3.range.isBlank, 'precond - editor has blank range');

  editor$3.render(editorElement$3);

  Helpers.wait(() => {
    assert.ok(editor$3.hasCursor(), 'editor has cursor');
    assert.ok(!editor$3.range.isBlank, 'editor has non-blank range');
    done();
  });
});

test$4('creating an editor with DOM node throws', (assert) => {
  assert.throws(function() {
    editor$3 = new Editor(document.createElement('div'));
  }, /accepts an options object/);
});

test$4('rendering an editor without a class name adds appropriate class', (assert) => {
  editorElement$3.className = '';

  editor$3 = new Editor();
  editor$3.render(editorElement$3);
  assert.hasClass(editor$3.element, EDITOR_ELEMENT_CLASS_NAME);
});

test$4('rendering an editor adds EDITOR_ELEMENT_CLASS_NAME if not there', (assert) => {
  editorElement$3.className = 'abc def';

  editor$3 = new Editor();
  editor$3.render(editorElement$3);

  assert.hasClass(editor$3.element, EDITOR_ELEMENT_CLASS_NAME, `adds ${EDITOR_ELEMENT_CLASS_NAME}`);
  assert.hasClass(editor$3.element, 'abc', 'preserves existing classnames');
  assert.hasClass(editor$3.element, 'def', 'preserves existing classnames');
});

test$4('rendering an editor adds EDITOR_HAS_NO_CONTENT_CLASS_NAME if post has no content', (assert) => {
  editor$3 = new Editor();
  assert.ok(!editor$3.post.hasContent, 'precond - post has no content');
  editor$3.render(editorElement$3);

  assert.hasClass(editorElement$3, EDITOR_HAS_NO_CONTENT_CLASS_NAME);

  // Firefox requires that the cursor be placed explicitly for this test to pass,
  // `editor.focus()` won't work when running this test on CI in Firefox
  Helpers.dom.moveCursorTo(editor$3, editor$3.element, 0);

  editor$3.insertText('abc');
  assert.ok(editor$3.post.hasContent, 'editor has content');
  assert.notHasClass(editorElement$3, EDITOR_HAS_NO_CONTENT_CLASS_NAME, `removes "${EDITOR_HAS_NO_CONTENT_CLASS_NAME}" when editor has content`);

  editor$3.deleteRange(editor$3.post.toRange());
  assert.hasClass(editorElement$3, EDITOR_HAS_NO_CONTENT_CLASS_NAME, `adds "${EDITOR_HAS_NO_CONTENT_CLASS_NAME}" after editor content is all deleted`);
});

test$4('editor fires lifecycle hooks', (assert) => {
  assert.expect(4);
  let didCallUpdatePost, didCallWillRender, didCallDidRender;
  editor$3 = new Editor();
  editor$3.didUpdatePost(postEditor => {
    assert.ok(postEditor, 'Post editor provided');
    assert.ok(!didCallWillRender && !didCallDidRender,
              'didUpdatePost called before render hooks');
    didCallUpdatePost = true;
  });
  editor$3.willRender(() => {
    assert.ok(didCallUpdatePost && !didCallDidRender,
              'willRender called between didUpdatePost, didRender');
    didCallWillRender = true;
  });
  editor$3.didRender(() => {
    assert.ok(didCallUpdatePost && didCallWillRender,
              'didRender called last');
    didCallDidRender = true;
  });
  editor$3.render(editorElement$3);
});

test$4('editor fires lifecycle hooks for edit', (assert) => {
  assert.expect(4);
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection}) => {
    return post([markupSection()]);
  });
  editor$3 = new Editor({mobiledoc});
  editor$3.render(editorElement$3);

  let didCallUpdatePost, didCallWillRender, didCallDidRender;
  editor$3.didUpdatePost(postEditor => {
    assert.ok(postEditor, 'Post editor provided');
    assert.ok(!didCallWillRender && !didCallDidRender,
              'didUpdatePost called before render hooks');
    didCallUpdatePost = true;
  });
  editor$3.willRender(() => {
    assert.ok(didCallUpdatePost && !didCallDidRender,
              'willRender called between didUpdatePost, didRender');
    didCallWillRender = true;
  });
  editor$3.didRender(() => {
    assert.ok(didCallUpdatePost && didCallWillRender,
              'didRender called last');
    didCallDidRender = true;
  });

  editor$3.run(postEditor => {
    postEditor.removeSection(editor$3.post.sections.head);
  });
});

test$4('editor fires lifecycle hooks for noop edit', (assert) => {
  assert.expect(1);
  editor$3 = new Editor();
  editor$3.render(editorElement$3);

  editor$3.didUpdatePost(postEditor => {
    assert.ok(postEditor, 'Post editor provided');
  });
  editor$3.willRender(() => {
    assert.ok(false, 'willRender should not be called');
  });
  editor$3.didRender(() => {
    assert.ok(false, 'didRender should not be called');
  });

  editor$3.run(() => {});
});

test$4('editor parses and renders mobiledoc format', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('hello world')])]);
  });
  editorElement$3.innerHTML = '<p>something here</p>';
  editor$3 = new Editor({mobiledoc});
  editor$3.render(editorElement$3);

  assert.ok(editor$3.mobiledoc, 'editor has mobiledoc');
  assert.equal(editorElement$3.innerHTML,
               `<p>hello world</p>`);

  assert.deepEqual(editor$3.serialize(), mobiledoc,
                   'serialized editor === mobiledoc');
});

test$4('#serialize serializes to MOBILEDOC_VERSION by default', (assert) => {
  let mobiledoc2 = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, '0.2.0');
  let mobiledoc3 = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, '0.3.0');
  let mobiledoc3_1 = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, '0.3.1');
  let mobiledoc3_2 = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, '0.3.2');

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  assert.deepEqual(editor$3.serialize('0.2.0'), mobiledoc2, 'serializes 0.2.0');
  assert.deepEqual(editor$3.serialize('0.3.0'), mobiledoc3, 'serializes 0.3.0');
  assert.deepEqual(editor$3.serialize('0.3.1'), mobiledoc3_1, 'serializes 0.3.1');
  assert.deepEqual(editor$3.serialize('0.3.2'), mobiledoc3_2, 'serializes 0.3.2');
  assert.deepEqual(editor$3.serialize(), mobiledoc3_2, 'serializes 0.3.2 by default');

  assert.throws(
    () => editor$3.serialize('unknown'),
    /Unknown version/
  );
});

test$4('editor parses and renders html', (assert) => {
  editorElement$3.innerHTML = '<p>something here</p>';
  editor$3 = new Editor({html: '<p>hello world</p>'});
  editor$3.render(editorElement$3);

  assert.equal(editorElement$3.innerHTML,
               `<p>hello world</p>`);
});

test$4('editor parses and renders DOM', (assert) => {
  editorElement$3.innerHTML = '<p>something here</p>';
  editor$3 = new Editor({html: $('<p>hello world</p>')[0]});
  editor$3.render(editorElement$3);

  assert.equal(editorElement$3.innerHTML,
               `<p>hello world</p>`);
});

test$4('#detectMarkupInRange not found', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [1, normalizeTagName('p'), [
          [[], 0, 'hello world']
        ]]
      ]
    ]
  };
  editor$3 = new Editor({mobiledoc});
  editor$3.render(editorElement$3);

  let section = editor$3.post.sections.head;
  let range = Range.create(section, 0, section, section.text.length);
  let markup = editor$3.detectMarkupInRange(range, 'strong');
  assert.ok(!markup, 'selection is not strong');
});

test$4('#detectMarkupInRange matching bounds of marker', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [
        ['strong']
      ],
      [
        [1, normalizeTagName('p'), [
          [[0], 1, 'hello world']
        ]]
      ]
    ]
  };
  editor$3 = new Editor({mobiledoc});
  editor$3.render(editorElement$3);

  let section = editor$3.post.sections.head;
  let range = Range.create(section, 0, section, section.text.length);
  let markup = editor$3.detectMarkupInRange(range, 'strong');
  assert.ok(markup, 'selection has markup');
  assert.equal(markup.tagName, 'strong', 'detected markup is strong');
});

test$4('useful error message when given invalid mobiledoc', (assert) => {
  let badMobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      ["incorrect"]
    ]
  };
  assert.throws(() => {
    new Editor({mobiledoc: badMobiledoc});
  }, /unable to parse.*mobiledoc/i);
});

test$4('useful error message when given bad version of mobiledoc', (assert) => {
  let verybadMobiledoc = "not mobiledoc";
  assert.throws(() => {
    new Editor({mobiledoc: verybadMobiledoc});
  }, /Unknown version of mobiledoc parser requested/i);
});

test$4('activeSections of a rendered blank mobiledoc is an empty array', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post}) => {
    return post();
  });

  assert.ok(editor$3.hasRendered, 'editor has rendered');
  assert.equal(editor$3.activeSections.length, 0, 'empty activeSections');
});

test$4('activeSections is empty when the editor has no cursor', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, {autofocus: false});

  assert.ok(!editor$3.hasCursor(), 'precond - no cursor');
  assert.equal(editor$3.activeSections.length, 0, 'empty activeSections');
});

test$4('activeSectionAttributes of a rendered blank mobiledoc is an empty array', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post}) => {
    return post();
  });

  assert.ok(editor$3.hasRendered, 'editor has rendered');
  assert.deepEqual(editor$3.activeSectionAttributes, {}, 'empty activeSectionAttributes');
});

test$4('activeSectionAttributes is updated based on the selection', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')], false, { 'data-md-text-align': 'center' })]);
  }, {autofocus: false});

  assert.ok(!editor$3.hasCursor(), 'precond - no cursor');
  assert.deepEqual(editor$3.activeSectionAttributes, {}, 'empty activeSectionAttributes');

  let head = editor$3.post.sections.head;
  editor$3.selectRange(Range.create(head, 'abc'.length));
  assert.deepEqual(editor$3.activeSectionAttributes['text-align'], ['center'], 'active section attributes captured');
});

test$4('editor.cursor.hasCursor() is false before rendering', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(({post}) => post());
  editor$3 = new Editor({mobiledoc});

  assert.ok(!editor$3.cursor.hasCursor(), 'no cursor before rendering');

  Helpers.dom.moveCursorTo(editor$3, editorElement$3, 0);

  assert.ok(!editor$3.cursor.hasCursor(),
            'no cursor before rendering, even when selection exists');
});

test$4('#destroy clears selection if it has one', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(({post}) => post());
  editor$3 = new Editor({mobiledoc});
  editor$3.render(editorElement$3);

  Helpers.dom.moveCursorTo(editor$3, editorElement$3, 0);
  assert.ok(editor$3.cursor.hasCursor(), 'precond - has cursor');

  editor$3.destroy();

  assert.equal(window.getSelection().rangeCount, 0, 'selection is cleared');
});

test$4('#destroy does not clear selection if it is outside the editor element', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(({post}) => post());
  editor$3 = new Editor({mobiledoc});
  editor$3.render(editorElement$3);

  Helpers.dom.moveCursorTo(editor$3, $('#qunit-fixture')[0], 0);
  assert.ok(!editor$3.cursor.hasCursor(), 'precond - has no cursor');
  assert.equal(window.getSelection().rangeCount, 1, 'precond - has selection');

  editor$3.destroy();

  assert.equal(window.getSelection().rangeCount, 1, 'selection is not cleared');
});

test$4('editor parses HTML post using parser plugins', (assert) => {
  let seenTagNames = [];
  let parserPlugin = function(element) {
    seenTagNames.push(element.tagName);
  };
  let html = '<p><textarea></textarea><img></p>';
  editor$3 = new Editor({html, parserPlugins: [parserPlugin]});
  assert.ok(!!editor$3.post, 'editor loads post');

  assert.deepEqual(seenTagNames, ['P', 'TEXTAREA', 'IMG']);
});

test$4('#activeMarkups returns the markups at cursor when range is collapsed', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [
      marker('abc'),
      marker('def', [markup('b')]),
      marker('ghi')
    ])]);
  });

  let head = editor$3.post.sections.head;
  editor$3.selectRange(Range.create(head, 'abc'.length));
  assert.equal(editor$3.activeMarkups.length, 0, 'no active markups at left of bold text');

  editor$3.selectRange(Range.create(head, 'abcd'.length));
  assert.equal(editor$3.activeMarkups.length, 1, 'active markups in bold text');
  assert.ok(editor$3.hasActiveMarkup('b'), 'has bold active markup');

  editor$3.selectRange(Range.create(head, 'abcdef'.length));
  assert.equal(editor$3.activeMarkups.length, 1, 'active markups at end of bold text');
  assert.ok(editor$3.hasActiveMarkup('b'), 'has bold active markup');

  editor$3.selectRange(Range.create(head, 'abcdefg'.length));
  assert.equal(editor$3.activeMarkups.length, 0, 'no active markups after end of bold text');
});

test$4('#hasActiveMarkup returns true for complex markups', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [
      marker('abc '),
      marker('def', [markup('a', {href: 'http://bustle.com'})]),
      marker(' ghi')
    ])]);
  });

  let head = editor$3.post.sections.head;
  editor$3.selectRange(Range.create(head, 'abc '.length));
  assert.equal(editor$3.activeMarkups.length, 0, 'no active markups at left of linked text');

  editor$3.selectRange(Range.create(head, 'abc d'.length));
  assert.equal(editor$3.activeMarkups.length, 1, 'active markups in linked text');
  assert.ok(editor$3.hasActiveMarkup('a'), 'has A active markup');

  editor$3.selectRange(Range.create(head, 'abc def'.length));
  assert.equal(editor$3.activeMarkups.length, 0, 'active markups at end of linked text');

  editor$3.selectRange(Range.create(head, 'abc def '.length));
  assert.equal(editor$3.activeMarkups.length, 0, 'no active markups after end of linked text');
});

test$4('#insertText inserts text at cursor position, replacing existing range if non-collapsed', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    return post([markupSection('p', [ marker('b') ])]);
  });

  editor$3.selectRange(new Range(editor$3.post.tailPosition()));
  editor$3.insertText('Z');
  assert.equal(editor$3.post.sections.head.text, 'bZ');

  editor$3.selectRange(new Range(editor$3.post.headPosition()));
  editor$3.insertText('A');
  assert.equal(editor$3.post.sections.head.text, 'AbZ');

  editor$3.selectRange(Range.create(editor$3.post.sections.head, 'A'.length));
  editor$3.insertText('B');
  assert.equal(editor$3.post.sections.head.text, 'ABbZ');

  editor$3.selectRange(new Range(editor$3.post.headPosition(), editor$3.post.tailPosition()));
  editor$3.insertText('new stuff');
  assert.equal(editor$3.post.sections.head.text, 'new stuff');
});

test$4('#insertText inserts text at cursor position, inheriting active markups', (assert) => {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [
      marker('a'),
      marker('b', [markup('b')])
    ])]);
  });

  editor$3.selectRange(new Range(editor$3.post.tailPosition()));
  assert.equal(editor$3.activeMarkups.length, 1, 'precond - 1 active markup');
  editor$3.insertText('Z');
  assert.hasElement('#editor b:contains(bZ)');

  editor$3.selectRange(new Range(editor$3.post.headPosition()));
  assert.equal(editor$3.activeMarkups.length, 0, 'precond - 0 active markups at start');
  editor$3.toggleMarkup('b');
  editor$3.insertText('A');

  assert.hasElement('#editor b:contains(A)');
});

test$4('#insertText is no-op when editor does not have cursor', (assert) => {
  let expected;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('abc')])]);
    return post([markupSection('p', [marker('abc')])]);
  }, {autofocus: false});

  assert.ok(!editor$3.hasCursor(), 'precond - editor has no cursor');
  editor$3.insertText('blah blah blah');

  assert.postIsSimilar(editor$3.post, expected, 'post is not changed');
});

test$4('#insertText when post is blank', (assert) => {
  let expected;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('blah blah')])]);
    return post();
  });

  // Necessary to ensure tests pass on FF when the window is not active
  Helpers.dom.selectRange(editorElement$3, 0, editorElement$3, 0);

  assert.ok(editor$3.hasCursor(), 'precond - editor has cursor');
  assert.ok(editor$3.post.isBlank, 'precond - editor has blank post');
  editor$3.insertText('blah blah');

  assert.postIsSimilar(editor$3.post, expected, 'text is added to post');
});

test$4('#insertAtom inserts atom at cursor position, replacing range if non-collapsed', (assert) => {
  let atom = {
    name: 'the-atom',
    type: 'dom',
    render() {
    }
  };

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    return post([markupSection('p', [ marker('b') ])]);
  }, {atoms: [atom]});

  editor$3.selectRange(new Range(editor$3.post.tailPosition()));
  editor$3.insertAtom('the-atom', 'END');

  assert.equal(editor$3.post.sections.head.text, 'bEND');

  editor$3.selectRange(new Range(editor$3.post.headPosition()));
  editor$3.insertAtom('the-atom', 'START');
  assert.equal(editor$3.post.sections.head.text, 'STARTbEND');

  editor$3.selectRange(new Range(editor$3.post.headPosition(), editor$3.post.tailPosition()));
  editor$3.insertAtom('the-atom', 'REPLACE-ALL');
  assert.equal(editor$3.post.sections.head.text, 'REPLACE-ALL');
});

test$4('#insertAtom is no-op when editor does not have cursor', (assert) => {
  let atom = {
    name: 'the-atom',
    type: 'dom',
    render() {
    }
  };

  let expected;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('abc')])]);
    return post([markupSection('p', [marker('abc')])]);
  }, {atoms: [atom], autofocus: false});

  assert.ok(!editor$3.hasCursor(), 'precond - editor has no cursor');
  editor$3.insertAtom('the-atom');

  assert.postIsSimilar(editor$3.post, expected, 'post is not changed');
});

test$4('#insertAtom when post is blank', (assert) => {
  let atom = {
    name: 'the-atom',
    type: 'dom',
    render() {
    }
  };

  let expected;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, atom, markupSection}) => {
    expected = post([markupSection('p', [atom('the-atom', 'THEATOMTEXT')])]);
    return post();
  }, {atoms: [atom]});

  Helpers.dom.selectRange(editorElement$3, 0, editorElement$3, 0);

  assert.ok(editor$3.hasCursor(), 'precond - editor has cursor');
  assert.ok(editor$3.post.isBlank, 'precond - post is blank');
  editor$3.insertAtom('the-atom', 'THEATOMTEXT');

  assert.postIsSimilar(editor$3.post, expected);
});

test$4('#insertAtom returns the inserted atom', (assert) => {
  let atom = {
    name: 'the-atom',
    type: 'dom',
    render() {
    }
  };

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post}) => {
    return post();
  }, {atoms: [atom]});

  // Force the selection -- this is necessary for tests in Firefox at
  // SauceLabs.
  Helpers.dom.selectRange(editorElement$3, 0, editorElement$3, 0);

  assert.ok(editor$3.hasCursor(), 'precond - editor has cursor');

  const insertedAtom = editor$3.insertAtom('the-atom', 'THEATOMTEXT');

  assert.equal(insertedAtom.value, 'THEATOMTEXT', 'return value is the inserted atom');
});

test$4('#insertCard inserts card at section after cursor position, replacing range if non-collapsed', (assert) => {
  let card = {
    name: 'the-card',
    type: 'dom',
    render() {
    }
  };

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    return post([markupSection('p', [ marker('b') ])]);
  }, {cards: [card]});

  editor$3.selectRange(new Range(editor$3.post.tailPosition()));
  editor$3.insertCard('the-card');

  assert.equal(editor$3.post.sections.length, 2, 'adds a section at end');
  assert.ok(editor$3.post.sections.tail.isCardSection, 'added section is card section');

  editor$3.run(postEditor => {
    let blankSection = postEditor.builder.createMarkupSection();

    let firstSection = editor$3.post.sections.head;
    let collection = editor$3.post.sections;
    postEditor.insertSectionBefore(collection, blankSection, firstSection);
  });

  assert.equal(editor$3.post.sections.length, 3, 'precond - adds blank section at start');
  assert.ok(!editor$3.post.sections.head.isCardSection, 'precond - initial section is not card section');

  editor$3.selectRange(new Range(editor$3.post.headPosition()));
  editor$3.insertCard('the-card');

  assert.equal(editor$3.post.sections.length, 3, 'replaced initial blank section with card');
  assert.ok(editor$3.post.sections.head.isCardSection, 'initial section is card section');

  editor$3.selectRange(new Range(editor$3.post.headPosition(), editor$3.post.tailPosition()));
  editor$3.insertCard('the-card');
  assert.equal(editor$3.post.sections.length, 1, 'replaces range with card section');
  assert.ok(editor$3.post.sections.head.isCardSection, 'initial section is card section');
});

test$4('#insertCard when cursor is in list item', (assert) => {
  let card = {
    name: 'the-card',
    type: 'dom',
    render() {
    }
  };

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker, listItem, listSection}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('def')])
    ])]);
  }, {cards: [card]});

  editor$3.selectRange(Range.create(editor$3.post.sections.head.items.head, 'ab'.length));
  editor$3.insertCard('the-card');

  assert.equal(editor$3.post.sections.length, 2, 'adds a second section');
  assert.ok(editor$3.post.sections.tail.isCardSection, 'tail section is card section');
});

test$4('#insertCard is no-op when editor does not have cursor', (assert) => {
  let card = {
    name: 'the-card',
    type: 'dom',
    render() {
    }
  };

  let expected;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('abc')])]);
    return post([markupSection('p', [marker('abc')])]);
  }, {cards: [card], autofocus: false});

  assert.ok(!editor$3.hasCursor(), 'precond - editor has no cursor');
  editor$3.insertCard('the-card');

  assert.postIsSimilar(editor$3.post, expected, 'post is not changed');
});

test$4('#insertCard when post is blank', (assert) => {
  let card = {
    name: 'the-card',
    type: 'dom',
    render() {
    }
  };

  let expected;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post, cardSection}) => {
    expected = post([cardSection('the-card')]);
    return post();
  }, {cards: [card]});

  Helpers.dom.selectRange(editorElement$3, 0, editorElement$3, 0);

  assert.ok(editor$3.hasCursor(), 'precond - editor has cursor');
  assert.ok(editor$3.post.isBlank, 'precond - post is blank');

  editor$3.insertCard('the-card');

  assert.postIsSimilar(editor$3.post, expected, 'adds card section');
});

test$4('#insertCard returns card object', (assert) => {
  let card = {
    name: 'the-card',
    type: 'dom',
    render() {
    }
  };

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post}) => {
    return post();
  }, {cards: [card]});

  Helpers.dom.selectRange(editorElement$3, 0, editorElement$3, 0);

  assert.ok(editor$3.hasCursor(), 'precond - editor has cursor');
  assert.ok(editor$3.post.isBlank, 'precond - post is blank');

  const insertedCard = editor$3.insertCard('the-card');

  assert.ok(!!insertedCard, 'insertedCard is present');
  assert.equal(editor$3.post.sections.tail, insertedCard, 'returned card is the inserted card');
});

test$4('#insertCard focuses the cursor at the end of the card', (assert) => {
  let card = {
    name: 'the-card',
    type: 'dom',
    render() {
    }
  };

  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3, ({post}) => {
    return post();
  }, {cards: [card]});

  Helpers.dom.selectRange(editorElement$3, 0, editorElement$3, 0);

  let insertedCard = editor$3.insertCard('the-card');

  let range = editor$3.range;
  assert.positionIsEqual(range.head, insertedCard.tailPosition(), 'range head on card tail');
  assert.positionIsEqual(range.tail, insertedCard.tailPosition(), 'range tail on card tail');
  assert.ok(document.activeElement === editorElement$3, 'editor element retains focus');
});

test$4('#toggleMarkup removes A tag when no attributes given', function(assert) {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3,
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [
      marker('^'), marker('link', [markup('a', {href: 'google.com'})]), marker('$')
    ])]);
  });
  Helpers.dom.selectText(editor$3, 'link');
  editor$3.toggleMarkup('a');

  assert.selectedText('link', 'text "link" still selected');
  assert.ok(editor$3.hasCursor(), 'editor has cursor');
  assert.hasElement('#editor p:contains(^link$)');
  assert.hasNoElement('#editor a', 'a tag is removed');
});

test$4('#toggleMarkup adds A tag with attributes', function(assert) {
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3,
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('^link$')])]);
  });
  Helpers.dom.selectText(editor$3, 'link');
  editor$3.toggleMarkup('a', {href: 'google.com'});

  assert.selectedText('link', 'text "link" still selected');
  assert.ok(editor$3.hasCursor(), 'editor has cursor');
  assert.hasElement('#editor a:contains(link)');
  assert.hasElement('#editor a[href="google.com"]:contains(link)');
});

test$4('#toggleMarkup calls #beforeToggleMarkup hooks', function(assert) {
  assert.expect(5*3 + 2);

  let callbackCount = 0;
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3,
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('^link$')])]);
  });
  Helpers.dom.selectText(editor$3, 'link');
  let callback = ({markup, range, willAdd}) => {
    assert.ok(true, 'calls #beforeToggleMarkup');
    assert.equal(markup.tagName, 'a', 'passes markup');
    assert.equal(markup.getAttribute('href'), 'google.com',
      'passes markup with attrs');
    assert.ok(!!range, 'passes a range');
    assert.ok(willAdd, 'correct value for willAdd');
    callbackCount++;
  };

  // 3 times
  editor$3.beforeToggleMarkup(callback);
  editor$3.beforeToggleMarkup(callback);
  editor$3.beforeToggleMarkup(callback);

  editor$3.toggleMarkup('a', {href: 'google.com'});
  assert.equal(callbackCount, 3, 'calls once for each callback');
  assert.hasElement('#editor a[href="google.com"]:contains(link)',
    'adds link');
});

test$4('#toggleMarkup is canceled if #beforeToggleMarkup hook returns false', function(assert) {
  assert.expect(2);
  editor$3 = Helpers.mobiledoc.renderInto(editorElement$3,
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('^link$')])]);
  });
  Helpers.dom.selectText(editor$3, 'link');
  let callback = ({markup, range, willAdd}) => {
    assert.ok(true, 'calls #beforeToggleMarkup');
    return false;
  };

  editor$3.beforeToggleMarkup(callback);

  editor$3.toggleMarkup('a', {href: 'google.com'});
  assert.hasNoElement('#editor a', 'not adds link');
});

const { module: module$5, test: test$5 } = Helpers;

const SPECIAL_KEYS$1 = {
  BACKSPACE: Keycodes.BACKSPACE,
  TAB:       Keycodes.TAB,
  ENTER:     Keycodes.ENTER,
  ESC:       Keycodes.ESC,
  SPACE:     Keycodes.SPACE,
  PAGEUP:    Keycodes.PAGEUP,
  PAGEDOWN:  Keycodes.PAGEDOWN,
  END:       Keycodes.END,
  HOME:      Keycodes.HOME,
  LEFT:      Keycodes.LEFT,
  UP:        Keycodes.UP,
  RIGHT:     Keycodes.RIGHT,
  DOWN:      Keycodes.DOWN,
  INS:       Keycodes.INS,
  DEL:       Keycodes.DELETE
};

module$5('Unit: Editor key commands');

test$5('leaves modifier, code and run in place if they exist', (assert) => {
  const fn = function() {};

  const {
    modifier, code, run
  } = buildKeyCommand({
    code: Keycodes.ENTER,
    modifier: MODIFIERS.META,
    run: fn
  });

  assert.equal(modifier, MODIFIERS.META, 'keeps modifier');
  assert.equal(code, Keycodes.ENTER, 'keeps code');
  assert.equal(run, fn, 'keeps run');
});

test$5('translates MODIFIER+CHARACTER string to modifierMask and code', (assert) => {

  const { modifierMask: modifierMask$1, code } = buildKeyCommand({ str: 'meta+k' });

  assert.equal(modifierMask$1, modifierMask({metaKey: true}),
               'calculates correct modifierMask');
  assert.equal(code, 75, 'translates string to code');
});

test$5('translates modifier+character string to modifierMask and code', (assert) => {

  const { modifierMask: modifierMask$1, code } = buildKeyCommand({ str: 'META+K' });

  assert.equal(modifierMask$1, modifierMask({metaKey: true}),
               'calculates correct modifierMask');
  assert.equal(code, 75, 'translates string to code');
});

test$5('translates multiple modifiers to modifierMask', (assert) => {
  const { modifierMask: modifierMask$1, code } = buildKeyCommand({ str: 'META+SHIFT+K' });
  assert.equal(modifierMask$1, modifierMask({metaKey: true, shiftKey: true}),
               'calculates correct modifierMask');
  assert.equal(code, 75, 'translates string to code');
});

test$5('translates uppercase character string to code', (assert) => {

  const { modifierMask, code } = buildKeyCommand({ str: 'K' });

  assert.equal(modifierMask, 0, 'no modifier given');
  assert.equal(code, 75, 'translates string to code');
});

test$5('translates lowercase character string to code', (assert) => {

  const { modifier, code } = buildKeyCommand({ str: 'k' });

  assert.equal(modifier, undefined, 'no modifier given');
  assert.equal(code, 75, 'translates string to code');

});

test$5('throws when given invalid modifier', (assert) => {
  assert.throws(() => {
    buildKeyCommand({str: 'MEAT+K'});
  }, /No modifier named.*MEAT.*/);
});

test$5('throws when given `modifier` property (deprecation)', (assert) => {
  assert.throws(() => {
    buildKeyCommand({str: 'K', modifier: MODIFIERS.META});
  }, /Key commands no longer use.*modifier.* property/);
});

test$5('throws when given str with too many characters', (assert) => {
  assert.throws(() => {
    buildKeyCommand({str: 'abc'});
  }, /Only 1 character/);
});

test$5('translates uppercase special key names to codes', (assert) => {
  Object.keys(SPECIAL_KEYS$1).forEach(name => {
    const { code } = buildKeyCommand({ str: name.toUpperCase() });
    assert.equal(code, SPECIAL_KEYS$1[name], `translates ${name} string to code`);
  });
});

test$5('translates lowercase special key names to codes', (assert) => {
  Object.keys(SPECIAL_KEYS$1).forEach(name => {
    const { code } = buildKeyCommand({ str: name.toLowerCase() });
    assert.equal(code, SPECIAL_KEYS$1[name], `translates ${name} string to code`);
  });
});

test$5('`findKeyCommands` matches modifiers exactly', (assert) => {
  let cmdK = buildKeyCommand({
    str: 'META+K'
  });
  let cmdShiftK = buildKeyCommand({
    str: 'META+SHIFT+K'
  });
  let commands = [cmdK, cmdShiftK];

  let element = null;
  let cmdKEvent = Helpers.dom.createMockEvent('keydown', element, {
    keyCode: 75,
    metaKey: true
  });
  let cmdShiftKEvent = Helpers.dom.createMockEvent('keydown', element, {
    keyCode: 75,
    metaKey: true,
    shiftKey: true
  });

  let found = findKeyCommands(commands, cmdKEvent);
  assert.ok(found.length && found[0] === cmdK,
                   'finds cmd-K command from cmd-k event');

  found = findKeyCommands(commands, cmdShiftKEvent);
  assert.ok(found.length && found[0] === cmdShiftK,
                   'finds cmd-shift-K command from cmd-shift-k event');
});

const { FORWARD: FORWARD$2, BACKWARD: BACKWARD$2 } = DIRECTION;

const { module: module$6, test: test$6 } = Helpers;

let { postEditor: { run: run$1 } } = Helpers;
let { postAbstract: { buildFromText: buildFromText$2 } } = Helpers;
const { editor: { retargetPosition: retargetPosition$1 } } = Helpers;

module$6('Unit: PostEditor: #deleteAtPosition');

let expectationGroups = [{
  name: 'single markup section',
  direction: BACKWARD$2,
  expectations: [
    ['abc|def', 'ab|def', 'middle'],
    ['abcdef|', 'abcde|', 'end'],
    ['|abcdef', '|abcdef', 'start'],

    ['ab *cd*| ef', 'ab *c*| ef', 'markup (right side)'],
    ['ab |*cd* ef', 'ab|*cd* ef', 'markup (left side)'],

    ['ab @| ef', 'ab | ef', 'atom (right side)'],
    ['ab |@ ef', 'ab|@ ef', 'atom (left side)']
  ]
}, {
  name: 'single markup section',
  direction: FORWARD$2,
  expectations: [
    ['abc|def', 'abc|ef', 'middle'],
    ['abcdef|', 'abcdef|', 'end'],
    ['|abcdef', '|bcdef', 'start'],

    ['ab *cd*| ef', 'ab *cd*|ef', 'markup (right side)'],
    ['ab |*cd* ef', 'ab |*d* ef', 'markup (left side)'],

    ['ab @| ef', 'ab @|ef', 'atom (right side)'],
    ['ab |@ ef', 'ab | ef', 'atom (left side)']
  ]
}, {
  name: 'across section boundary',
  direction: BACKWARD$2,
  expectations: [
    [['abc','|def'], 'abc|def', 'markup sections'],
    [['*abc*','|def'], '*abc*|def', 'markup sections with markup'],
    [['[abc]','|def'], ['[abc]|','def'], 'prev section is card'],
    [['abc','|[def]'], ['abc|','[def]'], 'cur section is card'],
    [['', '|abc'], ['|abc'], 'prev section is blank']
  ]
}, {
  name: 'across section boundary',
  direction: FORWARD$2,
  expectations: [
    [['abc|','def'], 'abc|def', 'markup sections'],
    [['*abc*|','def'], '*abc*|def', 'markup sections with markup'],
    [['[abc]|','def'], ['[abc]|','def'], 'cur section is card'],
    [['abc|','[def]'], ['abc|','[def]'], 'next section is card'],
    [['abc|', ''], ['abc|'], 'next section is blank']
  ]
}, {
  name: 'across list item boundary',
  direction: BACKWARD$2,
  expectations: [
    [['* abc','* |def'], ['* abc', '|def'], 'start of list item'],
    [['* abc','|def'], ['* abc|def'], 'into list item'],
    [['', '* |abc'], ['', '|abc'], 'prev blank section'],
  ]
}, {
  name: 'across list item boundary',
  direction: FORWARD$2,
  expectations: [
    [['* abc|','* def'], ['* abc|def'], 'item into item'],
    [['* abc|','def'], ['* abc|def'], 'item into markup'],
    [['abc|','* def'], ['abc|def'], 'markup into markup'],
  ]
}];

expectationGroups.forEach(({name, expectations, direction}) => {
  expectations.forEach(([before, after, msg]) => {
    let dir = direction === FORWARD$2 ? 'forward' : 'backward';
    test$6(`${dir}: ${name}, "${before}" -> "${after}" (${msg})`, (assert) => {
      let { post, range: { head: position } } = buildFromText$2(before);
      let { post: expectedPost, range: { head: expectedPosition } } = buildFromText$2(after);

      position = run$1(post, postEditor => postEditor.deleteAtPosition(position, direction));
      expectedPosition = retargetPosition$1(expectedPosition, post);

      assert.postIsSimilar(post, expectedPost);
      assert.positionIsEqual(position, expectedPosition);
    });
  });
});

const { module: module$7, test: test$7 } = Helpers;

const { postEditor: { run: run$2 } } = Helpers;
const { postAbstract: { buildFromText: buildFromText$3 } } = Helpers;
const { editor: { retargetRange: retargetRange$1 } } = Helpers;

module$7('Unit: PostEditor: #deleteRange');

test$7('with collapsed range is no-op', (assert) => {
  let { post, range } = buildFromText$3('abc|def');
  let { post: expectedPost, range: expectedRange } = buildFromText$3('abc|def');

  let position = run$2(post, postEditor => postEditor.deleteRange(range));

  expectedRange = retargetRange$1(expectedRange, post);

  assert.postIsSimilar(post, expectedPost);
  assert.rangeIsEqual(position.toRange(), expectedRange);
});

let expectationGroups$1 = [{
  name: 'within a section (single section)',
  expectations: [
    ['ab<c>', 'ab|', 'at tail'],
    ['<a>bc', '|bc', 'at head'],
    ['a<b>c', 'a|c', 'middle']
  ]
}, {
  name: 'within a section with markup (single section)',
  expectations: [
    ['abc <*def*> ghi', 'abc | ghi', 'entire markup in middle'],
    ['abc *de<f* ghi>', 'abc *de|*', 'partial markup at end'],
    ['abc *de<f* g>hi', 'abc *de|*hi', 'partial markup in middle (right)'],
    ['ab<c *de>f* ghi', 'ab*|f* ghi', 'partial markup in middle (left)'],
    ['<abc *de>f* ghi', '*|f* ghi', 'partial markup at start'],
  ]
}, {
  name: 'across markup section boundaries',
  expectations: [
    [['abc<', '>def'], 'abc|def', 'at boundary'],
    [['abc<', 'd>ef'], 'abc|ef', 'boundary into next section'],
    [['ab<c', '>def'], 'ab|def', 'section into boundary'],
    [['ab<c', 'd>ef'], 'ab|ef', 'containing boundary'],

    [['abc<', 'def', '>ghi'], 'abc|ghi', 'across section at boundary'],
    [['abc<', 'def', 'g>hi'], 'abc|hi', 'across section boundary containing next section'],
    [['ab<c', 'def', '>ghi'], 'ab|ghi', 'across section boundary containing before section'],
    [['ab<c', 'def', 'g>hi'], 'ab|hi', 'across section boundary containing before and after section'],
  ]
}, {
  name: 'across markup section boundaries including markups',
  expectations: [
    [['*abc*<', '>def'], '*abc*|def', 'at boundary (left markup)'],
    [['*abc*<', 'd>ef'], '*abc*|ef', 'boundary into next section (left markup)'],
    [['*ab<c*', '>def'], '*ab*|def', 'section into boundary (left markup)'],
    [['*ab<c*', 'd>ef'], '*ab*|ef', 'containing boundary (left markup)'],

    [['abc<', '*>def*'], 'abc|*def*', 'at boundary (right markup)'],
    [['abc<', '*d>ef*'], 'abc|*ef*', 'boundary into next section (right markup)'],
    [['ab<c', '*>def*'], 'ab|*def*', 'section into boundary (right markup)'],
    [['ab<c', '*d>ef*'], 'ab|*ef*', 'containing boundary (right markup)'],

    [['abc<', '*def*', '>ghi'], 'abc|ghi', 'across section at boundary (containing markup)'],
    [['abc<', '*def*', 'g>hi'], 'abc|hi', 'across section boundary containing next section (containing markup)'],
    [['ab<c', '*def*', '>ghi'], 'ab|ghi', 'across section boundary containing before section (containing markup)'],
    [['ab<c', '*def*', 'g>hi'], 'ab|hi', 'across section boundary containing before and after section (containing markup)'],

    [['abc<', '*def*', '>*g*hi'], 'abc|*g*hi', 'across section at boundary (into markup)'],
    [['abc<', '*def*', '*g*>hi'], 'abc|hi', 'across section boundary containing next section (into markup)'],
    [['ab<c', '*def*', '>*g*hi'], 'ab|*g*hi', 'across section boundary containing before section (into markup)'],
    [['ab<c', '*def*', '*g*>hi'], 'ab|hi', 'across section boundary containing before and after section (into markup)'],
  ]
}, {
  name: 'across markup/non-markup section boundaries',
  expectations: [
    [['[some-card]<','>abc'], ['[some-card]|', 'abc'], 'card->markup start'], 
    [['[some-card]<','>'], ['[some-card]|'], 'card->blank-markup'], 
    [['<[some-card]','a>bc'], ['|bc'], 'card->markup inner'], 

    [['abc<','>[some-card]'], ['abc|', '[some-card]'], 'markup->card'], 

    [['abc<', '[some-card]', '>def'], ['abc|def'], 'containing card, boundaries in outer sections'],

    [['abc', '<[some-card]>', 'def'], ['abc', '|', 'def'], 'containing card, boundaries in card section'],

    [['<', '>[some-card]'], ['|[some-card]'], 'blank section into card']
  ]
}, {
  name: 'across list items',
  expectations: [
    [['* item 1<', '* >item 2'], ['* item 1|item 2'], 'at boundary'],
    [['* item <1', '* i>tem 2'], ['* item |tem 2'], 'surrounding boundary'],
    [['* item 1<', '* i>tem 2'], ['* item 1|tem 2'], 'boundary to next'],
    [['* item <1', '* >item 2'], ['* item |item 2'], 'prev to boundary'],

    [['* item 1<', '* middle', '* >item 2'], ['* item 1|item 2'], 'across item at boundary'],
    [['* item <1', '* middle', '* i>tem 2'], ['* item |tem 2'], 'across item surrounding boundary'],
    [['* item <1', '* middle', '* >item 2'], ['* item |item 2'], 'across item prev to boundary'],
    [['* item 1<', '* middle', '* i>tem 2'], ['* item 1|tem 2'], 'across item boundary to next'],

    [['* item 1<', 'middle', '* >item 2'], ['* item 1|item 2'], 'across markup at boundary'],
    [['* item <1', 'middle', '* i>tem 2'], ['* item |tem 2'], 'across markup surrounding boundary'],

    [['* item 1', '<middle', '* i>tem 2'], ['* item 1', '|tem 2'], 'across markup into next'],

    [['* item 1<', '>middle'], ['* item 1|middle'], 'item tail to markup head'],
    [['start<', '* >middle'], ['start|middle'], 'markup tail to item head'],

    [['* <','>abc'], ['* |abc'], 'empty li into markup start'],
    [['* <','a>bc'], ['* |bc'], 'empty li into markup middle'],
    [['* <','abc>'], ['* |'], 'empty li into markup end'],
    [['* abc<','>'], ['* abc|'], 'li into empty markup'],
    [['* <','>'], ['* |'], 'empty li into empty markup'],
  ]
}, {
  name: 'with atoms',
  expectations: [
    ['abc<@>def', 'abc|def', 'surrounding'],
    ['abc<@d>ef', 'abc|ef', 'into atom into next marker'],
    ['ab<c@>def', 'ab|def', 'into marker into atom'],

    ['ab<c>@def', 'ab|@def', 'prev boundary'],
    ['abc@<d>ef', 'abc@|ef', 'next boundary']
  ]
}];

expectationGroups$1.forEach(({name, expectations}) => {
  expectations.forEach(([before, after, msg]) => {
    test$7(`${name}, "${before}" -> "${after}" (${msg})`, (assert) => {
      let { post, range } = buildFromText$3(before);
      let { post: expectedPost, range: expectedRange } = buildFromText$3(after);

      let position = run$2(post, postEditor => postEditor.deleteRange(range));

      expectedRange = retargetRange$1(expectedRange, post);

      assert.postIsSimilar(post, expectedPost);
      assert.rangeIsEqual(position.toRange(), expectedRange);
    });
  });
});

let entirePostExpectations = [
  [['<abc>'], 'single section'],
  [['<[some-card]>'], 'single card'],
  [['<abc','def','ghi>'], 'multiple sections'],
  [['<>'], 'single blank section'],
  [['<','','>'], 'multiple blank sections'],
  [['<[some-card]', 'abc', '[some-card]>'], 'cards at head/tail, containing markup section'],
  [['<abc', '[some-card]', 'def>'], 'markup sections containing card'],
  [['<[some-card]', 'abc>'], 'card->markup'],
  [['<abc', '[some-card]>'], 'markup->card'],
];

entirePostExpectations.forEach(([text, msg]) => {
  test$7(`entire post "${text}" (${msg})`, (assert) => {
    let { post, range } = buildFromText$3(text);
    let position = run$2(post, postEditor => postEditor.deleteRange(range));

    assert.ok(post.sections.length === 1 && post.sections.head.isBlank, `post has single blank section after deleteRange (${msg})`);
    assert.ok(position.section === post.sections.head, `position#section is correct (${msg})`);
    assert.equal(position.offset, 0, `position#offset is correct (${msg})`);
  });
});

const { module: module$8, test: test$8 } = Helpers;

let editor$4, editorElement$4;

let builder, postEditor, mockEditor;

let { postEditor: { MockEditor: MockEditor$1, renderBuiltAbstract: renderBuiltAbstract$1 } } = Helpers;

function buildEditorWithMobiledoc(builderFn, autofocus=true) {
  let mobiledoc = Helpers.mobiledoc.build(builderFn);
  let unknownCardHandler = () => {};
  let unknownAtomHandler = () => {};
  editor$4 = new Editor({mobiledoc, unknownCardHandler, unknownAtomHandler, autofocus});
  editor$4.render(editorElement$4);
  let selectRange = editor$4.selectRange;
  editor$4.selectRange = function(range) {
    selectRange.call(editor$4, range);
    // Store the rendered range so the test can make assertions with it
    editor$4._renderedRange = range;
  };
  return editor$4;
}

module$8('Unit: PostEditor', {
  beforeEach() {
    editorElement$4 = $('#editor')[0];
    builder = new PostNodeBuilder();
    mockEditor = new MockEditor$1(builder);
    postEditor = new PostEditor(mockEditor);
  },

  afterEach() {
    if (editor$4) {
      editor$4.destroy();
      editor$4 = null;
    }
  }
});

test$8('#splitMarkers when headMarker = tailMarker', (assert) => {
  let post, section;
  Helpers.postAbstract.build(({marker, markupSection, post: buildPost}) => {
    section = markupSection('p', [
      marker('abcd')
    ]);
    post = buildPost([ section ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  const postEditor = new PostEditor(mockEditor);
  const range = Range.create(section, 1, section, 3);
  const markers = postEditor.splitMarkers(range);
  postEditor.complete();

  assert.equal(markers.length, 1, 'markers');
  assert.equal(markers[0].value, 'bc', 'marker 0');
});

test$8('#splitMarkers when head section = tail section, but different markers', (assert) => {
  const post = Helpers.postAbstract.build(({marker, markupSection, post}) =>
    post([
      markupSection('p', [marker('abc'), marker('def')])
    ])
  );

  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  const section = post.sections.head;
  const range = Range.create(section, 2, section, 5);
  const postEditor = new PostEditor(mockEditor);
  const markers = postEditor.splitMarkers(range);
  postEditor.complete();

  assert.equal(markers.length, 2, 'markers');
  assert.equal(markers[0].value, 'c', 'marker 0');
  assert.equal(markers[1].value, 'de', 'marker 1');
});

// see https://github.com/bustle/mobiledoc-kit/issues/121
test$8('#splitMarkers when single-character marker at start', (assert) => {
  let post, section;
  Helpers.postAbstract.build(({marker, markupSection, post: buildPost}) => {
    section = markupSection('p', [
      marker('a'),
      marker('b'),
      marker('c')
    ]);
    post = buildPost([ section ]);
  });

  renderBuiltAbstract$1(post, mockEditor);

  const range = Range.create(section, 1, section, 3);
  const markers = postEditor.splitMarkers(range);
  postEditor.complete();

  assert.equal(markers.length, 2, 'markers');
  assert.equal(markers[0].value, 'b', 'marker 0');
  assert.equal(markers[1].value, 'c', 'marker 1');
});

test$8('#replaceSection one markup section with another', (assert) => {
  let _section1, _section2;
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    _section1 = markupSection('p', [marker('abc')]);
    _section2 = markupSection('p', [marker('123')]);
    return post([_section1]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  assert.equal(post.sections.head.text, 'abc', 'precond - section text');
  assert.equal(post.sections.length, 1, 'precond - only 1 section');
  postEditor.replaceSection(_section1, _section2);
  postEditor.complete();

  assert.equal(post.sections.head.text, '123', 'section replaced');
  assert.equal(post.sections.length, 1, 'only 1 section');
});

test$8('#replaceSection markup section with list section', (assert) => {
  let _section1, _section2;
  const post = Helpers.postAbstract.build(
    ({post, markupSection, listSection, listItem, marker}) => {
    _section1 = markupSection('p', [marker('abc')]);
    _section2 = listSection('ul', [listItem([marker('123')])]);
    return post([_section1]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  assert.equal(post.sections.head.text, 'abc', 'precond - section text');
  assert.equal(post.sections.length, 1, 'precond - only 1 section');
  postEditor.replaceSection(_section1, _section2);
  postEditor.complete();

  assert.equal(post.sections.head.items.head.text, '123', 'section replaced');
  assert.equal(post.sections.length, 1, 'only 1 section');
});

test$8('#replaceSection solo list item with markup section removes list section', (assert) => {
  let _section1, _section2;
  const post = Helpers.postAbstract.build(
    ({post, markupSection, listSection, listItem, marker}) => {
    _section1 = listItem([marker('abc')]);
    _section2 = markupSection('p', [marker('123')]);
    return post([listSection('ul', [_section1])]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  assert.equal(post.sections.head.items.head.text, 'abc', 'precond - list item text');
  assert.equal(post.sections.length, 1, 'precond - only 1 section');
  postEditor.replaceSection(_section1, _section2);
  postEditor.complete();

  assert.equal(post.sections.head.text, '123', 'section replaced');
  assert.equal(post.sections.length, 1, 'only 1 section');
});

/*
 * FIXME, this test should be made to pass, but it is not a situation that we
 * run into in the actual life of the editor right now.

test('#replaceSection middle list item with markup section cuts list into two', (assert) => {
  let _section1, _section2;
  const post = Helpers.postAbstract.build(
    ({post, markupSection, listSection, listItem, marker}) => {
    _section1 = listItem([marker('li 2')]);
    _section2 = markupSection('p', [marker('123')]);
    return post([listSection('ul', [
      listItem([marker('li 1')]),
      _section1,
      listItem([marker('li 3')])
    ])]);
  });
  renderBuiltAbstract(post, mockEditor);

  assert.equal(post.sections.head.items.length, 3, 'precond - 3 lis');
  assert.equal(post.sections.head.items.objectAt(1).text, 'li 2', 'precond - list item text');
  assert.equal(post.sections.length, 1, 'precond - only 1 section');
  postEditor.replaceSection(_section1, _section2);
  postEditor.complete();

  assert.equal(post.sections.length, 3, '3 sections');
  assert.equal(post.sections.head.items.length, 1, '1 li in 1st ul');
  assert.equal(post.sections.objectAt(1).text, '123', 'new section text is there');
  assert.equal(post.sections.tail.items.length, 1, '1 li in last ul');
});

*/

test$8('#replaceSection last list item with markup section when multiple list items appends after list section', (assert) => {
  let _section1, _section2;
  const post = Helpers.postAbstract.build(
    ({post, markupSection, listSection, listItem, marker}) => {
    _section1 = listItem([marker('abc')]);
    _section2 = markupSection('p', [marker('123')]);
    return post([listSection('ul', [
      listItem([marker('before li')]),
      _section1
    ])]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  assert.equal(post.sections.head.items.length, 2, 'precond - 2 lis');
  assert.equal(post.sections.head.items.tail.text, 'abc', 'precond - list item text');
  assert.equal(post.sections.length, 1, 'precond - only 1 section');
  postEditor.replaceSection(_section1, _section2);
  postEditor.complete();

  assert.equal(post.sections.head.items.length, 1, 'only 1 li');
  assert.equal(post.sections.head.items.head.text, 'before li', 'first li remains');
  assert.equal(post.sections.length, 2, '2 sections');
  assert.equal(post.sections.tail.text, '123', 'new section text is there');
});

test$8('#replaceSection when section is null appends new section', (assert) => {
  let newEmptySection;
  const post = Helpers.postAbstract.build(
    ({post, markupSection}) => {
    newEmptySection = markupSection('p');
    return post();
  });
  renderBuiltAbstract$1(post, mockEditor);

  assert.equal(post.sections.length, 0, 'precond - no sections');
  postEditor.replaceSection(null, newEmptySection);
  postEditor.complete();

  assert.equal(post.sections.length, 1, 'has 1 section');
  assert.equal(post.sections.head.text, '', 'no text in new section');
});

test$8('#insertSectionAtEnd inserts the section at the end of the mobiledoc', (assert) => {
  let newSection;
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    newSection = markupSection('p', [marker('123')]);
    return post([markupSection('p', [marker('abc')])]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  postEditor.insertSectionAtEnd(newSection);
  postEditor.complete();

  assert.equal(post.sections.length, 2, 'new section added');
  assert.equal(post.sections.tail.text, '123', 'new section added at end');
});

test$8('markers with identical non-attribute markups get coalesced after applying or removing markup', (assert) => {
  let strong, section;
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    strong = markup('strong');
    section = markupSection('p', [marker('a'), marker('b',[strong]), marker('c')]);
    return post([section]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  // removing the strong from the "b"
  let range = Range.create(section, 1, section, 2);
  postEditor = new PostEditor(mockEditor);
  postEditor.removeMarkupFromRange(range, strong);
  postEditor.complete();

  assert.equal(section.markers.length, 1, 'similar markers are coalesced');
  assert.equal(section.markers.head.value, 'abc', 'marker value is correct');
  assert.ok(!section.markers.head.hasMarkup(strong), 'marker has no bold');

  // adding strong to each of the characters individually
  postEditor = new PostEditor(mockEditor);
  for (let i=0; i < section.length; i++) {
    range = Range.create(section, i, section, i+1);
    postEditor.addMarkupToRange(range, strong);
  }
  postEditor.complete();

  assert.equal(section.markers.length, 1, 'bold markers coalesced');
  assert.equal(section.markers.head.value, 'abc', 'bold marker value is correct');
  assert.ok(section.markers.head.hasMarkup(strong), 'bold marker has bold');
});

test$8('markers do not get coalesced with atoms', (assert) => {
  let strong, section;
  let post = Helpers.postAbstract.build(({post, markupSection, marker, atom, markup}) => {
    strong = markup('strong');
    section = markupSection('p', [atom('the-atom', 'A'), marker('b',[strong])]);
    return post([section]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  // removing the strong from the "b"
  let range = Range.create(section, 0, section, 2);
  postEditor = new PostEditor(mockEditor);
  postEditor.removeMarkupFromRange(range, strong);
  postEditor.complete();

  assert.equal(section.markers.length, 2, 'still 2 markers');
  assert.equal(section.markers.head.value, 'A', 'head marker value is correct');
  assert.ok(section.markers.head.isAtom, 'head marker is atom');
  assert.equal(section.markers.tail.value, 'b', 'tail marker value is correct');
  assert.ok(section.markers.tail.isMarker, 'tail marker is marker');

  assert.ok(!section.markers.head.hasMarkup(strong), 'head marker has no bold');
  assert.ok(!section.markers.tail.hasMarkup(strong), 'tail marker has no bold');
});

test$8('neighboring atoms do not get coalesced', (assert) => {
  let strong, section;
  let post = Helpers.postAbstract.build(({post, markupSection, marker, atom, markup}) => {
    strong = markup('strong');
    section = markupSection('p', [
      atom('the-atom', 'A', {}, [strong]),
      atom('the-atom', 'A', {}, [strong])
    ]);
    return post([section]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  let range = Range.create(section, 0, section, 2);
  postEditor = new PostEditor(mockEditor);
  postEditor.removeMarkupFromRange(range, strong);
  postEditor.complete();

  assert.equal(section.markers.length, 2, 'atoms not coalesced');
  assert.ok(!section.markers.head.hasMarkup(strong));
  assert.ok(!section.markers.tail.hasMarkup(strong));
});

test$8('#removeMarkupFromRange is no-op with collapsed range', (assert) => {
  let section, markup;
  const post = Helpers.postAbstract.build(({
    post, markupSection, marker, markup: buildMarkup
  }) => {
    markup = buildMarkup('strong');
    section = markupSection('p', [
      marker('abc')
    ]);
    return post([section]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  let range = Range.create(section, 1, section, 1);
  postEditor.removeMarkupFromRange(range, markup);
  postEditor.complete();

  assert.equal(section.markers.length, 1, 'similar markers are coalesced');
  assert.equal(section.markers.head.value, 'abc', 'marker value is correct');
  assert.ok(!section.markers.head.hasMarkup(markup), 'marker has no markup');
});

test$8('#removeMarkupFromRange splits markers when necessary', (assert) => {
  let bold, section;
  let post = Helpers.postAbstract.build(
    ({post, marker, markup, markupSection}) => {
    bold = markup('b');
    section = markupSection('p', [
      marker('abc', [bold]),
      marker('def')
    ]);
    return post([section]);
  });

  renderBuiltAbstract$1(post, mockEditor);

  let range = Range.create(section, 'a'.length,
                           section, 'abcd'.length);

  postEditor.removeMarkupFromRange(range, bold);
  postEditor.complete();

  assert.equal(section.text, 'abcdef', 'text still correct');
  assert.equal(section.markers.length, 2, '2 markers');

  let [head, tail] = section.markers.toArray();
  assert.equal(head.value, 'a', 'head marker value');
  assert.ok(head.hasMarkup(bold), 'head has bold');
  assert.equal(tail.value, 'bcdef', 'tail marker value');
  assert.ok(!tail.hasMarkup(bold), 'tail has no bold');
});

test$8('#removeMarkupFromRange handles atoms correctly', (assert) => {
  let bold, section;
  let post = Helpers.postAbstract.build(
    ({post, marker, markup, atom, markupSection}) => {
    bold = markup('b');
    section = markupSection('p', [
      atom('the-atom', 'n/a', {}, [bold]),
      marker('X')
    ]);
    return post([section]);
  });

  renderBuiltAbstract$1(post, mockEditor);

  let range = Range.create(section, 0, section, 2);

  postEditor.removeMarkupFromRange(range, bold);
  postEditor.complete();

  assert.equal(section.markers.length, 2, '2 markers');

  let [head, tail] = section.markers.toArray();
  assert.ok(head.isAtom, 'head is atom');
  assert.ok(!head.hasMarkup(bold), 'head has no bold');

  assert.equal(tail.value, 'X', 'tail marker value');
  assert.ok(!tail.hasMarkup(bold), 'tail has no bold');
});

test$8('#addMarkupToRange is no-op with collapsed range', (assert) => {
  let section, markup;
  const post = Helpers.postAbstract.build(({
    post, markupSection, marker, markup: buildMarkup
  }) => {
    markup = buildMarkup('strong');
    section = markupSection('p', [
      marker('abc')
    ]);
    return post([section]);
  });
  renderBuiltAbstract$1(post, mockEditor);

  let range = Range.create(section, 1, section, 1);
  postEditor.addMarkupToRange(range, markup);
  postEditor.complete();

  assert.equal(section.markers.length, 1, 'similar markers are coalesced');
  assert.equal(section.markers.head.value, 'abc', 'marker value is correct');
  assert.ok(!section.markers.head.hasMarkup(markup), 'marker has no markup');
});

test$8("#addMarkupToRange around a markup pushes the new markup below existing ones", (assert) => {
  let em;
  const editor = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    em = markup('em');
    return post([
        markupSection('p', [
          marker('one '),
          marker('BOLD', [markup('b')]),
          marker(' two')
      ])
    ]);
  });

  let section = editor.post.sections.head;

  let range = Range.create(section, 0, section, 'one BOLD two'.length);
  editor.run(function(postEditor) {
    postEditor.addMarkupToRange(range, em);
  });

  let markers = section.markers.toArray();
  assert.equal(markers[0].closedMarkups.length, 0,
      'Existing markup is not closed');

  assert.equal(editor.element.innerHTML,
      '<p><em>one <b>BOLD</b> two</em></p>');
});


test$8("#addMarkupToRange within a markup puts the new markup on top of the stack", (assert) => {
  let b;
  const editor = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    b = markup('b');
    return post([
        markupSection('p', [
          marker('one BOLD two', [markup('em')]),
      ])
    ]);
  });

  let section = editor.post.sections.head;

  let range = Range.create(section, 'one '.length, section, 'one BOLD'.length);
  editor.run(function(postEditor) {
    postEditor.addMarkupToRange(range, b);
  });

  let markers = section.markers.toArray();
  assert.equal(markers[0].closedMarkups.length, 0,
      'Existing markup is not closed');

  assert.equal(editor.element.innerHTML,
      '<p><em>one <b>BOLD</b> two</em></p>');
});

test$8("#addMarkupToRange straddling the open tag of an existing markup, closes and reopens the existing markup", (assert) => {
  let em;
  const editor = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    em = markup('em');
    return post([
        markupSection('p', [
          marker('_one '),
          marker('TWO_ THREE', [markup('b')])
      ])
    ]);
  });

  let section = editor.post.sections.head;
  let range = Range.create(section, 0, section, '_one TWO_'.length);

  editor.run(function(postEditor) {
    postEditor.addMarkupToRange(range, em);
  });

  assert.equal(editor.element.innerHTML,
      '<p><em>_one <b>TWO_</b></em><b> THREE</b></p>');
});

test$8("#addMarkupToRange straddling the closing tag of an existing markup, closes and reopens the existing markup", (assert) => {
  let em;
  const editor = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    em = markup('em');
    return post([
        markupSection('p', [
          marker('ONE _TWO', [markup('b')]),
          marker(' three_')
      ])
    ]);
  });

  let section = editor.post.sections.head;
  let range = Range.create(section, 'ONE '.length, section, 'ONE _TWO three_'.length);

  editor.run(function(postEditor) {
    postEditor.addMarkupToRange(range, em);
  });

  assert.equal(editor.element.innerHTML,
      '<p><b>ONE </b><em><b>_TWO</b> three_</em></p>');
});

test$8('markers with identical markups get coalesced after deletion', (assert) => {
  let strong, section;
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    strong = markup('strong');
    section = markupSection('p', [marker('a'), marker('b',[strong]), marker('c')]);
    return post([section]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  let range = Range.create(section, 1, section, 2);
  postEditor = new PostEditor(mockEditor);
  postEditor.deleteRange(range);
  postEditor.complete();

  assert.equal(section.markers.length, 1, 'similar markers are coalesced');
  assert.equal(section.markers.head.value, 'ac', 'marker value is correct');
});

test$8('#moveSectionBefore moves the section as expected', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  const [headSection, tailSection] = post.sections.toArray();
  const collection = post.sections;
  postEditor = new PostEditor(mockEditor);
  let movedSection = postEditor.moveSectionBefore(collection, tailSection, headSection);
  postEditor.complete();

  assert.equal(post.sections.head, movedSection, 'movedSection is returned');
  assert.equal(post.sections.head.text, '123', 'tail section is now head');
  assert.equal(post.sections.tail.text, 'abc', 'head section is now tail');
});

test$8('#moveSectionBefore moves card sections', (assert) => {
  const listiclePayload = {some:'thing'};
  const otherPayload = {some:'other thing'};
  const post = Helpers.postAbstract.build(({post, cardSection}) => {
    return post([
      cardSection('listicle-card', listiclePayload),
      cardSection('other-card', otherPayload)
    ]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  const collection = post.sections;
  let [headSection, tailSection] = post.sections.toArray();
  postEditor = new PostEditor(mockEditor);
  postEditor.moveSectionBefore(collection, tailSection, headSection);
  postEditor.complete();

  ([headSection, tailSection] = post.sections.toArray());
  assert.equal(headSection.name, 'other-card', 'other-card moved to first spot');
  assert.equal(tailSection.name, 'listicle-card', 'listicle-card moved to last spot');
  assert.deepEqual(headSection.payload, otherPayload, 'payload is correct for other-card');
  assert.deepEqual(tailSection.payload, listiclePayload, 'payload is correct for listicle-card');
});

test$8('#moveSectionUp moves it up', (assert) => {
  const post = Helpers.postAbstract.build(({post, cardSection}) => {
    return post([
      cardSection('listicle-card'),
      cardSection('other-card')
    ]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  let [headSection, tailSection] = post.sections.toArray();
  postEditor = new PostEditor(mockEditor);
  postEditor.moveSectionUp(tailSection);
  postEditor.complete();

  ([headSection, tailSection] = post.sections.toArray());
  assert.equal(headSection.name, 'other-card', 'other-card moved to first spot');
  assert.equal(tailSection.name, 'listicle-card', 'listicle-card moved to last spot');

  postEditor = new PostEditor(mockEditor);
  let movedSection = postEditor.moveSectionUp(headSection);
  postEditor.complete();

  ([headSection, tailSection] = post.sections.toArray());
  assert.equal(post.sections.head, movedSection, 'movedSection is returned');
  assert.equal(headSection.name, 'other-card', 'moveSectionUp is no-op when card is at top');
});

test$8('moveSectionDown moves it down', (assert) => {
  const post = Helpers.postAbstract.build(({post, cardSection}) => {
    return post([
      cardSection('listicle-card'),
      cardSection('other-card')
    ]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);

  let [headSection, tailSection] = post.sections.toArray();
  postEditor = new PostEditor(mockEditor);
  postEditor.moveSectionDown(headSection);
  postEditor.complete();

  ([headSection, tailSection] = post.sections.toArray());
  assert.equal(headSection.name, 'other-card', 'other-card moved to first spot');
  assert.equal(tailSection.name, 'listicle-card', 'listicle-card moved to last spot');

  postEditor = new PostEditor(mockEditor);
  let movedSection = postEditor.moveSectionDown(tailSection);
  postEditor.complete();

  ([headSection, tailSection] = post.sections.toArray());
  assert.equal(post.sections.tail, movedSection, 'movedSection is returned');
  assert.equal(tailSection.name, 'listicle-card',
               'moveSectionDown is no-op when card is at bottom');
});

test$8('#setAttribute on empty Mobiledoc does nothing', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection}) => {
    return post([]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.blankRange();

  postEditor = new PostEditor(mockEditor);
  postEditor.setAttribute('text-align', 'center', range);
  postEditor.complete();

  assert.postIsSimilar(postEditor.editor.post, post);
});

test$8('#setAttribute sets attribute of a single section', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection}) => {
    return post([markupSection('p')]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 0);

  assert.deepEqual(
    post.sections.head.attributes,
    {}
  );

  postEditor = new PostEditor(mockEditor);
  postEditor.setAttribute('text-align', 'center', range);
  postEditor.complete();

  assert.deepEqual(
    post.sections.head.attributes,
    {
      'data-md-text-align': 'center'
    }
  );
});

test$8('#removeAttribute removes attribute of a single section', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection}) => {
    return post([markupSection('p', [], false, { 'data-md-text-align': 'center' })]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 0);

  assert.deepEqual(
    post.sections.head.attributes,
    {
      'data-md-text-align': 'center'
    }
  );

  postEditor = new PostEditor(mockEditor);
  postEditor.removeAttribute('text-align', range);
  postEditor.complete();

  assert.deepEqual(
    post.sections.head.attributes,
    {}
  );
});

test$8('#setAttribute sets attribute of multiple sections', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      markupSection('p', [marker('abc')]),
      cardSection('my-card'),
      markupSection('p', [marker('123')])
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 0,
                             post.sections.tail, 2);

  postEditor = new PostEditor(mockEditor);
  postEditor.setAttribute('text-align', 'center', range);
  postEditor.complete();

  assert.deepEqual(
    post.sections.head.attributes,
    {
      'data-md-text-align': 'center'
    }
  );
  assert.ok(post.sections.objectAt(1).isCardSection);
  assert.deepEqual(
    post.sections.tail.attributes,
    {
      'data-md-text-align': 'center'
    }
  );
});

test$8('#removeAttribute removes attribute of multiple sections', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      markupSection('p', [marker('abc')], false, { 'data-md-text-align': 'center' }),
      cardSection('my-card'),
      markupSection('p', [marker('123')], { 'data-md-text-align': 'left' })
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 0,
                             post.sections.tail, 2);

  postEditor = new PostEditor(mockEditor);
  postEditor.removeAttribute('text-align', range);
  postEditor.complete();

  assert.deepEqual(
    post.sections.head.attributes,
    {}
  );
  assert.ok(post.sections.objectAt(1).isCardSection);
  assert.deepEqual(
    post.sections.tail.attributes,
    {}
  );
});

test$8('#setAttribute sets attribute of a single list', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker, markup}) => {
    return post([listSection('ul', [
      listItem([marker('a')]),
      listItem([marker('def')]),
    ])]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.head, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.setAttribute('text-align', 'center', range);
  postEditor.complete();

  assert.deepEqual(
    post.sections.head.attributes,
    {
      'data-md-text-align': 'center'
    }
  );
});

test$8('#setAttribute when cursor is in non-markerable section changes nothing', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      cardSection('my-card')
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = post.sections.head.headPosition().toRange();

  postEditor = new PostEditor(mockEditor);
  postEditor.setAttribute('text-align', 'center', range);
  postEditor.complete();

  assert.ok(post.sections.head.isCardSection, 'card section not changed');
  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection changes single section to and from tag name', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection}) => {
    return post([markupSection('p')]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('blockquote', range);
  postEditor.complete();

  assert.equal(post.sections.head.tagName, 'blockquote');

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('blockquote', range);
  postEditor.complete();

  assert.equal(post.sections.head.tagName, 'p');
  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection changes multiple sections to and from tag name', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 2,
                             post.sections.tail, 2);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('blockquote', range);
  postEditor.complete();

  assert.equal(post.sections.head.tagName, 'blockquote');
  assert.equal(post.sections.tail.tagName, 'blockquote');

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('blockquote', range);
  postEditor.complete();

  assert.equal(post.sections.head.tagName, 'p');
  assert.equal(post.sections.tail.tagName, 'p');

  assert.positionIsEqual(
    mockEditor._renderedRange.head,
    post.sections.head.toPosition(2),
    'Maintains the selection'
  );
  assert.positionIsEqual(
    mockEditor._renderedRange.tail,
    post.sections.tail.toPosition(2),
    'Maintains the selection'
  );
});

test$8('#toggleSection skips over non-markerable sections', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      markupSection('p', [marker('abc')]),
      cardSection('my-card'),
      markupSection('p', [marker('123')])
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 0,
                             post.sections.tail, 2);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('blockquote', range);
  postEditor.complete();

  assert.equal(post.sections.head.tagName, 'blockquote');
  assert.ok(post.sections.objectAt(1).isCardSection);
  assert.equal(post.sections.tail.tagName, 'blockquote');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection when cursor is in non-markerable section changes nothing', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      cardSection('my-card')
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = post.sections.head.headPosition().toRange();

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('blockquote', range);
  postEditor.complete();

  assert.ok(post.sections.head.isCardSection, 'card section not changed');
  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection when editor has no cursor does nothing', (assert) => {
  assert.expect(6);
  let done = assert.async();

  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, false);
  let expected = Helpers.postAbstract.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  assert.ok(!editor$4.hasCursor(), 'editor has no cursor');
  assert.ok(editor$4.range.isBlank, 'editor has blank range');

  editor$4.run(postEditor => postEditor.toggleSection('blockquote'));

  Helpers.wait(() => {
    assert.postIsSimilar(editor$4.post, expected);
    assert.ok(document.activeElement !== editorElement$4,
              'editor element is not active');
    assert.ok(editor$4.range.isBlank, 'rendered range is blank');
    assert.equal(window.getSelection().rangeCount, 0, 'nothing selected');

    done();
  });
});

test$8('#toggleSection toggle single p -> list item', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [marker('a'), marker('b', [markup('b')]), marker('c')])
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1);
  let listSection = post.sections.head;
  assert.ok(listSection.isListSection);
  assert.equal(listSection.tagName, 'ul');
  assert.equal(listSection.items.length, 1);
  assert.equal(listSection.items.head.text, 'abc');
  let item = listSection.items.head;
  assert.equal(item.markers.length, 3);
  assert.equal(item.markers.objectAt(0).value, 'a');
  assert.equal(item.markers.objectAt(1).value, 'b');
  assert.ok(item.markers.objectAt(1).hasMarkup('b'), 'b has b markup');
  assert.equal(item.markers.objectAt(2).value, 'c');
});

test$8('#toggleSection toggle single list item -> p', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker, markup}) => {
    return post([listSection('ul', [
      listItem([marker('a'), marker('b', [markup('b')]), marker('c')])
    ])]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.head, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1);
  assert.equal(post.sections.head.tagName, 'p');
  assert.equal(post.sections.head.text, 'abc');
  assert.equal(post.sections.head.markers.length, 3);
  assert.equal(post.sections.head.markers.objectAt(0).value, 'a');
  assert.equal(post.sections.head.markers.objectAt(1).value, 'b');
  assert.ok(post.sections.head.markers.objectAt(1).hasMarkup('b'), 'b has b markup');
  assert.equal(post.sections.head.markers.objectAt(2).value, 'c');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection toggle multiple ps -> list and list -> multiple ps', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);
  });

  editor$4 = new Editor({mobiledoc});
  let { post } = editor$4;
  editor$4.render(editorElement$4);
  let range = Range.create(post.sections.head, 0, post.sections.tail, 2);

  postEditor = new PostEditor(editor$4);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  let listSection = post.sections.head;
  assert.equal(post.sections.length, 1, 'post has 1 list section after toggle');
  assert.ok(listSection.isListSection);
  assert.equal(listSection.tagName, 'ul');
  assert.equal(listSection.items.length, 2, '2 list items');
  assert.equal(listSection.items.head.text, 'abc');
  assert.equal(listSection.items.tail.text, '123');

  range = Range.create(listSection.items.head, 0, listSection.items.tail, 0);
  postEditor = new PostEditor(editor$4);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 2, 'post has 2 sections after toggle');
  assert.equal(post.sections.head.tagName, 'p');
  assert.equal(post.sections.tail.tagName, 'p');
  assert.equal(post.sections.head.text, 'abc');
  assert.equal(post.sections.tail.text, '123');

  assert.ok(editor$4.range.head.section === post.sections.head,
            'selected head correct');
  assert.equal(editor$4.range.head.offset, 0);
});

test$8('#toggleSection untoggle first list item changes it to markup section, retains markup', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker, markup}) => {
    return post([listSection('ul', [
      listItem([marker('a'), marker('b', [markup('b')]), marker('c')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ])]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.head, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 2, '2 sections');
  assert.equal(post.sections.head.tagName, 'p', 'head section is p');
  assert.equal(post.sections.head.text, 'abc');
  let section = post.sections.head;
  assert.equal(section.markers.length, 3);
  assert.equal(section.markers.objectAt(0).value, 'a');
  assert.ok(section.markers.objectAt(1).hasMarkup('b'), 'b has b markup');
  assert.equal(section.markers.objectAt(2).value, 'c');
  assert.ok(post.sections.tail.isListSection, 'tail is list section');
  assert.equal(post.sections.tail.items.length, 2, '2 items in list');
  assert.equal(post.sections.tail.items.head.text, 'def');
  assert.equal(post.sections.tail.items.tail.text, 'ghi');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection untoggle middle list item changes it to markup section, retaining markup', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker, markup}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('d'), marker('e', [markup('b')]), marker('f')]),
      listItem([marker('ghi')])
    ])]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.objectAt(1), 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 3, '3 sections');
  let section = post.sections.objectAt(1);
  assert.equal(section.tagName, 'p', 'middle section is p');
  assert.equal(section.text, 'def');
  assert.equal(section.markers.length, 3);
  assert.equal(section.markers.objectAt(0).value, 'd');
  assert.equal(section.markers.objectAt(1).value, 'e');
  assert.ok(section.markers.objectAt(1).hasMarkup('b'), 'e has b markup');
  assert.equal(section.markers.objectAt(2).value, 'f');
  assert.positionIsEqual(mockEditor._renderedRange.head, section.headPosition());

  assert.ok(post.sections.head.isListSection, 'head section is list');
  assert.ok(post.sections.tail.isListSection, 'tail section is list');
  assert.equal(post.sections.head.items.length, 1, '1 item in first list');
  assert.equal(post.sections.tail.items.length, 1, '1 item in last list');
  assert.equal(post.sections.head.items.head.text, 'abc');
  assert.equal(post.sections.tail.items.head.text, 'ghi');
});

test$8('#toggleSection toggle markup section -> ul between lists joins the lists', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, listSection, listItem, marker, markupSection}) => {
    return post([
      listSection('ul', [listItem([marker('abc')])]),
      markupSection('p', [marker('123')]),
      listSection('ul', [listItem([marker('def')])])
    ]);
  });
  editor$4 = new Editor({mobiledoc});
  let { post } = editor$4;
  editor$4.render(editorElement$4);
  let range = Range.create(post.sections.objectAt(1), 0);

  postEditor = new PostEditor(editor$4);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1, '1 sections');
  let section = post.sections.head;
  assert.ok(section.isListSection, 'list section');
  assert.equal(section.items.length, 3, '3 items');
  assert.deepEqual(section.items.map(i => i.text), ['abc', '123', 'def']);

  let listItem = section.items.objectAt(1);
  assert.ok(editor$4.range.head.section === listItem, 'correct head selection');
  assert.equal(editor$4.range.head.offset, 0);
});

test$8('#toggleSection untoggle multiple items at end of list changes them to markup sections', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ])]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.objectAt(1), 0,
                           post.sections.head.items.tail, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 3, '3 sections');
  assert.ok(post.sections.head.isListSection, 'head section is list');
  assert.equal(post.sections.head.items.length, 1, 'head section has 1 item');
  assert.equal(post.sections.head.items.head.text, 'abc');

  assert.equal(post.sections.objectAt(1).tagName, 'p', 'middle is p');
  assert.equal(post.sections.objectAt(1).text, 'def');
  assert.equal(post.sections.tail.tagName, 'p', 'tail is p');
  assert.equal(post.sections.tail.text, 'ghi');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.objectAt(1).headPosition());
});

test$8('#toggleSection untoggle multiple items at start of list changes them to markup sections', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ])]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.head, 0,
                           post.sections.head.items.objectAt(1), 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 3, '3 sections');
  assert.equal(post.sections.head.tagName, 'p', 'head section is p');
  assert.equal(post.sections.head.text, 'abc');

  assert.equal(post.sections.objectAt(1).tagName, 'p', '2nd section is p');
  assert.equal(post.sections.objectAt(1).text, 'def');

  assert.ok(post.sections.objectAt(2).isListSection, '3rd section is list');
  assert.equal(post.sections.objectAt(2).items.length, 1, 'list has 1 item');
  assert.equal(post.sections.objectAt(2).items.head.text, 'ghi');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.headPosition());
});

test$8('#toggleSection untoggle items and overflowing markup sections changes the overflow to items', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([
      listSection('ul', [
        listItem([marker('abc')]),
        listItem([marker('def')]),
        listItem([marker('ghi')])
      ]),
      markupSection('p', [marker('123')])
    ]);
  });
  editor$4 = new Editor({mobiledoc});
  editor$4.render(editorElement$4);
  let { post } = editor$4;
  let range = Range.create(post.sections.head.items.objectAt(1), 0,
                           post.sections.tail, 0);

  postEditor = new PostEditor(editor$4);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1, '1 section');
  assert.ok(post.sections.head.isListSection, 'head section is list');
  assert.equal(post.sections.head.items.length, 4, 'list has 4 items');

  let text = post.sections.head.items.toArray().map(i => i.text);
  assert.deepEqual(text, ['abc', 'def', 'ghi', '123']);

  assert.ok(editor$4.range.head.section === post.sections.head.items.objectAt(1), 'selected head correct');
  assert.equal(editor$4.range.head.offset, 0);
});

test$8('#toggleSection untoggle last list item changes it to markup section', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ])]);
  });
  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  let range = Range.create(post.sections.head.items.tail, 0);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 2, '2 sections');
  assert.ok(post.sections.head.isListSection, 'head section is list');
  assert.equal(post.sections.tail.tagName, 'p', 'tail is p');
  assert.equal(post.sections.tail.text, 'ghi');

  assert.equal(post.sections.head.items.length, 2, '2 items in list');
  assert.equal(post.sections.head.items.head.text, 'abc');
  assert.equal(post.sections.head.items.tail.text, 'def');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.tail.headPosition());
});

test$8('#toggleSection toggle list item to different type of list item', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [listItem([marker('abc')])])]);
  });

  let range = Range.create(post.sections.head.items.head, 0);

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ol', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1, '1 section');
  assert.ok(post.sections.head.isListSection, 'section is list');
  assert.equal(post.sections.head.tagName, 'ol', 'section is ol list');
  assert.equal(post.sections.head.items.length, 1, '1 item');
  assert.equal(post.sections.head.items.head.text, 'abc');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.head.items.head.headPosition());
});

test$8('#toggleSection toggle list item to different type of list item when other sections precede it', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker, markupSection}) => {
    return post([
      markupSection('p', [marker('123')]),
      listSection('ul', [listItem([marker('abc')])])
    ]);
  });

  let range = Range.create(post.sections.tail.items.head, 0);

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ol', range);
  postEditor.complete();

  assert.equal(post.sections.length, 2, '2 section');
  assert.equal(post.sections.head.tagName, 'p', '1st section is p');
  assert.equal(post.sections.head.text, '123');
  assert.ok(post.sections.tail.isListSection, 'section is list');
  assert.equal(post.sections.tail.tagName, 'ol', 'section is ol list');
  assert.equal(post.sections.tail.items.length, 1, '1 item');
  assert.equal(post.sections.tail.items.head.text, 'abc');

  assert.positionIsEqual(mockEditor._renderedRange.head, post.sections.tail.items.head.headPosition());
});

test$8('#toggleSection toggle when cursor on card section is no-op', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, cardSection}) => {
    return post([cardSection('my-card')]);
  });

  let range = Range.create(post.sections.head, 0);

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('ol', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1, '1 section');
  assert.ok(post.sections.head.isCardSection, 'still card section');

  assert.positionIsEqual(mockEditor._renderedRange.head, range.head, 'range head is set to same');
  assert.positionIsEqual(mockEditor._renderedRange.tail, range.tail, 'range tail is set to same');
});

test$8('#toggleSection joins contiguous list items', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, listSection, listItem, marker}) => {
    return post([
      listSection('ul', [listItem([marker('abc')])]),
      listSection('ol', [listItem([marker('123')])]),
      listSection('ul', [listItem([marker('def')])])
    ]);
  });

  editor$4 = new Editor({mobiledoc});
  editor$4.render(editorElement$4);
  let { post } = editor$4;
  let range = Range.create(post.sections.objectAt(1).items.head, 0);
  postEditor = new PostEditor(editor$4);
  postEditor.toggleSection('ul', range);
  postEditor.complete();

  assert.equal(post.sections.length, 1, '1 section');
  assert.ok(post.sections.head.isListSection, 'is list');
  assert.equal(post.sections.head.items.length, 3, '3 items');
  assert.deepEqual(post.sections.head.items.map(i => i.text),
                   ['abc', '123', 'def']);
});

test$8('#toggleSection maintains the selection when the sections in the selected range are still there', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')])
    ]);
  });

  mockEditor = renderBuiltAbstract$1(post, mockEditor);
  const range = Range.create(post.sections.head, 1,
                             post.sections.head, 2);

  postEditor = new PostEditor(mockEditor);
  postEditor.toggleSection('h1', range);
  postEditor.complete();

  assert.positionIsEqual(
    mockEditor._renderedRange.head,
    post.sections.head.toPosition(1),
    'Maintains the selection'
  );
  assert.positionIsEqual(
    mockEditor._renderedRange.tail,
    post.sections.tail.toPosition(2),
    'Maintains the selection'
  );
});

test$8('#toggleMarkup when cursor is in non-markerable does nothing', (assert) => {
  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      cardSection('my-card')
    ]);
  });

  const range = editor$4.post.sections.head.headPosition().toRange();
  postEditor = new PostEditor(editor$4);
  postEditor.toggleMarkup('b', range);
  postEditor.complete();

  assert.ok(editor$4.post.sections.head.isCardSection);
  assert.positionIsEqual(editor$4._renderedRange.head,
                         editor$4.post.sections.head.headPosition());
});

test$8('#toggleMarkup when cursor surrounds non-markerable does nothing', (assert) => {
  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      cardSection('my-card')
    ]);
  });

  const range = editor$4.post.sections.head.toRange();
  postEditor = new PostEditor(editor$4);
  postEditor.toggleMarkup('b', range);
  postEditor.complete();

  assert.ok(editor$4.post.sections.head.isCardSection);
  assert.positionIsEqual(editor$4._renderedRange.head,
                         editor$4.post.sections.head.headPosition());
});

test$8('#toggleMarkup when range has the markup removes it', (assert) => {
  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('abc', [markup('b')])])]);
  });
  let expected = Helpers.postAbstract.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  const range = editor$4.post.sections.head.toRange();
  postEditor = new PostEditor(editor$4);
  postEditor.toggleMarkup('b', range);
  postEditor.complete();

  assert.positionIsEqual(editor$4._renderedRange.head, editor$4.post.headPosition());
  assert.positionIsEqual(editor$4._renderedRange.tail, editor$4.post.tailPosition());
  assert.postIsSimilar(editor$4.post, expected);
});

test$8('#toggleMarkup when only some of the range has it removes it', (assert) => {
  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [
      marker('a'),
      marker('b', [markup('b')]),
      marker('c')
    ])]);
  });
  let expected = Helpers.postAbstract.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  const range = editor$4.post.sections.head.toRange();
  postEditor = new PostEditor(editor$4);
  postEditor.toggleMarkup('b', range);
  postEditor.complete();

  assert.positionIsEqual(editor$4._renderedRange.head,
                         editor$4.post.sections.head.headPosition());
  assert.positionIsEqual(editor$4._renderedRange.tail,
                         editor$4.post.sections.head.tailPosition());
  assert.postIsSimilar(editor$4.post, expected);
});

test$8('#toggleMarkup when range does not have the markup adds it', (assert) => {
  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  let expected = Helpers.postAbstract.build(
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('abc', [markup('b')])])]);
  });

  const range = editor$4.post.sections.head.toRange();
  postEditor = new PostEditor(editor$4);
  postEditor.toggleMarkup('b', range);
  postEditor.complete();

  assert.positionIsEqual(editor$4._renderedRange.head,
                         editor$4.post.sections.head.headPosition());
  assert.positionIsEqual(editor$4._renderedRange.tail,
                         editor$4.post.sections.head.tailPosition());
  assert.postIsSimilar(editor$4.post, expected);
});

test$8('#toggleMarkup when the editor has no cursor', (assert) => {
  let done = assert.async();

  editor$4 = buildEditorWithMobiledoc(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  }, false);
  let expected = Helpers.postAbstract.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  editor$4._renderedRange = null;
  editor$4.run(postEditor => postEditor.toggleMarkup('b'));

  Helpers.wait(() => {
    assert.postIsSimilar(editor$4.post, expected);
    assert.equal(window.getSelection().rangeCount, 0,
                 'nothing is selected');
    assert.ok(document.activeElement !== editorElement$4,
              'active element is not editor element');
    assert.ok(editor$4._renderedRange && editor$4._renderedRange.isBlank, 'rendered range is blank');

    done();
  });
});

test$8('#insertMarkers inserts an atom', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup, atom}) => {
    toInsert = [
      atom('simple-atom', '123', [markup('b')])
    ];
    expected = post([
      markupSection('p', [
        marker('abc'),
        atom('simple-atom', '123', [markup('b')]),
        marker('def')
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abcdef')])]);
  });
  let position = editor$4.post.sections.head.toPosition('abc'.length);
  postEditor = new PostEditor(editor$4);
  postEditor.insertMarkers(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.toPosition(4)
  );
});

test$8('#insertMarkers inserts the markers in middle, merging markups', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = [
      marker('123', [markup('b')]), marker('456')
    ];
    expected = post([
      markupSection('p', [
        marker('abc'),
        marker('123', [markup('b')]),
        marker('456def')
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abcdef')])]);
  });
  let position = editor$4.post.sections.head.toPosition('abc'.length);
  postEditor = new PostEditor(editor$4);
  postEditor.insertMarkers(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.toPosition('abc123456'.length)
  );
});

test$8('#insertMarkers inserts the markers when the markerable has no markers', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = [
      marker('123', [markup('b')]), marker('456')
    ];
    expected = post([
      markupSection('p', [
        marker('123', [markup('b')]),
        marker('456')
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection}) => {
    return post([markupSection()]);
  });
  let position = editor$4.post.sections.head.headPosition();
  postEditor = new PostEditor(editor$4);
  postEditor.insertMarkers(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.toPosition('123456'.length)
  );
});

test$8('#insertMarkers inserts the markers at start', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = [
      marker('123', [markup('b')]), marker('456')
    ];
    expected = post([
      markupSection('p', [
        marker('123', [markup('b')]),
        marker('456abc')
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  let position = editor$4.post.sections.head.headPosition();
  postEditor = new PostEditor(editor$4);
  postEditor.insertMarkers(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.toPosition('123456'.length)
  );
});

test$8('#insertMarkers inserts the markers at end', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = [
      marker('123', [markup('b')]), marker('456')
    ];
    expected = post([
      markupSection('p', [
        marker('abc'),
        marker('123', [markup('b')]),
        marker('456')
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  let position = editor$4.post.sections.head.tailPosition();
  postEditor = new PostEditor(editor$4);
  postEditor.insertMarkers(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.tailPosition()
  );
});

test$8('#insertMarkers throws if the position is not markerable', (assert) => {
  let toInsert;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = [marker('123', [markup('b')]), marker('456')];
  });

  editor$4 = buildEditorWithMobiledoc(({post, cardSection}) => {
    return post([cardSection('some-card')]);
  });
  let position = editor$4.post.sections.head.tailPosition();
  postEditor = new PostEditor(editor$4);

  assert.throws(() => {
    postEditor.insertMarkers(position, toInsert);
  }, /cannot insert.*non-markerable/i);
});

test$8('#insertText is no-op if the position section is not markerable', (assert) => {
  let toInsert = '123';
  let expected = Helpers.postAbstract.build(({post, cardSection}) => {
    return post([cardSection('test-card')]);
  });
  editor$4 = buildEditorWithMobiledoc(({post, cardSection}) => {
    return post([cardSection('test-card')]);
  });
  let position = editor$4.post.sections.head.headPosition();
  postEditor = new PostEditor(editor$4);
  postEditor.insertText(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.ok(!editor$4._renderedRange, 'no range is rendered since nothing happened');
});

test$8('#insertText inserts the text at start', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = '123';
    expected = post([
      markupSection('p', [
        marker('123abc', [markup('b')])
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('abc', [markup('b')])])]);
  });
  let position = editor$4.post.sections.head.headPosition();
  postEditor = new PostEditor(editor$4);
  postEditor.insertText(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.toPosition('123'.length)
  );
});

test$8('#insertText inserts text in the middle', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = '123';
    expected = post([
      markupSection('p', [
        marker('ab123c', [markup('b')])
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('abc', [markup('b')])])]);
  });
  let position = editor$4.post.sections.head.toPosition('ab'.length);
  postEditor = new PostEditor(editor$4);
  postEditor.insertText(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.toPosition('ab123'.length)
  );
});

test$8('#insertText inserts text at the end', (assert) => {
  let toInsert, expected;
  Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    toInsert = '123';
    expected = post([
      markupSection('p', [
        marker('abc123', [markup('b')])
    ])]);
  });

  editor$4 = buildEditorWithMobiledoc(({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [marker('abc', [markup('b')])])]);
  });
  let position = editor$4.post.sections.head.tailPosition();
  postEditor = new PostEditor(editor$4);
  postEditor.insertText(position, toInsert);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
  assert.positionIsEqual(
    editor$4._renderedRange.head,
    editor$4.post.sections.head.tailPosition()
  );
});

test$8('#_splitListItem creates two list items', (assert) => {
  let expected = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker, markup}) => {
    return post([listSection('ul', [
      listItem([marker('abc'), marker('bo', [markup('b')])]),
      listItem([marker('ld', [markup('b')])])
    ])]);
  });
  editor$4 = buildEditorWithMobiledoc(
    ({post, listSection, listItem, marker, markup}) => {
    return post([listSection('ul', [
      listItem([marker('abc'), marker('bold', [markup('b')])])
    ])]);
  });

  let item = editor$4.post.sections.head.items.head;
  let position = item.toPosition('abcbo'.length);
  postEditor = new PostEditor(editor$4);
  postEditor._splitListItem(item, position);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
  assert.renderTreeIsEqual(editor$4._renderTree, expected);
});

test$8('#_splitListItem when position is start creates blank list item', (assert) => {
  let expected = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('')]),
      listItem([marker('abc')])
    ])]);
  });
  editor$4 = buildEditorWithMobiledoc(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [listItem([marker('abc')])])]);
  });

  let item = editor$4.post.sections.head.items.head;
  let position = item.headPosition();
  postEditor = new PostEditor(editor$4);
  postEditor._splitListItem(item, position);
  postEditor.complete();

  assert.postIsSimilar(editor$4.post, expected);
});

const { module: module$9, test: test$9 } = Helpers;
const { editor: { retargetRange: retargetRange$2 } } = Helpers;

let editor$5, editorElement$5;
// see https://github.com/bustle/mobiledoc-kit/issues/259
module$9('Unit: PostEditor: #insertPost', {
  beforeEach() {
    editorElement$5 = $('#editor')[0];
  },

  afterEach() {
    if (editor$5) {
      editor$5.destroy();
      editor$5 = null;
    }
  }
});

let blankSectionExpecations = [
  ['* abc'], // single list item
  ['* abc','* def'], // multiple list items
  ['abc'], // single section
  ['abc','def'], // multiple sections, see https://github.com/bustle/mobiledoc-kit/issues/462
  ['*abc*'], // section with markup
  ['[my-card]'], // single card
  ['[my-card]', '[my-other-card]'], // multiple cards
  ['abc','* 123','* 456','[my-card]'], // mixed
];
blankSectionExpecations.forEach(dsl => {
  test$9(`inserting "${dsl}" in blank section replaces it`, (assert) => {
    let {post: toInsert} = Helpers.postAbstract.buildFromText(dsl);
    let expected = toInsert;
    editor$5 = Helpers.editor.buildFromText(['|'], {unknownCardHandler: () => {}, element: editorElement$5});

    editor$5.run(postEditor => postEditor.insertPost(editor$5.range.head, toInsert));

    assert.renderTreeIsEqual(editor$5._renderTree, expected);
    assert.postIsSimilar(editor$5.post, expected);

    let expectedRange = editor$5.post.tailPosition().toRange();
    assert.rangeIsEqual(editor$5.range, expectedRange);
  });
});

let expectationGroups$2 = [{
  groupName: 'insert around card',
  expectations: [
    // insert 1 section
    [['|[my-card]'], ['abc'], ['abc|','[my-card]']],
    [['[my-card]|'], ['abc'], ['[my-card]','abc|']],

    // insert multiple sections
    [['|[my-card]'], ['abc','def'], ['abc','def|','[my-card]']],
    [['[my-card]|'], ['abc','def'], ['[my-card]','abc','def|']],

    // insert list with 1 item
    [['|[my-card]'], ['* abc'], ['* abc|','[my-card]']],
    [['[my-card]|'], ['* abc'], ['[my-card]','* abc|']],

    // insert list with multiple items
    [['|[my-card]'], ['* abc','* def'], ['* abc','* def|', '[my-card]']],
    [['[my-card]|'], ['* abc','* def'], ['[my-card]','* abc','* def|']]
  ],
}, {
  groupName: 'insert card around markerable',
  expectations: [
    // insert card only
    [['|abc'], ['[my-card]'], ['[my-card]|','abc']],
    [['ab|c'], ['[my-card]'], ['ab','[my-card]|','c']],
    [['abc|'], ['[my-card]'], ['abc', '[my-card]|']],

    // insert card+section
    [['|abc'], ['[my-card]','def'], ['[my-card]','def|','abc']],
    [['ab|c'], ['[my-card]','def'], ['ab','[my-card]','def|','c']],
    [['abc|'], ['[my-card]','def'], ['abc','[my-card]','def|']],

    // insert section+card
    [['|abc'], ['def','[my-card]'], ['def', '[my-card]|','abc']],
    [['ab|c'], ['def','[my-card]'], ['abdef','[my-card]|','c']],
    [['abc|'], ['def','[my-card]'], ['abcdef','[my-card]|']]
  ]
}, {
  groupName: 'insert (non-list-item) markerable(s) around markerable',
  expectations: [
    // insert 1 section
    [['|abc'], ['123'], ['123|abc']],
    [['ab|c'], ['123'], ['ab123|c']],
    [['abc|'], ['123'], ['abc123|']],

    // insert multiple sections
    [['|abc'], ['123','456'], ['123','456|', 'abc']],
    [['ab|c'], ['123','456'], ['ab123','456|','c']],
    [['abc|'], ['123','456'], ['abc123','456|']]
  ]
}, {
  groupName: 'insert list item(s) around markerable',
  expectations: [
    // insert 1 item
    [['|abc'], ['* 123'], ['123|abc']],
    [['ab|c'], ['* 123'], ['ab123|c']],
    [['abc|'], ['* 123'], ['abc123|']],

    // insert multiple items
    [['|abc'], ['* 123','* 456'], ['123','* 456|', 'abc']],
    [['ab|c'], ['* 123','* 456'], ['ab123','* 456|', 'c']],
    [['abc|'], ['* 123','* 456'], ['abc123','* 456|']]
  ]
}, {
  groupName: 'insert list+markup-section around markerable',
  expectations: [
    // list + markup section
    [['|abc'], ['* 123','def'], ['123','def|','abc']],
    [['ab|c'], ['* 123','def'], ['ab123','def|','c']],
    [['abc|'], ['* 123','def'], ['abc123','def|']],

    // markup section + 1-item list
    [['|abc'], ['def', '* 123'], ['def', '* 123|','abc']],
    [['ab|c'], ['def', '* 123'], ['abdef','* 123|','c']],
    [['abc|'], ['def', '* 123'], ['abcdef','* 123|']],

    // markup section + multi-item list
    [['|abc'], ['def', '* 123','* 456'], ['def', '* 123','* 456|', 'abc']],
    [['ab|c'], ['def', '* 123','* 456'], ['abdef', '* 123','* 456|', 'c']],
    [['abc|'], ['def', '* 123','* 456'], ['abcdef', '* 123','* 456|']],
  ]
}, {
  groupName: 'insert into list',
  expectations: [
    // insert 1 markup section
    [['* |abc'], ['def'], ['* def|abc']],
    [['* ab|c'], ['def'], ['* abdef|c']],
    [['* abc|'], ['def'], ['* abcdef|']],

    // insert multiple markup sections
    [['* abc|'], ['def', 'ghi'], ['* abcdef', '* ghi|']],
    // See https://github.com/bustle/mobiledoc-kit/issues/456
    [['* abc','* def|'], ['ghi', 'jkl'], ['* abc', '* defghi', '* jkl|']],

    // insert markup sections + card
    [['* abc','* def|'], ['ghi', 'jkl', '[my-card]'], ['* abc', '* defghi', '* jkl', '[my-card]|']],

    // insert list item
    [['* |abc'], ['* def'], ['* def|abc']],
    [['* ab|c'], ['* def'], ['* abdef|c']],
    [['* abc|'], ['* def'], ['* abcdef|']],

    // insert multiple list items
    [['* |abc'], ['* def', '* ghi'], ['* def','* ghi|', '* abc']],
    [['* ab|c'], ['* def', '* ghi'], ['* abdef','* ghi|', '* c']],
    [['* abc|'], ['* def', '* ghi'], ['* abcdef','* ghi|']],

    // insert list + markup
    [['* |abc'], ['* def', '123'], ['* def','123|', '* abc']],
    [['* ab|c'], ['* def', '123'], ['* abdef','123|', '* c']],
    [['* abc|'], ['* def', '123'], ['* abcdef','123|']],

    // insert into empty list
    [['* |'], ['[my-card]'], ['* ', '[my-card]|']],
    [['* |'], ['abc'], ['* abc|']],
    [['* |'], ['abc', 'def'], ['* abc', '* def|']],
    [['* |'], ['* abc'], ['* abc|']],
    [['* |'], ['* abc', '* def'], ['* abc', '* def|']],


    /// insert between list items ///

    // insert card between list items
    [['* abc|','* def'], ['[my-card]'], ['* abc','[my-card]|','* def']],
    [['* ab|c','* def'], ['[my-card]'], ['* ab','[my-card]|','* c','* def']],
    [['* abc|','* def'], ['[my-card]'], ['* abc','[my-card]|','* def']],
    // See https://github.com/bustle/mobiledoc-kit/issues/467
    [['* abc','* |def'], ['[my-card]'], ['* abc','[my-card]|','* def']],

    // insert markup section between list items
    [['* abc|','* def'], ['123'], ['* abc123|','* def']],
    [['* abc','* |def'], ['123'], ['* abc','* 123|def']],

    // insert 1 list item between list items
    [['* abc|','* def'], ['* 123'], ['* abc123|','* def']],
    [['* abc','* |def'], ['* 123'], ['* abc','* 123|def']],

    // insert multiple list items between list items
    [['* abc|','* def'], ['* 123', '* 456'], ['* abc123','* 456|','* def']],
    [['* abc','* |def'], ['* 123', '* 456'], ['* abc','* 123', '* 456|','* def']]
  ]
}];

expectationGroups$2.forEach(({groupName, expectations}) => {
  expectations.forEach(([editorDSL, toInsertDSL, expectedDSL]) => {
    test$9(`${groupName}: inserting "${toInsertDSL}" in "${editorDSL}" -> "${expectedDSL}"`, (assert) => {
      editor$5 = Helpers.editor.buildFromText(editorDSL, {unknownCardHandler: () => {}, element: editorElement$5});
      let {post: toInsert} = Helpers.postAbstract.buildFromText(toInsertDSL);
      let {post: expectedPost, range: expectedRange} = Helpers.postAbstract.buildFromText(expectedDSL);

      editor$5.run(postEditor => postEditor.insertPost(editor$5.range.head, toInsert));

      assert.renderTreeIsEqual(editor$5._renderTree, expectedPost);
      assert.postIsSimilar(editor$5.post, expectedPost);
      assert.rangeIsEqual(editor$5.range, retargetRange$2(expectedRange, editor$5.post));
    });
  });
});

const { module: module$a, test: test$a } = Helpers;

let editor$6, editorElement$6;

module$a('Unit: UI', {
  beforeEach() {
    editorElement$6 = $('#editor')[0];
  },
  afterEach() {
    if (editor$6) {
      editor$6.destroy();
      editor$6 = null;
    }
  }
});

test$a('toggleLink calls the default window prompt', (assert) => {
  assert.expect(1);
  window.prompt = () => assert.ok(true, 'window.prompt called');

  editor$6 = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$6, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  Helpers.dom.selectText(editor$6 ,'something', editorElement$6);

  toggleLink(editor$6);
});

test$a('toggleLink accepts a custom prompt function', (assert) => {
  assert.expect(1);

  let prompt = () => assert.ok(true, 'custom prompt called');

  editor$6 = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$6, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  Helpers.dom.selectText(editor$6 ,'something', editorElement$6);

  toggleLink(editor$6, prompt);
});

const {module: module$b, test: test$b} = Helpers;

let builder$1;
module$b('Unit: Atom', {
  beforeEach() {
    builder$1 = new PostNodeBuilder();
  },
  afterEach() {
    builder$1 = null;
  }
});

test$b('can create an atom with value and payload', (assert) => {
  let payload = {};
  let value = 'atom-value';
  let name = 'atom-name';
  let atom = builder$1.createAtom(name, value, payload);
  assert.ok(!!atom, 'creates atom');
  assert.ok(atom.name === name, 'has name');
  assert.ok(atom.value === value, 'has value');
  assert.ok(atom.payload === payload, 'has payload');
  assert.ok(atom.length === 1, 'has length of 1');
});

const {module: module$c, test: test$c} = Helpers;

let builder$2;
module$c('Unit: Card', {
  beforeEach() {
    builder$2 = new PostNodeBuilder();
  },
  afterEach() {
    builder$2 = null;
  }
});

test$c('can create a card with payload', (assert) => {
  const payload = {};
  const card = builder$2.createCardSection('card-name', payload);
  assert.ok(!!card, 'creates card');
  assert.ok(card.payload === payload, 'has payload');
});

test$c('cloning a card copies payload', (assert) => {
  const payload = {foo:'bar'};

  const card = builder$2.createCardSection('card-name', payload);
  const card2 = card.clone();

  assert.ok(card !== card2, 'card !== cloned');
  assert.ok(card.payload !== card2.payload, 'payload is copied');

  card.payload.foo = 'other foo';
  assert.equal(card2.payload.foo, 'bar', 'card2 payload not updated');
});

test$c('card cannot have attributes', (assert) => {
  const card = builder$2.createCardSection('card-name');

  assert.equal(card.attributes, undefined);
});

const {module: module$d, test: test$d} = Helpers;

module$d('Unit: Models: LifecycleCallbacksMixin');

test$d('#addCallback permanently adds the callback', (assert) => {
  let item = new LifecycleCallbacks(['test']);
  let queueName = 'test';
  let called = 0;
  let callback = () => called++;
  item.addCallback(queueName, callback);

  item.runCallbacks(queueName);
  assert.equal(called, 1);

  item.runCallbacks(queueName);
  assert.equal(called, 2, 'callback is run a second time');
});

test$d('#addCallback callback only runs in its queue', (assert) => {
  let item = new LifecycleCallbacks(['test', 'other']);
  let queueName = 'test';
  let called = 0;
  let callback = () => called++;
  item.addCallback(queueName, callback);

  let otherQueueName = 'other';
  item.runCallbacks(otherQueueName);

  assert.equal(called, 0);
});

test$d('callbacks run with arguments', (assert) => {
  let item = new LifecycleCallbacks(['test']);
  let queueName = 'test';
  let arg1, arg2;
  let foo = {}, bar = {};
  let callback = (_arg1, _arg2) => {
    arg1 = _arg1;
    arg2 = _arg2;
  };
  item.addCallback(queueName, callback);
  item.runCallbacks(queueName, [foo, bar]);

  assert.deepEqual(arg1, foo);
  assert.deepEqual(arg2, bar);
});

test$d('#addCallbackOnce only runs the callback one time', (assert) => {
  let item = new LifecycleCallbacks(['test']);
  let queueName = 'test';
  let called = 0;
  let callback = () => called++;
  item.addCallbackOnce(queueName, callback);

  item.runCallbacks(queueName);
  assert.equal(called, 1, 'runs once');

  item.runCallbacks(queueName);
  assert.equal(called, 1, 'does not run twice');
});

test$d('#addCallback and #addCallbackOnce work correctly together', (assert) => {
  let item = new LifecycleCallbacks(['test']);
  let queueName = 'test';
  let calledOnce = 0;
  let callbackOnce = () => calledOnce++;
  let called = 0;
  let callback = () => called++;

  item.addCallbackOnce(queueName, callbackOnce);
  item.addCallback(queueName, callback);

  item.runCallbacks(queueName);
  assert.equal(called, 1, 'runs callback');
  assert.equal(calledOnce, 1, 'runs one-time callback once');

  item.runCallbacks(queueName);
  assert.equal(called, 2, 'runs callback again');
  assert.equal(calledOnce, 1, 'runs one-time callback only once');
});

const VALID_ATTRIBUTES$3 = [
  { key: 'data-md-text-align', value: 'center' },
  { key: 'data-md-text-align', value: 'justify' },
  { key: 'data-md-text-align', value: 'left' },
  { key: 'data-md-text-align', value: 'right' }
];

const INVALID_ATTRIBUTES = [
  { key: 'data-foo', value: 'baz' }
];

const { module: module$e, test: test$e } = Helpers;

let builder$3;
module$e('Unit: List Section', {
  beforeEach() {
    builder$3 = new PostNodeBuilder();
  },
  afterEach() {
    builder$3 = null;
  }
});

VALID_ATTRIBUTES$3.forEach(attribute => {
  // eslint-disable-next-line no-loop-func
  test$e(`a section can have attribute "${attribute.key}" with value "${attribute.value}`, assert => {
    const attributes = {};
    attributes[attribute.key] = attribute.value;

    const s1 = builder$3.createListSection('ol', [], attributes);
    assert.deepEqual(
      s1.attributes,
      attributes,
      'Attribute set at instantiation'
    );
  });
});

INVALID_ATTRIBUTES.forEach(attribute => {
  // eslint-disable-next-line no-loop-func
  test$e(`a section throws when invalid attribute "${attribute.key}" is passed to a marker`, assert => {
    const attributes = {};
    attributes[attribute.key] = attribute.value;

    assert.throws(() => {
      builder$3.createListSection('ul', [], attributes);
    });
  });

  test$e('cloning a list section creates the same type of list section', assert => {
    let item = builder$3.createListItem([builder$3.createMarker('abc')]);
    let list = builder$3.createListSection('ol', [item]);
    let cloned = list.clone();

    assert.equal(list.tagName, cloned.tagName);
    assert.equal(list.items.length, cloned.items.length);
    assert.equal(list.items.head.text, cloned.items.head.text);
  });
});

const {module: module$f, test: test$f} = Helpers;

let builder$4;
module$f('Unit: Marker', {
  beforeEach() {
    builder$4 = new PostNodeBuilder();
  },
  afterEach() {
    builder$4 = null;
  }
});

test$f('a marker can have a markup applied to it', (assert) => {
  const m1 = builder$4.createMarker('hi there!');
  m1.addMarkup(builder$4.createMarkup('b'));

  assert.ok(m1.hasMarkup('b'));
});

test$f('a marker can have the same markup tagName applied twice', (assert) => {
  const m1 = builder$4.createMarker('hi there!');
  m1.addMarkup(builder$4.createMarkup('b'));
  m1.addMarkup(builder$4.createMarkup('b'));

  assert.equal(m1.markups.length, 2, 'markup only applied once');
});

test$f('a marker can have a complex markup applied to it', (assert) => {
  const m1 = builder$4.createMarker('hi there!');
  const markup = builder$4.createMarkup('a', {href:'blah'});
  m1.addMarkup(markup);

  assert.ok(m1.hasMarkup('a'));
  assert.equal(m1.getMarkup('a').attributes.href, 'blah');
});

test$f('a marker can have the same complex markup tagName applied twice, even with different attributes', (assert) => {
  const m1 = builder$4.createMarker('hi there!');
  const markup1 = builder$4.createMarkup('a', {href:'blah'});
  const markup2 = builder$4.createMarkup('a', {href:'blah2'});
  m1.addMarkup(markup1);
  m1.addMarkup(markup2);

  assert.equal(m1.markups.length, 2, 'only one markup');
  assert.equal(m1.getMarkup('a').attributes.href, 'blah',
               'first markup is applied');
});

test$f('#split splits a marker in 3 with blank markers when no endOffset is passed', (assert) => {
  const m1 = builder$4.createMarker('hi there!');
  m1.addMarkup(builder$4.createMarkup('b'));

  const [beforeMarker, ...afterMarkers] = m1.split(5);

  assert.ok(beforeMarker.hasMarkup('b'));
  afterMarkers.forEach(m => assert.ok(m.hasMarkup('b')));

  assert.equal(beforeMarker.value, 'hi th');
  assert.equal(afterMarkers[0].value, 'ere!');
  assert.ok(afterMarkers[1].isBlank, 'final split marker is empty');
});

test$f('#split splits a marker in 3 when endOffset is passed', (assert) => {
  const m = builder$4.createMarker('hi there!');
  m.addMarkup(builder$4.createMarkup('b'));

  const [beforeMarker, ...afterMarkers] = m.split(2, 4);

  assert.equal(1 + afterMarkers.length, 3, 'creates 3 new markers');
  assert.ok(beforeMarker.hasMarkup('b'), 'beforeMarker has markup');
  afterMarkers.forEach(m => assert.ok(m.hasMarkup('b'), 'afterMarker has markup'));

  assert.equal(beforeMarker.value, 'hi');
  assert.equal(afterMarkers[0].value, ' t');
  assert.equal(afterMarkers[1].value, 'here!');
});

test$f('#split creates an initial empty marker if the offset is 0', (assert) => {
  const m = builder$4.createMarker('hi there!');
  const [beforeMarker, ...afterMarkers] = m.split(0);
  assert.equal(afterMarkers.length, 2, '2 after markers');
  assert.ok(beforeMarker.isBlank, 'beforeMarker is empty');
  assert.equal(afterMarkers[0].value, 'hi there!');
  assert.ok(afterMarkers[1].isBlank, 'final afterMarker is empty');
});

test$f('#clone a marker', (assert) => {
  const marker = builder$4.createMarker('hi there!');
  const cloned = marker.clone();
  assert.equal(marker.builder, cloned.builder, 'builder is present');
  assert.equal(marker.value, cloned.value, 'value is present');
  assert.equal(marker.markups.length, cloned.markups.length, 'markup length is the same');
});

// https://github.com/bustle/mobiledoc-kit/issues/274
test$f('#deleteValueAtOffset handles emoji', (assert) => {
  let str = 'monkey ';
  assert.equal(str.length, 'monkey '.length + 2,
               'string length reports monkey emoji as length 2');
  let marker = builder$4.createMarker(str);
  marker.deleteValueAtOffset(str.length - 1);
  assert.equal(marker.value, 'monkey ', 'deletes correctly from low surrogate');

  marker = builder$4.createMarker(str);
  marker.deleteValueAtOffset(str.length - 2);
  assert.equal(marker.value, 'monkey ', 'deletes correctly from high surrogate');
});

const {module: module$g, test: test$g} = Helpers;

let builder$5;
module$g('Unit: Markup Section', {
  beforeEach() {
    builder$5 = new PostNodeBuilder();
  },
  afterEach() {
    builder$5 = null;
  }
});

test$g('a section can append a marker', (assert) => {
  const s1 = builder$5.createMarkupSection('P');
  const m1 = builder$5.createMarker('hello');

  s1.markers.append(m1);
  assert.equal(s1.markers.length, 1);
});

VALID_ATTRIBUTES$3.forEach(attribute => {
  // eslint-disable-next-line no-loop-func
  test$g(`a section can have attribute "${attribute.key}" with value "${attribute.value}`, (assert) => {
    const s1 = builder$5.createMarkupSection('P', [], false, { [attribute.key]: attribute.value });
    assert.deepEqual(
      s1.attributes,
      { [attribute.key]: attribute.value },
      'Attribute set at instantiation'
    );
  });
});

INVALID_ATTRIBUTES.forEach(attribute => {
  // eslint-disable-next-line no-loop-func
  test$g(`a section throws when invalid attribute "${attribute.key}" is passed to a marker`, (assert) => {
    assert.throws(() => {
      builder$5.createMarkupSection('P', [], false, attribute);
    });
  });
});

test$g('#isBlank returns true if the text length is zero for two markers', (assert) => {
  const m1 = builder$5.createMarker('');
  const m2 = builder$5.createMarker('');
  const s = builder$5.createMarkupSection('p', [m1,m2]);
  assert.ok(s.isBlank, 'section with two blank markers is blank');
});

test$g('#isBlank returns true if there are no markers', (assert) => {
  const s = builder$5.createMarkupSection('p');
  assert.ok(s.isBlank, 'section with no markers is blank');
});

test$g('#isBlank returns false if there is a marker with length', (assert) => {
  const m = builder$5.createMarker('a');
  const s = builder$5.createMarkupSection('p', [m]);
  assert.ok(!s.isBlank, 'section with marker is not blank');
});

test$g('#markersFor clones markers', (assert) => {
  const m = builder$5.createMarker('a');
  const s = builder$5.createMarkupSection('p', [m]);
  const clones = s.markersFor(0, 1);
  assert.equal(clones.length, 1, 'correct number of clones are created');
  assert.ok(clones[0] !== m, 'marker is cloned');
  assert.equal(clones[0].value, m.value, 'marker content is the same');
});

test$g('#markersFor clones markers, trimming at tailOffset', (assert) => {
  const m1 = builder$5.createMarker('ab');
  const m2 = builder$5.createMarker('cd');
  const s = builder$5.createMarkupSection('p', [m1, m2]);
  const clones = s.markersFor(0, 3);
  assert.equal(clones.length, 2, 'correct number of clones are created');
  assert.equal(clones[0].value, 'ab', 'marker content correct');
  assert.equal(clones[1].value, 'c', 'marker content is correct');
});

test$g('#markersFor clones markers, trimming at headOffset', (assert) => {
  const m1 = builder$5.createMarker('ab');
  const m2 = builder$5.createMarker('cd');
  const s = builder$5.createMarkupSection('p', [m1, m2]);
  const clones = s.markersFor(1, 4);
  assert.equal(clones.length, 2, 'correct number of clones are created');
  assert.equal(clones[0].value, 'b', 'marker content correct');
  assert.equal(clones[1].value, 'cd', 'marker content is correct');
});

test$g('#markersFor clones markers, trimming at offsets that do not trim', (assert) => {
  const m1 = builder$5.createMarker('ab');
  const m2 = builder$5.createMarker('cd');
  const m3 = builder$5.createMarker('ef');
  const s = builder$5.createMarkupSection('p', [m1, m2, m3]);
  const clones = s.markersFor(2, 4);
  assert.equal(clones.length, 1, 'correct number of clones are created');
  assert.equal(clones[0].value, 'cd', 'marker content correct');
});

test$g('#markersFor clones markers when offset completely surrounds a marker', (assert) => {
  const m1 = builder$5.createMarker('ab');  // 0-2
  const m2 = builder$5.createMarker('cd1'); // 2-5
  const m3 = builder$5.createMarker('cd2'); // 5-8
  const m4 = builder$5.createMarker('ef');  // 8-10
  const s = builder$5.createMarkupSection('p', [m1, m2, m3, m4]);
  const clones = s.markersFor(3, 9);
  assert.equal(clones.length, 3, 'correct number of clones are created');
  assert.equal(clones[0].value, 'd1', 'marker content correct');
  assert.equal(clones[1].value, 'cd2', 'marker content correct');
  assert.equal(clones[2].value, 'e', 'marker content correct');
});

test$g('#markersFor clones a single marker with a tail offset', (assert) => {
  const m1 = builder$5.createMarker(' def');
  const s = builder$5.createMarkupSection('p', [m1]);
  const clones = s.markersFor(0,1);
  assert.equal(clones.length, 1);
  assert.equal(clones[0].value, ' ');
});

test$g('instantiating with invalid tagName throws', (assert) => {
  assert.throws(() => {
    builder$5.createMarkupSection('blah');
  }, /Cannot set.*tagName.*blah/);
});

test$g('markerBeforeOffset returns marker the ends at offset', (assert) => {
  let marker = builder$5.createMarker;
  let section = builder$5.createMarkupSection('p', [
    marker('a'), marker('bc'), marker('def')
  ]);

  assert.ok(section.markerBeforeOffset(1) === section.markers.head);
  assert.ok(section.markerBeforeOffset(3) === section.markers.objectAt(1));
  assert.ok(section.markerBeforeOffset(6) === section.markers.tail);
});

test$g('markerBeforeOffset throws if offset is not between markers', (assert) => {
  let marker = builder$5.createMarker;
  let section = builder$5.createMarkupSection('p', [
    marker('a'), marker('bc'), marker('def')
  ]);

  assert.throws(
    () => section.markerBeforeOffset(0),
    /not between/
  );
  assert.throws(
    () => section.markerBeforeOffset(2),
    /not between/
  );
  assert.throws(
    () => section.markerBeforeOffset(4),
    /not between/
  );
  assert.throws(
    () => section.markerBeforeOffset(5),
    /not between/
  );
});

test$g('markerBeforeOffset returns first marker if it is empty and offset is 0', (assert) => {
  let marker = (text) => builder$5.createMarker(text);
  let section = builder$5.createMarkupSection('p', [
    marker(''), marker('bc'), marker('def')
  ]);

  assert.ok(section.markerBeforeOffset(0) === section.markers.head);
});

test$g('splitMarkerAtOffset inserts empty marker when offset is 0', (assert) => {
  let section = builder$5.createMarkupSection('p', [builder$5.createMarker('abc')]);

  section.splitMarkerAtOffset(0);

  assert.equal(section.markers.length, 2);
  assert.deepEqual(section.markers.map(m => m.value), ['', 'abc']);
});

test$g('splitMarkerAtOffset inserts empty marker if section is blank', (assert) => {
  let section = builder$5.createMarkupSection('p');

  section.splitMarkerAtOffset(0);

  assert.equal(section.markers.length, 1);
  assert.deepEqual(section.markers.map(m => m.value), ['']);
});

test$g('splitMarkerAtOffset splits marker if offset is contained by marker', (assert) => {
  let section = builder$5.createMarkupSection('p', [builder$5.createMarker('abc')]);

  section.splitMarkerAtOffset(1);

  assert.equal(section.markers.length, 2);
  assert.deepEqual(section.markers.map(m => m.value),
                   ['a', 'bc']);
});

test$g('splitMarkerAtOffset is no-op when offset is at end of marker', (assert) => {
  let section = builder$5.createMarkupSection('p', [builder$5.createMarker('abc')]);

  section.splitMarkerAtOffset(3);

  assert.equal(section.markers.length, 1);
  assert.deepEqual(section.markers.map(m => m.value), ['abc']);
});

test$g('splitMarkerAtOffset does nothing if the is offset is at end', (assert) => {
  let marker = (text) => builder$5.createMarker(text);
  let section = builder$5.createMarkupSection('p', [marker('a'), marker('bc')]);

  section.splitMarkerAtOffset(3);

  assert.equal(section.markers.length, 2);
  assert.deepEqual(section.markers.map(m => m.value), ['a', 'bc']);
});

test$g('splitMarkerAtOffset splits a marker deep in the middle', (assert) => {
  let marker = (text) => builder$5.createMarker(text);
  let section = builder$5.createMarkupSection('p', [
    marker('a'), marker('bc'), marker('def'), marker('ghi')
  ]);

  section.splitMarkerAtOffset(5);

  assert.equal(section.markers.length, 5);
  assert.deepEqual(section.markers.map(m => m.value),
                   ['a', 'bc', 'de', 'f', 'ghi']);
});

test$g('a section has property `isSection`', (assert) => {
  let section = builder$5.createMarkupSection();
  assert.ok(section.isSection, 'section.isSection');
});

test$g('#length is correct', (assert) => {
  let expectations;
  Helpers.postAbstract.build(({markupSection, marker, atom}) => {
    expectations = [{
      name: 'blank section',
      length: 0,
      section: markupSection()
    }, {
      name: 'section with empty marker',
      length: 0,
      section: markupSection('p', [marker('')])
    }, {
      name: 'section with single marker',
      length: 'abc'.length,
      section: markupSection('p', [marker('abc')])
    }, {
      name: 'section with multiple markers',
      length: 'abc'.length + 'defg'.length,
      section: markupSection('p', [marker('abc'),marker('defg')])
    }, {
      name: 'section with atom',
      length: 1,
      section: markupSection('p', [atom('mention', 'bob')])
    }, {
      name: 'section with multiple atoms',
      length: 2,
      section: markupSection('p', [atom('mention', 'bob'), atom('mention','other')])
    }, {
      name: 'section with atom and markers',
      length: 'abc'.length + 1,
      section: markupSection('p', [marker('abc'), atom('mention', 'bob')])
    }];
  });

  assert.expect(expectations.length);
  expectations.forEach(({name, length, section}) => {
    assert.equal(section.length, length, `${name} has correct length`);
  });
});

test$g('#textUntil is correct', (assert) => {
  let expectations;

  Helpers.postAbstract.build(({markupSection, marker, atom}) => {
    expectations = [{
      name: 'blank section',
      text: '',
      section: markupSection(),
      offset: 0
    }, {
      name: 'section with empty marker',
      text: '',
      section: markupSection('p', [marker('')]),
      offset: 0
    }, {
      name: 'section with single marker end',
      text: 'abc',
      section: markupSection('p', [marker('abc')]),
      offset: 'abc'.length
    }, {
      name: 'section with single marker middle',
      text: 'ab',
      section: markupSection('p', [marker('abc')]),
      offset: 'ab'.length
    }, {
      name: 'section with single marker start',
      text: '',
      section: markupSection('p', [marker('abc')]),
      offset: 0
    }, {
      name: 'section with multiple markers end',
      text: 'abcdefg',
      section: markupSection('p', [marker('abc'),marker('defg')]),
      offset: 'abc'.length + 'defg'.length
    }, {
      name: 'section with multiple markers middle',
      text: 'abcde',
      section: markupSection('p', [marker('abc'),marker('defg')]),
      offset: 'abc'.length + 'de'.length
    }, {
      name: 'section with atom has no text for atom',
      text: '',
      section: markupSection('p', [atom('mention', 'bob')]),
      offset: 1
    }, {
      name: 'section with multiple atoms has no text for atoms',
      text: '',
      section: markupSection('p', [atom('mention', 'bob'), atom('mention','other')]),
      offset: 2
    }, {
      name: 'section with atom and markers has text for markers only',
      text: 'abc',
      section: markupSection('p', [marker('abc'), atom('mention', 'bob')]),
      offset: 'abc'.length + 1
    }];
  });

  assert.expect(expectations.length);
  expectations.forEach(({name, text, section, offset}) => {
    assert.equal(text, section.textUntil(new Position$1(section, offset)), name);
  });
});

const {module: module$h, test: test$h} = Helpers;

module$h('Unit: PostNodeBuilder');

test$h('#createMarkup returns singleton markup', (assert) => {
  const builder = new PostNodeBuilder();
  const m1 = builder.createMarkup('strong');
  const m2 = builder.createMarkup('strong');

  assert.ok(m1 === m2, 'markups are singletons');
});

test$h('#createMarkup returns singleton markup when has equal attributes', (assert) => {
  const builder = new PostNodeBuilder();
  const m1 = builder.createMarkup('a', {href:'bustle.com'});
  const m2 = builder.createMarkup('a', {href:'bustle.com'});

  assert.ok(m1 === m2, 'markups with attributes are singletons');
});

test$h('#createMarkup returns differents markups when has different attributes', (assert) => {
  const builder = new PostNodeBuilder();
  const m1 = builder.createMarkup('a', {href:'bustle.com'});
  const m2 = builder.createMarkup('a', {href:'other.com'});

  assert.ok(m1 !== m2, 'markups with different attributes are different');
});

test$h('#createMarkup normalizes tagName', (assert) => {
  const builder = new PostNodeBuilder();
  const m1 = builder.createMarkup('b');
  const m2 = builder.createMarkup('B');
  const m3 = builder.createMarkup('b', {});
  const m4 = builder.createMarkup('B', {});

  assert.ok(m1 === m2 &&
            m2 === m3 &&
            m3 === m4, 'all markups are the same');
});

test$h('#createCardSection creates card with builder', (assert) => {
  const builder = new PostNodeBuilder();
  const cardSection = builder.createCardSection('test-card');
  assert.ok(cardSection.builder === builder, 'card section has builder');
});

const {module: module$i, test: test$i} = Helpers;

module$i('Unit: Post');

test$i('#walkMarkerableSections finds no section when range contains only a card', (assert) => {
  const post = Helpers.postAbstract.build(builder => {
    const {post, cardSection} = builder;

    return post([cardSection('simple-card')]);
  });

  let foundSections = [];

  const card = post.sections.objectAt(0);
  const range = Range.create(card, 0, card, 0);

  post.walkMarkerableSections(range, s => foundSections.push(s));
  assert.equal(foundSections.length, 0, 'found no markerable sections');
});

test$i('#walkMarkerableSections skips non-markerable sections', (assert) => {
  const post = Helpers.postAbstract.build(builder => {
    const {post, markupSection, marker, cardSection} = builder;

    return post([
      markupSection('p', ['s1m1'].map(t => marker(t))),
      markupSection('p', ['s2m1'].map(t => marker(t))),
      cardSection('simple-card'),
      markupSection('p', ['s3m1'].map(t => marker(t))),
      markupSection('p', ['s4m1'].map(t => marker(t)))
    ]);
  });

  let foundSections = [];

  const s1 = post.sections.objectAt(0);
  const s4 = post.sections.objectAt(4);

  assert.equal(s1.text, 's1m1', 'precond - find s1');
  assert.equal(s4.text, 's4m1', 'precond - find s4');

  const range = Range.create(s1, 0, s4, 0);

  post.walkMarkerableSections(range, s => foundSections.push(s));

  assert.deepEqual(foundSections.map(s => s.text),
                   ['s1m1', 's2m1', 's3m1', 's4m1'],
                   'iterates correct sections');

});

test$i('#walkAllLeafSections returns markup section that follows a list section', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker, listSection, listItem}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('def')]),
      listSection('ul', [
        listItem([marker('123')])
      ]),
      markupSection('p')
    ]);
  });

  let sections = [];
  post.walkAllLeafSections(s => sections.push(s));

  assert.equal(sections.length, 4);
  assert.ok(sections[0] === post.sections.head, 'section 0');
  assert.ok(sections[1] === post.sections.objectAt(1), 'section 1');
  assert.ok(sections[2] === post.sections.objectAt(2).items.head, 'section 2');
  assert.ok(sections[3] === post.sections.tail, 'section 3');
});

test$i('#markupsInRange returns all markups when range is not collapsed', (assert) => {
  let b, i, a1, a2, found, collapsedRange;
  const post = Helpers.postAbstract.build(builder => {
    const {post, markupSection, cardSection, marker, markup} = builder;

    b  = markup('strong');
    i  = markup('em');
    a1 = markup('a', {href:'example.com'});
    a2 = markup('a', {href:'other-example.com'});

    return post([
      markupSection('p', [
        marker('plain text'),
        marker('bold text', [b]),
        marker('i text', [i]),
        marker('bold+i text', [b, i])
      ]),
      markupSection('p', [
        marker('link 1', [a1])
      ]),
      cardSection('simple-card'),
      markupSection('p', [
        marker('link 2', [a2])
      ])
    ]);
  });

  const [s1, s2,, s3] = post.sections.toArray();

  assert.equal(s1.text, 'plain textbold texti textbold+i text', 'precond s1');
  assert.equal(s2.text, 'link 1', 'precond s2');
  assert.equal(s3.text, 'link 2', 'precond s3');

  collapsedRange = Range.create(s1, 0);
  assert.equal(post.markupsInRange(collapsedRange).length, 0,
               'no markups in collapsed range at start');

  collapsedRange = Range.create(s1, 'plain text'.length);
  assert.equal(post.markupsInRange(collapsedRange).length, 0,
               'no markups in collapsed range at end of plain text');

  collapsedRange = Range.create(s1, 'plain textbold'.length);
  found = post.markupsInRange(collapsedRange);
  assert.equal(found.length, 1, 'markup in collapsed range in bold text');
  assert.inArray(b, found, 'finds b in bold text');

  collapsedRange = Range.create(s1, 'plain textbold text'.length);
  found = post.markupsInRange(collapsedRange);
  assert.equal(found.length, 1, 'markup in collapsed range at end of bold text');
  assert.inArray(b, found, 'finds b at end of bold text');

  const simpleRange = Range.create(s1, 0, s1, 'plain text'.length);
  assert.equal(post.markupsInRange(simpleRange).length, 0,
               'no markups in simple range');

  const singleMarkerRange = Range.create(s1, 'plain textb'.length,
                                      s1, 'plain textbold'.length);
  found = post.markupsInRange(singleMarkerRange);
  assert.equal(found.length, 1, 'finds markup in marker');
  assert.inArray(b, found, 'finds b');

  const singleSectionRange = Range.create(s1, 0, s1, s1.length);
  found = post.markupsInRange(singleSectionRange);
  assert.equal(found.length, 2, 'finds both markups in section');
  assert.inArray(b, found, 'finds b');
  assert.inArray(i, found, 'finds i');

  const multiSectionRange = Range.create(s1, 'plain textbold te'.length,
                                      s2, 'link'.length);
  found = post.markupsInRange(multiSectionRange);
  assert.equal(found.length, 3, 'finds all markups in multi-section range');
  assert.inArray(b, found, 'finds b');
  assert.inArray(i, found, 'finds i');
  assert.inArray(a1, found, 'finds a1');

  const rangeSpanningCard = Range.create(s1, 0, s3, 'link'.length);
  found = post.markupsInRange(rangeSpanningCard);
  assert.equal(found.length, 4, 'finds all markups in spanning section range');
  assert.inArray(b, found, 'finds b');
  assert.inArray(i, found, 'finds i');
  assert.inArray(a1, found, 'finds a1');
  assert.inArray(a2, found, 'finds a2');
});

test$i('#markupsInRange obeys left- and right-inclusive rules for "A" markups', (assert) => {
  let a;
  let post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    a = markup('a', {href: 'example.com'});
    return post([markupSection('p', [
      marker('123', [a]),
      marker(' abc '),
      marker('def', [a]),
      marker(' ghi '),
      marker('jkl', [a])
    ])]);
  });

  let section = post.sections.head;
  let start = Range.create(section, 0);
  let left = Range.create(section, '123 abc '.length);
  let inside = Range.create(section, '123 abc d'.length);
  let right = Range.create(section, '123 abc def'.length);
  let end = Range.create(section, '123 abc def ghi jkl'.length);

  assert.deepEqual(post.markupsInRange(start), [], 'no markups at start');
  assert.deepEqual(post.markupsInRange(left), [], 'no markups at left');
  assert.deepEqual(post.markupsInRange(right), [], 'no markups at right');
  assert.deepEqual(post.markupsInRange(inside), [a], '"A" markup inside range');
  assert.deepEqual(post.markupsInRange(end), [], 'no markups at end');
});

test$i('#markersContainedByRange when range is single marker', (assert) => {
  let found;
  const post = Helpers.postAbstract.build(({post, marker, markupSection}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  const innerRange = Range.create(post.sections.head, 1, post.sections.head, 2);
  found = post.markersContainedByRange(innerRange);
  assert.equal(found.length, 0, '0 markers in innerRange');

  const outerRange = Range.create(post.sections.head, 0, post.sections.head, 3);
  found = post.markersContainedByRange(outerRange);
  assert.equal(found.length, 1, '1 marker in outerRange');
  assert.ok(found[0] === post.sections.head.markers.head, 'finds right marker');
});

test$i('#markersContainedByRange when range is single section', (assert) => {
  let found;
  const post = Helpers.postAbstract.build(({post, marker, markupSection}) => {
    return post([markupSection('p', [
      marker('abc'), marker('def'), marker('ghi')
    ])]);
  });

  const section = post.sections.head;

  const innerRange = Range.create(section, 2, section, 4);
  found = post.markersContainedByRange(innerRange);
  assert.equal(found.length, 0, '0 markers in innerRange');

  const middleRange = Range.create(section, 2, section, 7);
  found = post.markersContainedByRange(middleRange);
  assert.equal(found.length, 1, '1 markers in middleRange');
  assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');

  const middleRangeLeftFencepost = Range.create(section, 3, section, 7);
  found = post.markersContainedByRange(middleRangeLeftFencepost);
  assert.equal(found.length, 1, '1 markers in middleRangeLeftFencepost');
  assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');

  const middleRangeRightFencepost = Range.create(section, 2, section, 6);
  found = post.markersContainedByRange(middleRangeRightFencepost);
  assert.equal(found.length, 1, '1 markers in middleRangeRightFencepost');
  assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');

  const middleRangeBothFencepost = Range.create(section, 3, section, 6);
  found = post.markersContainedByRange(middleRangeBothFencepost);
  assert.equal(found.length, 1, '1 markers in middleRangeBothFencepost');
  assert.ok(found[0] === section.markers.objectAt(1), 'finds right marker');

  const outerRange = Range.create(section, 0, section, section.length);
  found = post.markersContainedByRange(outerRange);
  assert.equal(found.length, section.markers.length, 'all markers in outerRange');
});

test$i('#markersContainedByRange when range is contiguous sections', (assert) => {
  let found;
  const post = Helpers.postAbstract.build(({post, marker, markupSection}) => {
    return post([
      markupSection('p', [marker('abc'), marker('def'), marker('ghi')]),
      markupSection('p', [marker('123'), marker('456'), marker('789')])
    ]);
  });

  const headSection = post.sections.head, tailSection = post.sections.tail;

  const innerRange = Range.create(headSection, 7, tailSection, 2);
  found = post.markersContainedByRange(innerRange);
  assert.equal(found.length, 0, '0 markers in innerRange');

  const middleRange = Range.create(headSection, 5, tailSection, 4);
  found = post.markersContainedByRange(middleRange);
  assert.equal(found.length, 2, '2 markers in middleRange');
  assert.ok(found[0] === headSection.markers.objectAt(2), 'finds right head marker');
  assert.ok(found[1] === tailSection.markers.objectAt(0), 'finds right tail marker');

  const middleRangeLeftFencepost = Range.create(headSection, 6, tailSection, 2);
  found = post.markersContainedByRange(middleRangeLeftFencepost);
  assert.equal(found.length, 1, '1 markers in middleRangeLeftFencepost');
  assert.ok(found[0] === headSection.markers.objectAt(2), 'finds right head marker');

  const middleRangeRightFencepost = Range.create(headSection, 7, tailSection, 3);
  found = post.markersContainedByRange(middleRangeRightFencepost);
  assert.equal(found.length, 1, '1 markers in middleRangeRightFencepost');
  assert.ok(found[0] === tailSection.markers.objectAt(0), 'finds right marker');

  const middleRangeBothFencepost = Range.create(headSection, 6, tailSection, 3);
  found = post.markersContainedByRange(middleRangeBothFencepost);
  assert.equal(found.length, 2, '2 markers in middleRangeBothFencepost');
  assert.ok(found[0] === headSection.markers.objectAt(2), 'finds right head marker');
  assert.ok(found[1] === tailSection.markers.objectAt(0), 'finds right tail marker');

  const outerRange = Range.create(headSection, 0, tailSection, tailSection.length);
  found = post.markersContainedByRange(outerRange);
  assert.equal(found.length,
               headSection.markers.length + tailSection.markers.length,
               'all markers in outerRange');
});

test$i('#isBlank is true when there are no sections', (assert) => {
  let _post, _section;
  Helpers.postAbstract.build(({post, markupSection}) => {
    _post = post();
    _section = markupSection();
  });
  assert.ok(_post.isBlank);
  _post.sections.append(_section);
  assert.ok(!_post.isBlank);
});

test$i('#trimTo creates a post from the given range', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  const section = post.sections.head;
  const range = Range.create(section,1,section,2); // "b"

  post = post.trimTo(range);
  let expected = Helpers.postAbstract.build(({post, marker, markupSection}) => {
    return post([markupSection('p',[marker('b')])]);
  });

  assert.postIsSimilar(post, expected);
});

test$i('#trimTo copies card sections', (assert) => {
  let cardPayload = {foo: 'bar'};

  let buildPost = Helpers.postAbstract.build;

  let post = buildPost(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      markupSection('p', [marker('abc')]),
      cardSection('test-card', cardPayload),
      markupSection('p', [marker('123')])
    ]);
  });

  const range = Range.create(post.sections.head, 1,  // 'b'
                             post.sections.tail, 1); // '2'

  post = post.trimTo(range);
  let expected = buildPost(
    ({post, marker, markupSection, cardSection}) => {
    return post([
      markupSection('p',[marker('bc')]),
      cardSection('test-card', {foo: 'bar'}),
      markupSection('p',[marker('1')])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$i('#trimTo when range starts and ends in a list item', (assert) => {
  let buildPost = Helpers.postAbstract.build;

  let post = buildPost(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [listItem([marker('abc')])])]);
  });

  let range = Range.create(post.sections.head.items.head, 0,
                           post.sections.head.items.head, 'ab'.length);

  post = post.trimTo(range);
  let expected = buildPost(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [listItem([marker('ab')])])]);
  });

  assert.postIsSimilar(post, expected);
});

test$i('#trimTo when range contains multiple list items', (assert) => {
  let buildPost = Helpers.postAbstract.build;

  let post = buildPost(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ])]);
  });

  let range = Range.create(post.sections.head.items.head, 'ab'.length,
                           post.sections.head.items.tail, 'gh'.length);

  post = post.trimTo(range);
  let expected = buildPost(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('c')]),
      listItem([marker('def')]),
      listItem([marker('gh')])
    ])]);
  });

  assert.postIsSimilar(post, expected);
});

test$i('#trimTo when range contains multiple list items and more sections', (assert) => {
  let buildPost = Helpers.postAbstract.build;

  let post = buildPost(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([listSection('ul', [
      listItem([marker('abc')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ]), markupSection('p', [
      marker('123')
    ])]);
  });

  let range = Range.create(post.sections.head.items.head, 'ab'.length,
                           post.sections.tail, '12'.length);

  post = post.trimTo(range);
  let expected = buildPost(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([listSection('ul', [
      listItem([marker('c')]),
      listItem([marker('def')]),
      listItem([marker('ghi')])
    ]), markupSection('p', [
      marker('12')
    ])]);
  });

  assert.postIsSimilar(post, expected);
});

test$i('#headPosition and #tailPosition returns head and tail', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);
  });

  let head = post.headPosition();
  let tail = post.tailPosition();

  assert.positionIsEqual(head, post.sections.head.headPosition(), 'head pos');
  assert.positionIsEqual(tail, post.sections.tail.tailPosition(), 'tail pos');
});

test$i('#headPosition and #tailPosition when post is blank return blank', (assert) => {
  let post = Helpers.postAbstract.build(({post}) => {
    return post();
  });

  let head = post.headPosition();
  let tail = post.tailPosition();

  assert.positionIsEqual(head, Position$1.blankPosition(), 'head pos');
  assert.positionIsEqual(tail, Position$1.blankPosition(), 'tail pos');
});

test$i('#hasContent gives correct value', (assert) => {
  let expectations = Helpers.postAbstract.build(({post, markupSection, imageSection, marker}) => {
    return {
      hasNoContent: [{
        message: 'no sections',
        post: post()
      }, {
        message: '1 blank section',
        post: post([markupSection('p')])
      }, {
        message: '1 section with blank marker',
        post: post([markupSection('p', [marker('')])])
      }],
      hasContent: [{
        message: '1 section with non-blank marker',
        post: post([markupSection('p', [marker('text')])])
      }, {
        message: '2 sections',
        post: post([markupSection('p'), markupSection('p')])
      }, {
        message: 'image section',
        post: post([imageSection()])
      }]
    };
  });

  expectations.hasNoContent.forEach(({message, post}) => {
    assert.ok(!post.hasContent, message + ' !hasContent');
  });
  expectations.hasContent.forEach(({message, post}) => {
    assert.ok(post.hasContent, message + ' hasContent');
  });
});

const {module: module$j, test: test$j} = Helpers;
const { postAbstract: { buildFromText: buildFromText$4 } } = Helpers;
const ZWNJ$1 = '\u200c';

let editorElement$7, builder$6, parser, editor$7;
let editorOpts;
let buildDOM = Helpers.dom.fromHTML;

let mentionAtom = {
  name: 'mention',
  type: 'dom',
  render({value}) {
    let element = document.createElement('span');
    element.setAttribute('id', 'mention-atom');
    element.appendChild(document.createTextNode(value));
    return element;
  }
};

module$j('Unit: Parser: DOMParser', {
  beforeEach() {
    editorElement$7 = $('#editor')[0];
    builder$6 = new PostNodeBuilder();
    parser = new DOMParser(builder$6);
    editorOpts = { element: editorElement$7, atoms: [mentionAtom] };
  },
  afterEach() {
    builder$6 = null;
    parser = null;
    if (editor$7) {
      editor$7.destroy();
      editor$7 = null;
    }
  }
});

let expectations = [
  ['<p>some text</p>', ['some text']],
  ['<p>some text</p><p>some other text</p>', ['some text','some other text']],
  ['<p>some &nbsp;text &nbsp;&nbsp;for &nbsp; &nbsp;you</p>', ['some  text   for    you']],
  ['<p>a\u2003b</p>', [`a${TAB}b`]],

  // multiple ps, with and without adjacent text nodes
  ['<p>first line</p>\n<p>second line</p>', ['first line','second line']],
  ['<p>first line</p>middle line<p>third line</p>', ['first line','middle line','third line']],
  ['<p>first line</p>second line', ['first line','second line']],
  ['<p>first line</p><p></p><p>third line</p>', ['first line', 'third line']],

  ['<b>bold text</b>',['*bold text*']],

  // unrecognized tags
  ['<p>before<span>span</span>after</p>',['beforespanafter']],
  ['<p><span><span>inner</span></span></p>', ['inner']],

  //  unrecognized attribute
  ['<p><span style="font-color:red;">was red</span></p>', ['was red']],

  // list elements
  ['<ul><li>first element</li><li>second element</li></ul>', ['* first element', '* second element']],

  // nested list elements
  ['<ul><li>first element</li><li><ul><li>nested element</li></ul></li></ul>', ['* first element', '* nested element']],

  // See https://github.com/bustle/mobiledoc-kit/issues/333
  ['abc\ndef', ['abc def']],
];

let structures = [
  // See https://github.com/bustle/mobiledoc-kit/issues/648
  ['<section><p>first</p><p>second</p></section>', ['first','second'], 'one level'],
  ['<section><div><p>first</p><p>second</p></div></section>', ['first', 'second'], 'two levels'],
  ['<section><div><div><p>first</p><p>second</p></div></div></section>', ['first', 'second'], 'three levels'],
  ['<section><div><p>first</p></div><p>second</p></section>', ['first', 'second'], 'offset left'],
  ['<section><p>first</p><div><p>second</p></div></section>', ['first', 'second'], 'offset right']
];

expectations.forEach(([html, dslText]) => {
  test$j(`#parse ${html} -> ${dslText}`, (assert) => {
    let post = parser.parse(buildDOM(html));
    let { post: expected } = buildFromText$4(dslText);

    assert.postIsSimilar(post, expected);
  });
});

structures.forEach(([html, dslText, name]) => {
  test$j(`wrapped#parse ${html} -> ${dslText} (${name})`, (assert) => {
    let post = parser.parse(buildDOM(html));
    let { post: expected } = buildFromText$4(dslText);

    assert.postIsSimilar(post, expected);
  });
});

test$j('editor#parse fixes text in atom headTextNode when atom is at start of section', (assert) => {
  let done = assert.async();
  let {post: expected} = buildFromText$4(['X@("name": "mention", "value": "bob")']);
  editor$7 = Helpers.editor.buildFromText('@("name": "mention", "value": "bob")', editorOpts);

  let headTextNode = editor$7.post.sections.head.markers.head.renderNode.headTextNode;
  assert.ok(!!headTextNode, 'precond - headTextNode');
  headTextNode.textContent = ZWNJ$1 + 'X';

  Helpers.wait(() => { // wait for mutation
    assert.postIsSimilar(editor$7.post, expected);
    assert.renderTreeIsEqual(editor$7._renderTree, expected);

    done();
  });
});

test$j('editor#parse fixes text in atom headTextNode when atom has atom before it', (assert) => {
  let done = assert.async();
  let {post: expected} = buildFromText$4('@("name": "mention", "value": "first")X@("name": "mention", "value": "last")');
  editor$7 = Helpers.editor.buildFromText('@("name": "mention", "value": "first")@("name": "mention", "value": "last")', editorOpts);

  let headTextNode = editor$7.post.sections.head.markers.tail.renderNode.headTextNode;
  assert.ok(!!headTextNode, 'precond - headTextNode');
  headTextNode.textContent = ZWNJ$1 + 'X';

  Helpers.wait(() => {
    assert.postIsSimilar(editor$7.post, expected);
    assert.renderTreeIsEqual(editor$7._renderTree, expected);
    done();
  });
});

test$j('editor#parse fixes text in atom headTextNode when atom has marker before it', (assert) => {
  let done = assert.async();
  let {post: expected} = buildFromText$4('textX@("name":"mention","value":"bob")');
  editor$7 = Helpers.editor.buildFromText('text@("name":"mention","value":"bob")', editorOpts);

  let headTextNode = editor$7.post.sections.head.markers.objectAt(1).renderNode.headTextNode;
  assert.ok(!!headTextNode, 'precond - headTextNode');
  headTextNode.textContent = ZWNJ$1 + 'X';

  Helpers.wait(() => {
    assert.postIsSimilar(editor$7.post, expected);
    assert.renderTreeIsEqual(editor$7._renderTree, expected);
    done();
  });
});

test$j('editor#parse fixes text in atom tailTextNode when atom is at end of section', (assert) => {
  let done = assert.async();
  let {post: expected} = buildFromText$4('@("name":"mention","value":"bob")X');
  editor$7 = Helpers.editor.buildFromText('@("name":"mention","value":"bob")', editorOpts);

  let tailTextNode = editor$7.post.sections.head.markers.head.renderNode.tailTextNode;
  assert.ok(!!tailTextNode, 'precond - tailTextNode');
  tailTextNode.textContent = ZWNJ$1 + 'X';

  Helpers.wait(() => {
    assert.postIsSimilar(editor$7.post, expected);
    assert.renderTreeIsEqual(editor$7._renderTree, expected);
    done();
  });
});

test$j('editor#parse fixes text in atom tailTextNode when atom has atom after it', (assert) => {
  let done = assert.async();
  let {post: expected} = buildFromText$4('@("name":"mention","value":"first")X@("name":"mention","value":"last")');
  editor$7 = Helpers.editor.buildFromText('@("name":"mention","value":"first")@("name":"mention","value":"last")',
                                        editorOpts);

  let tailTextNode = editor$7.post.sections.head.markers.head.renderNode.tailTextNode;
  assert.ok(!!tailTextNode, 'precond - tailTextNode');
  tailTextNode.textContent = ZWNJ$1 + 'X';

  Helpers.wait(() => {
    assert.postIsSimilar(editor$7.post, expected);
    assert.renderTreeIsEqual(editor$7._renderTree, expected);
    done();
  });
});

test$j('editor#parse fixes text in atom tailTextNode when atom has marker after it', (assert) => {
  let done = assert.async();
  let {post: expected} = buildFromText$4('@("name":"mention","value":"bob")Xabc');
  editor$7 = Helpers.editor.buildFromText('@("name":"mention","value":"bob")abc',
                                        editorOpts);

  let tailTextNode = editor$7.post.sections.head.markers.head.renderNode.tailTextNode;
  assert.ok(!!tailTextNode, 'precond - tailTextNode');
  tailTextNode.textContent = ZWNJ$1 + 'X';

  Helpers.wait(() => {
    assert.postIsSimilar(editor$7.post, expected);
    assert.renderTreeIsEqual(editor$7._renderTree, expected);
    done();
  });
});

test$j('parse empty content', (assert) => {
  let element = buildDOM('');
  const post = parser.parse(element);

  assert.ok(post.isBlank, 'post is blank');
});

test$j('plain text creates a section', (assert) => {
  let container = buildDOM('plain text');
  let element = container.firstChild;
  const post = parser.parse(element);
  let {post: expected} = buildFromText$4('plain text');

  assert.postIsSimilar(post, expected);
});

test$j('strong tag + em + text node creates section', (assert) => {
  let element = buildDOM('<b><em>stray</em> markup tags</b>');
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, 'parse 1 section');
  assert.equal(post.sections.objectAt(0).text, 'stray markup tags');

  let markers = post.sections.objectAt(0).markers.toArray();
  assert.equal(markers.length, 2, '2 markers');

  let [m1, m2] = markers;

  assert.equal(m1.value, 'stray');
  assert.equal(m2.value, ' markup tags');

  assert.ok(m1.hasMarkup('b'), 'm1 is b');
  assert.ok(m1.hasMarkup('em'), 'm1 is em');

  assert.ok(m2.hasMarkup('b'), 'm2 is b');
  assert.ok(!m2.hasMarkup('em'), 'm1 is not em');
});

test$j('wrapped strong tag + em + text node creates section', (assert) => {
  let element = buildDOM('<div><b><em>stray</em> markup tags</b></div>');
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, 'parse 1 section');
  assert.equal(post.sections.objectAt(0).text, 'stray markup tags');

  let markers = post.sections.objectAt(0).markers.toArray();
  assert.equal(markers.length, 2, '2 markers');

  let [m1, m2] = markers;

  assert.equal(m1.value, 'stray');
  assert.equal(m2.value, ' markup tags');

  assert.ok(m1.hasMarkup('b'), 'm1 is b');
  assert.ok(m1.hasMarkup('em'), 'm1 is em');

  assert.ok(m2.hasMarkup('b'), 'm2 is b');
  assert.ok(!m2.hasMarkup('em'), 'm1 is not em');
});

test$j('link (A tag) is parsed', (assert) => {
  let url = 'http://bustle.com',
      rel = 'nofollow';
  let element = buildDOM(`<a href="${url}" rel="${rel}">link</a>`);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');
  assert.equal(post.sections.objectAt(0).text, 'link');

  let markers = post.sections.objectAt(0).markers.toArray();
  assert.equal(markers.length, 1, '1 marker');
  let [marker] = markers;
  assert.equal(marker.value, 'link');
  assert.ok(marker.hasMarkup('a'), 'has A markup');

  let markup = marker.markups[0];
  assert.equal(markup.getAttribute('href'), url, 'has href attr');
  assert.equal(markup.getAttribute('rel'), rel, 'has rel attr');
});

test$j('span with font-style italic maps to em', (assert) => {
  let element = buildDOM(`<p><span style="font-style:ItaLic;">emph</span></p>`);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');

  let section = post.sections.objectAt(0);
  assert.equal(section.markers.length, 1, '1 marker');
  let marker = section.markers.objectAt(0);

  assert.equal(marker.value, 'emph');
  assert.ok(marker.hasMarkup('em'), 'marker is em');
});

test$j('span with font-weight 700 maps to strong', (assert) => {
  let element = buildDOM(`<p><span style="font-weight:700;">bold 700</span></p>`);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');

  let section = post.sections.objectAt(0);
  assert.equal(section.markers.length, 1, '1 marker');
  let marker = section.markers.objectAt(0);

  assert.equal(marker.value, 'bold 700');
  assert.ok(marker.hasMarkup('strong'), 'marker is strong');
});

test$j('span with font-weight "bold" maps to strong', (assert) => {
  let element = buildDOM(`<p><span style="font-weight:bold;">bold bold</span></p>`);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');

  let section = post.sections.objectAt(0);
  assert.equal(section.markers.length, 1, '1 marker');
  let marker = section.markers.objectAt(0);

  assert.equal(marker.value, 'bold bold');
  assert.ok(marker.hasMarkup('strong'), 'marker is strong');
});

let recognizedTags = ['aside', 'blockquote', 'h1','h2','h3','h4','h5','h6','p'];
recognizedTags.forEach(tag => {
  test$j(`recognized markup section tags are parsed (${tag})`, (assert) => {
    let element = buildDOM(`<${tag}>${tag} text</${tag}>`);
    const post = parser.parse(element);

    assert.equal(post.sections.length, 1, '1 section');
    assert.equal(post.sections.objectAt(0).text, `${tag} text`);
    assert.equal(post.sections.objectAt(0).tagName, tag);
  });
});

test$j('unrecognized attributes are ignored', (assert) => {
  let element = buildDOM(`
    <a href="http://bustle.com"
       style="text-decoration: none">not-underlined link</a>`
  );
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');
  assert.equal(post.sections.objectAt(0).text, 'not-underlined link');
  let marker = post.sections.objectAt(0).markers.objectAt(0);
  assert.equal(marker.value, 'not-underlined link');
  assert.ok(marker.hasMarkup('a'), 'has <a> markup');
  let markup = marker.getMarkup('a');
  assert.equal(markup.getAttribute('href'), 'http://bustle.com');
  assert.ok(!markup.getAttribute('style'), 'style attribute not included');
});

test$j('singly-nested ol lis are parsed correctly', (assert) => {
  let element= buildDOM(`
    <ol><li>first element</li><li>second element</li></ol>
  `);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');
  let section = post.sections.objectAt(0);
  assert.equal(section.tagName, 'ol');
  assert.equal(section.items.length, 2, '2 items');
  assert.equal(section.items.objectAt(0).text, 'first element');
  assert.equal(section.items.objectAt(1).text, 'second element');
});

test$j('nested html doesn\'t create unneccessary whitespace', (assert) => {
  let element = buildDOM(`
    <div>
      <p>
        One
      <p>
      <p>
        Two
      </p>
    </div>
  `);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 2, '2 sections');
  assert.equal(post.sections.objectAt(0).text, 'One');
  assert.equal(post.sections.objectAt(1).text, 'Two');
});

// Google docs nests uls like this
test$j('lis in nested uls are flattened (when ul is child of ul)', (assert) => {
  let element= buildDOM(`
    <ul>
      <li>outer</li>
      <ul><li>inner</li></ul>
    </ul>
  `);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');
  let section = post.sections.objectAt(0);
  assert.equal(section.tagName, 'ul');
  assert.equal(section.items.length, 2, '2 items');
  assert.equal(section.items.objectAt(0).text, 'outer');
  assert.equal(section.items.objectAt(1).text, 'inner');
});

test$j('#appendSection does not skip sections containing a single atom with no text value', (assert) => {
  let options = {
    plugins: [function (node, builder, {addMarkerable, nodeFinished}) {
      if (node.nodeType !== 1 || node.tagName !== 'BR') {
          return;
      }

      let softReturn = builder.createAtom('soft-return');
      addMarkerable(softReturn);

      nodeFinished();
    }]
  };
  parser = new DOMParser(builder$6, options);

  let element = buildDOM(`Testing<br>Atoms`);
  const post = parser.parse(element);

  assert.equal(post.sections.length, 1, '1 section');
  let section = post.sections.objectAt(0);
  assert.equal(section.tagName, 'p');
  assert.equal(section.markers.length, 3, '3 markers');
  assert.equal(section.markers.objectAt(0).value, 'Testing');
  assert.equal(section.markers.objectAt(1).name, 'soft-return');
  assert.equal(section.markers.objectAt(2).value, 'Atoms');
});

var GoogleDocs = {
  'simple paragraph as span': {
    expected: "<p>simple paragraph</p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-d75a90f6-8c07-deca-96cb-4b79c9ad7a7f"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">simple paragraph</span></b>`
  },
  'simple paragraph as span (Chrome - Windows)': {
    expected: "<p>simple paragraph</p>",
    raw: `<html><body><!--StartFragment--><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-af1f8f2c-cacc-6998-07a1-89da38d9c501"><span style="font-size:14.666666666666666px;font-family:Arial;color:#222222;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">simple paragraph</span></b><!--EndFragment--></body></html>`
  },

  // when selecting a line without including the end of the line, the html represention
  // includes a <span> or series of <span>s
  'paragraph with bold as span': {
    expected: "<p>paragraph with <strong>bold</strong></p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-d75a90f6-8c09-8dc9-fb2f-f7eb880e143d"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">paragraph with </span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">bold</span></b>`
  },
  'paragraph with bold as span (Chrome - Windows)': {
    expected: "<p>paragraph with <strong>bold</strong></p>",
    raw: `<html><body><!--StartFragment--><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-af1f8f2c-cacd-c884-b763-ee9510747969"><span style="font-size:14.666666666666666px;font-family:Arial;color:#222222;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">paragraph with </span><span style="font-size:14.666666666666666px;font-family:Arial;color:#222222;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">bold</span></b><!--EndFragment--></body></html>`
  },

  // when selecting a line that includes the end (using, e.g., shift+up to selection the entire line),
  // the html representation includes a <p> tag
  'paragraph with bold as p': {
    expected: "<p>A <strong>bold</strong> paragraph.<p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-e8f29cd6-9031-bb09-1958-dcc3dd34c237"><p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">A </span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">bold</span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;"> paragraph.</span></p></b><br class="Apple-interchange-newline">`
  },
  'paragraph with italic as span': {
    expected: "<p>paragraph with <em>italic</em></p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-d75a90f6-8c15-20cb-c8cd-59f592dc8402"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">paragraph with </span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">italic</span></b>`
  },
  'paragraph with bold + italic as p': {
    expected: "<p>And a second <strong>bold</strong> <em>italic</em> paragraph.",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-e8f29cd6-9038-f59a-421c-1c5303efdaf6"><p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">And a second </span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:700;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">bold</span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;"> </span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:italic;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">italic</span><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;"> paragraph.</span></p></b><br class="Apple-interchange-newline">`
  },
  '2 paragraphs as p': {
    expected: "<p>Paragraph 1</p><p>Paragraph 2</p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-d75a90f6-8c66-10b0-1c99-0210f64abe05"><p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">Paragraph 1</span></p><br><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">Paragraph 2</span></b>`
  },
  'h1 with h1 tag': {
    expected: "<h1>h1 text</h1>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-2f095724-903a-1280-b377-a2b08d38ffaa"><h1 dir="ltr" style="line-height:1.38;margin-top:20pt;margin-bottom:6pt;"><span style="font-size:26.666666666666664px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">h1 text</span></h1></b>`
  },
  'paragraph with link as span': {
    expected: "<p>link to <a href='http://bustle.com'>bustle</a></p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-e8f29cd6-903c-08a3-cc9c-7841d9aa3871"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">link to </span><a href="http://bustle.com" style="text-decoration:none;"><span style="font-size:14.666666666666666px;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;vertical-align:baseline;white-space:pre-wrap;">bustle</span></a></b>`
  },
  'paragraph with link as p': {
    expected: "<p>link to <a href='http://bustle.com'>bustle</a></p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-e8f29cd6-903b-12a4-6455-23c68a9eae95"><p dir="ltr" style="line-height:1.38;margin-top:0pt;margin-bottom:0pt;"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;">link to </span><a href="http://bustle.com" style="text-decoration:none;"><span style="font-size:14.666666666666666px;font-family:Arial;color:#1155cc;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:underline;vertical-align:baseline;white-space:pre-wrap;">bustle</span></a></p></b><br class="Apple-interchange-newline">`
  },
  'img in span': {
    expected: "<p><img src='https://placehold.it/100x100'></p>",
    raw: `<meta charset='utf-8'><meta charset="utf-8"><b style="font-weight:normal;" id="docs-internal-guid-7a3c9f90-a5c3-d3b6-425c-75b28c50bd7e"><span style="font-size:14.666666666666666px;font-family:Arial;color:#000000;background-color:transparent;font-weight:400;font-style:normal;font-variant:normal;text-decoration:none;vertical-align:baseline;white-space:pre-wrap;"><img src="https://placehold.it/100x100" width="500px;" height="374px;" style="border: none; transform: rotate(0.00rad); -webkit-transform: rotate(0.00rad);"/></span></b>`
  }
};

const {module: module$k, test: test$k} = Helpers;

function parseHTML$1(html, options={}) {
  let builder = new PostNodeBuilder();
  return new HTMLParser(builder, options).parse(html);
}

module$k('Unit: Parser: HTMLParser Google Docs');

function equalToExpected(assert, rawHTML, expectedHTML) {
  let raw = parseHTML$1(rawHTML),
      expected = parseHTML$1(expectedHTML);

  assert.equal(raw.sections.length, expected.sections.length,
               'matches section length');
  raw.sections.forEach((section, sectionIndex) => {
    let expectedSection = expected.sections.objectAt(sectionIndex);

    if (section.type === CARD_TYPE) {
      assert.equal(section.name, expectedSection.name,
                   `card section at index ${sectionIndex} has equal name`);

      assert.deepEqual(section.payload, expectedSection.payload,
                   `card section at index ${sectionIndex} has equal payload`);

      return;
    }

    assert.equal(section.markers.length, expectedSection.markers.length,
                 `section at index ${sectionIndex} has equal marker length`);
    assert.equal(section.text, expectedSection.text,
                 `section at index ${sectionIndex} has equal text`);
    assert.equal(section.tagName, expectedSection.tagName,
                 `section at index ${sectionIndex} has equal tagName`);

    section.markers.forEach((marker, markerIndex) => {
      let expectedMarker = expectedSection.markers.objectAt(markerIndex);

      assert.equal(
        marker.value,
        expectedMarker.value,
        `marker #${markerIndex} at section #${sectionIndex} matches value`
      );

      assert.equal(
        marker.markups.length,
        expectedMarker.markups.length,
        `marker #${markerIndex} at section #${sectionIndex} matches markups length`
      );

      forEach(expectedMarker.markups, expectedMarkup => {
        let markup = marker.getMarkup(expectedMarkup.tagName);
        assert.ok(markup, `has markup with tagName ${expectedMarkup.tagName}`);
        let attributes = expectedMarkup.attributes;
        forEach(Object.keys(attributes), key => {
          assert.equal(expectedMarkup.getAttribute(key),
                       markup.getAttribute(key),
                       `equal attribute value for ${key}`);
        });
      });
    });
  });
}

Object.keys(GoogleDocs).forEach(key => {
  test$k(key, (assert) => {
    let example = GoogleDocs[key];
    equalToExpected(assert, example.raw, example.expected);
  });
});

test$k('img in span can use a cardParser to turn img into image-card', function(assert) {
  let example = GoogleDocs['img in span'];
  let options = {
    plugins: [function(element, builder, {addSection}) {
      if (element.tagName === 'IMG') {
        let payload = {url: element.src};
        let cardSection = builder.createCardSection('image-card', payload);
        addSection(cardSection);
      }
    }]
  };
  let parsed = parseHTML$1(example.raw, options);

  let sections = parsed.sections.toArray();
  let found = false, payload;
  for (let i=0; i < sections.length; i++) {
    if (sections[i].name === 'image-card') {
      found = true;
      payload = sections[i].payload;
    }
  }
  assert.ok(found, 'found image-card');
  assert.ok(payload.url, 'has url in payload');
});

const {module: module$l, test: test$l} = Helpers;

let parser$1;

module$l('Unit: Parser: HTMLParser Google Sheets', {
  beforeEach() {
    const options = {};
    const builder = new PostNodeBuilder();
    parser$1 = new HTMLParser(builder, options);
  },
  afterEach() {
    parser$1 = null;
  }
});

// No formatting
test$l('#parse returns a markup section when given a cell without formatting', (assert) => {
  const text = `<meta http-equiv="content-type" content="text/html; charset=utf-8"><style type="text/css"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style="font-size:13px;font-family:Arial;" data-sheets-value="[null,2,&quot;Ways of climbing over the wall&quot;]" data-sheets-userformat="[null,null,513,[null,0],null,null,null,null,null,null,null,null,0]">Ways of climbing over the wall</span>`;
  const post = parser$1.parse(text);
  const expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('Ways of climbing over the wall')])]);
  });

  assert.postIsSimilar(post, expected);
});

// No formatting (Chrome - Windows)
test$l('#parse returns a markup section when given a cell without formatting (Chrome - Windows)', (assert) => {
  const text = `<html><body><!--StartFragment--><style type="text/css"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style="font-size:13px;font-family:Arial;" data-sheets-value="[null,2,&quot;Ways of climbing over the wall&quot;]" data-sheets-userformat="[null,null,513,[null,0],null,null,null,null,null,null,null,null,0]">Ways of climbing over the wall</span><!--EndFragment--></body></html>`;
  const post = parser$1.parse(text);
  const expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('Ways of climbing over the wall')])]);
  });

  assert.postIsSimilar(post, expected);
});

// Cell in bold
test$l('#parse returns a markup section with bold when given a cell in bold', (assert) => {
  const text = `<meta http-equiv="content-type" content="text/html; charset=utf-8"><style type="text/css"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style="font-size:13px;font-family:Arial;font-weight:bold;" data-sheets-value="[null,2,&quot;Ways of climbing over the wall&quot;]" data-sheets-userformat="[null,null,16897,[null,0],null,null,null,null,null,null,null,null,0,null,null,null,null,1]">Ways of climbing over the wall</span>`;
  const post = parser$1.parse(text);
  const expected = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    const b = markup('strong');
    return post([markupSection('p', [marker('Ways of climbing over the wall', [b])])]);
  });

  assert.postIsSimilar(post, expected);
});

// Cell in bold (Chrome - Windows)
test$l('#parse returns a markup section with bold when given a cell in bold (Chrome - Windows)', (assert) => {
  const text = `<html><body><!--StartFragment--><style type="text/css"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><span style="font-size:13px;font-family:Arial;font-weight:bold;" data-sheets-value="[null,2,&quot;Ways of climbing over the wall&quot;]" data-sheets-userformat="[null,null,16897,[null,0],null,null,null,null,null,null,null,null,0,null,null,null,null,1]">Ways of climbing over the wall</span><!--EndFragment--></body></html>`;
  const post = parser$1.parse(text);
  const expected = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    const b = markup('strong');
    return post([markupSection('p', [marker('Ways of climbing over the wall', [b])])]);
  });

  assert.postIsSimilar(post, expected);
});

// Two adjacent cells without formatting
test$l('#parse returns a single markup section when given two cells on top of each other without formatting', (assert) => {
  const text = `<meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="generator" content="Sheets"><style type="text/css"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><table cellspacing="0" cellpadding="0" dir="ltr" border="1" style="table-layout:fixed;font-size:13px;font-family:arial,sans,sans-serif;border-collapse:collapse;border:1px solid #ccc"><colgroup><col width="361"></colgroup><tbody><tr style="height:21px;"><td style="padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;" data-sheets-value="[null,2,&quot;Ostalgia&quot;]">Ostalgia</td></tr><tr style="height:21px;"><td style="padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;" data-sheets-value="[null,2,&quot;Photo&quot;]">Photo</td></tr></tbody></table>`;
  const post = parser$1.parse(text);
  const expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('OstalgiaPhoto')])]);
  });

  assert.postIsSimilar(post, expected);
});

// Two adjacent cells without formatting (Chrome - Windows)
test$l('#parse returns a single markup section when given two cells on top of each other without formatting (Chrome - Windows)', (assert) => {
  const text = `<html><body><!--StartFragment--><meta name="generator" content="Sheets"><style type="text/css"><!--td {border: 1px solid #ccc;}br {mso-data-placement:same-cell;}--></style><table cellspacing="0" cellpadding="0" dir="ltr" border="1" style="table-layout:fixed;font-size:13px;font-family:arial,sans,sans-serif;border-collapse:collapse;border:1px solid #ccc"><colgroup><col width="361"></colgroup><tbody><tr style="height:21px;"><td style="padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;" data-sheets-value="[null,2,&quot;Ostalgia&quot;]">Ostalgia</td></tr><tr style="height:21px;"><td style="padding:2px 3px 2px 3px;vertical-align:bottom;font-family:Arial;" data-sheets-value="[null,2,&quot;Photo&quot;]">Photo</td></tr></tbody></table><!--EndFragment--></body></html>`;
  const post = parser$1.parse(text);
  const expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('OstalgiaPhoto')])]);
  });

  assert.postIsSimilar(post, expected);
});

const {module: module$m, test: test$m} = Helpers;

function parseHTML$2(html, options={}) {
  let builder = new PostNodeBuilder();
  return new HTMLParser(builder, options).parse(html);
}

let didParseVideo;
function videoParserPlugin(node) {
  if (node.tagName === 'VIDEO') {
    didParseVideo = true;
  }
}

module$m('Unit: Parser: HTMLParser', {
  beforeEach() {
    didParseVideo = false;
  }
});

test$m('style tags are ignored', (assert) => {
  // This is the html you get when copying a message from Slack's desktop app
  let html = `<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta http-equiv="Content-Style-Type" content="text/css"> <title></title> <meta name="Generator" content="Cocoa HTML Writer"> <meta name="CocoaVersion" content="1348.17"> <style type="text/css"> p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Times; color: #2c2d30; -webkit-text-stroke: #2c2d30; background-color: #f9f9f9} span.s1 {font-kerning: none} </style> </head> <body> <p class="p1"><span class="s1">cool</span></p> </body> </html>`;
  let post = parseHTML$2(html);

  let expected = Helpers.postAbstract.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('cool')])]);
  });

  assert.postIsSimilar(post, expected);
});

// See https://github.com/bustle/mobiledoc-kit/issues/333
test$m('newlines ("\\n") are replaced with space characters', (assert) => {
  let html = "abc\ndef";
  let post = parseHTML$2(html);
  let {post: expected} = Helpers.postAbstract.buildFromText(['abc def']);

  assert.postIsSimilar(post, expected);
});

// see https://github.com/bustlelabs/mobiledoc-kit/issues/494
test$m('top-level unknown void elements are parsed', (assert) => {
  let html = `<video />`;
  let post = parseHTML$2(html, {plugins: [videoParserPlugin]});
  let {post: expected} = Helpers.postAbstract.buildFromText([]);

  assert.ok(didParseVideo);
  assert.postIsSimilar(post, expected);
});

// see https://github.com/bustlelabs/mobiledoc-kit/issues/494
test$m('top-level unknown elements are parsed', (assert) => {
  let html = `<video>...inner...</video>`;
  let post = parseHTML$2(html, {plugins: [videoParserPlugin]});
  let {post: expected} = Helpers.postAbstract.buildFromText(['...inner...']);

  assert.ok(didParseVideo);
  assert.postIsSimilar(post, expected);
});

test$m('nested void unknown elements are parsed', (assert) => {
  let html = `<p>...<video />...</p>`;
  let post = parseHTML$2(html, {plugins: [videoParserPlugin]});
  let {post: expected} = Helpers.postAbstract.buildFromText(['......']);

  assert.ok(didParseVideo);
  assert.postIsSimilar(post, expected);
});

test$m('nested unknown elements are parsed', (assert) => {
  let html = `<p>...<video>inner</video>...</p>`;
  let post = parseHTML$2(html, {plugins: [videoParserPlugin]});
  let {post: expected} = Helpers.postAbstract.buildFromText(['...inner...']);

  assert.ok(didParseVideo);
  assert.postIsSimilar(post, expected);
});

const { module: module$n, test: test$n } = Helpers;

let builder$7, post;

function parse(mobiledoc) {
  return mobiledocParsers.parse(builder$7, mobiledoc);
}

module$n('Unit: Parsers: Mobiledoc', {
  beforeEach() {
    builder$7 = new PostNodeBuilder();
    post = builder$7.createPost();
  },
  afterEach() {
    builder$7 = null;
    post = null;
  }
});

test$n('#parse empty doc returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [[], []]
  };

  const parsed = parse(mobiledoc);
  assert.equal(parsed.sections.length, 0, '0 sections');
});


test$n('#parse basic mobiledoc from renderer works', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [
      marker('Howdy')
    ])]);
  });

  const parsed = parse(mobiledoc);
  assert.equal(parsed.sections.length, 1, '1 section');
});

const DATA_URL = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
const { module: module$o, test: test$o } = Helpers;

let parser$2, builder$8, post$1;

module$o('Unit: Parsers: Mobiledoc 0.2', {
  beforeEach() {
    builder$8 = new PostNodeBuilder();
    parser$2 = new MobiledocParser(builder$8);
    post$1 = builder$8.createPost();
  },
  afterEach() {
    parser$2 = null;
    builder$8 = null;
    post$1 = null;
  }
});

test$o('#parse empty doc returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [[], []]
  };

  const parsed = parser$2.parse(mobiledoc);
  assert.equal(parsed.sections.length, 0, '0 sections');
});

test$o('#parse empty markup section returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [[], [
      [1, 'p', []]
    ]]
  };

  const section = builder$8.createMarkupSection('p');
  post$1.sections.append(section);
  assert.deepEqual(parser$2.parse(mobiledoc), post$1);
});

test$o('#parse doc without marker types', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [[
        1,'P', [[[], 0, 'hello world']]
      ]]
    ]
  };
  const parsed = parser$2.parse(mobiledoc);

  let section = builder$8.createMarkupSection('P', [], false);
  let marker  = builder$8.createMarker('hello world');
  section.markers.append(marker);
  post$1.sections.append(section);

  assert.deepEqual(
    parsed,
    post$1
  );
});

test$o('#parse doc with blank marker', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [[
        1,'P', [[[], 0, '']]
      ]]
    ]
  };
  const parsed = parser$2.parse(mobiledoc);

  let section = builder$8.createMarkupSection('P', [], false);
  post$1.sections.append(section);

  assert.deepEqual(
    parsed,
    post$1
  );
});

test$o('#parse doc with marker type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [
        ['B'],
        ['A', ['href', 'google.com']]
      ],
      [[
        1,'P', [
          [[1], 0, 'hello'],     // a tag open
          [[0], 1, 'brave new'], // b tag open/close
          [[], 1, 'world']       // a tag close
        ]
      ]]
    ]
  };
  const parsed = parser$2.parse(mobiledoc);

  let section = builder$8.createMarkupSection('P', [], false);
  let aMarkerType = builder$8.createMarkup('A', {href:'google.com'});
  let bMarkerType = builder$8.createMarkup('B');

  let markers  = [
    builder$8.createMarker('hello', [aMarkerType]),
    builder$8.createMarker('brave new', [aMarkerType, bMarkerType]),
    builder$8.createMarker('world', [aMarkerType])
  ];
  markers.forEach(marker => section.markers.append(marker));
  post$1.sections.append(section);

  assert.deepEqual(
    parsed,
    post$1
  );
});

test$o('#parse pull-quote section to aside node', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [[
        1,'PULL-QUOTE', [
          [[], 0, 'quoted']
        ]
      ]]
    ]
  };
  const parsed = parser$2.parse(mobiledoc);

  let section = builder$8.createMarkupSection('ASIDE', [], false);
  let markers  = [
    builder$8.createMarker('quoted', [])
  ];
  markers.forEach(marker => section.markers.append(marker));
  post$1.sections.append(section);

  assert.deepEqual(
    parsed,
    post$1
  );
});

test$o('#parse doc with image section', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [2, DATA_URL]
      ]
    ]
  };

  const parsed = parser$2.parse(mobiledoc);

  let section = builder$8.createImageSection(DATA_URL);
  post$1.sections.append(section);
  assert.deepEqual(
    parsed,
    post$1
  );
});

test$o('#parse doc with custom card type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [10, 'custom-card', {}]
      ]
    ]
  };

  const parsed = parser$2.parse(mobiledoc);

  let section = builder$8.createCardSection('custom-card');
  post$1.sections.append(section);
  assert.deepEqual(
    parsed,
    post$1
  );
});

test$o('#parse a mobile doc with list-section and list-item', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [3, 'ul', [
          [[[], 0, "first item"]],
          [[[], 0, "second item"]]
        ]]
      ]
    ]
  };

  const parsed = parser$2.parse(mobiledoc);

  const items = [
    builder$8.createListItem([builder$8.createMarker('first item')]),
    builder$8.createListItem([builder$8.createMarker('second item')])
  ];
  const section = builder$8.createListSection('ul', items);
  post$1.sections.append(section);
  assert.deepEqual(
    parsed,
    post$1
  );
});

const DATA_URL$1 = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
const { module: module$p, test: test$p } = Helpers;

let parser$3, builder$9, post$2;

module$p('Unit: Parsers: Mobiledoc 0.3.2', {
  beforeEach() {
    builder$9 = new PostNodeBuilder();
    parser$3 = new MobiledocParser$3(builder$9);
    post$2 = builder$9.createPost();
  },
  afterEach() {
    parser$3 = null;
    builder$9 = null;
    post$2 = null;
  }
});

test$p('#parse empty doc returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: []
  };

  const parsed = parser$3.parse(mobiledoc);
  assert.equal(parsed.sections.length, 0, '0 sections');
});

test$p('#parse empty markup section returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [1, 'p', []]
    ]
  };

  const section = builder$9.createMarkupSection('p');
  post$2.sections.append(section);
  assert.deepEqual(parser$3.parse(mobiledoc), post$2);
});

test$p('#parse doc without marker types', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,'P', [[0, [], 0, 'hello world']]
      ]
    ]
  };
  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createMarkupSection('P', [], false);
  let marker  = builder$9.createMarker('hello world');
  section.markers.append(marker);
  post$2.sections.append(section);

  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse doc with blank marker', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,'P', [[0, [], 0, '']]
      ]
    ]
  };
  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createMarkupSection('P', [], false);
  post$2.sections.append(section);

  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse doc with marker type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [
      ['B'],
      ['A', ['href', 'google.com']]
    ],
    sections: [
      [
        1,'P', [
          [0, [1], 0, 'hello'],     // a tag open
          [0, [0], 1, 'brave new'], // b tag open/close
          [0, [], 1, 'world']       // a tag close
        ]
      ]
    ]
  };
  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createMarkupSection('P', [], false);
  let aMarkerType = builder$9.createMarkup('A', {href:'google.com'});
  let bMarkerType = builder$9.createMarkup('B');

  let markers  = [
    builder$9.createMarker('hello', [aMarkerType]),
    builder$9.createMarker('brave new', [aMarkerType, bMarkerType]),
    builder$9.createMarker('world', [aMarkerType])
  ];
  markers.forEach(marker => section.markers.append(marker));
  post$2.sections.append(section);

  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse doc with image section', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [2, DATA_URL$1]
    ]
  };

  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createImageSection(DATA_URL$1);
  post$2.sections.append(section);
  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse doc with custom card type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [
      ['custom-card', {}]
    ],
    markups: [],
    sections: [
      [10, 0]
    ]
  };

  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createCardSection('custom-card');
  post$2.sections.append(section);
  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse doc with custom atom type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [],
    sections: [
      [
        1,'P', [
          [1, [], 0, 0]
        ]
      ]
    ]
  };

  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createMarkupSection('P', [], false);
  let atom = builder$9.createAtom('mention', '@bob', { id: 42 });
  section.markers.append(atom);
  post$2.sections.append(section);

  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse a mobile doc with list-section and list-item', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [3, 'ul', [
        [[0, [], 0, "first item"]],
        [[0, [], 0, "second item"]]
      ]]
    ]
  };

  const parsed = parser$3.parse(mobiledoc);

  const items = [
    builder$9.createListItem([builder$9.createMarker('first item')]),
    builder$9.createListItem([builder$9.createMarker('second item')])
  ];
  const section = builder$9.createListSection('ul', items);
  post$2.sections.append(section);
  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse doc with paragraph with text alignment', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,
        'P',
        [[0, [], 0, 'hello world']],
        ['data-md-text-align', 'center']
      ]
    ]
  };

  const parsed = parser$3.parse(mobiledoc);

  let section = builder$9.createMarkupSection(
    'P',
    [],
    false,
    { 'data-md-text-align': 'center' }
  );
  let marker  = builder$9.createMarker('hello world');
  section.markers.append(marker);
  post$2.sections.append(section);

  assert.deepEqual(
    parsed,
    post$2
  );
});

test$p('#parse a mobile doc with list-section with text align', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        3,
        'ul',
        [
          [[0, [], 0, "first item"]],
          [[0, [], 0, "second item"]]
        ],
        ['data-md-text-align', 'center']
      ]
    ]
  };

  const parsed = parser$3.parse(mobiledoc);

  const items = [
    builder$9.createListItem([builder$9.createMarker('first item')]),
    builder$9.createListItem([builder$9.createMarker('second item')])
  ];
  const section = builder$9.createListSection(
    'ul',
    items,
    { 'data-md-text-align': 'center' }
  );
  post$2.sections.append(section);
  assert.deepEqual(
    parsed,
    post$2
  );
});

const DATA_URL$2 = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
const { module: module$q, test: test$q } = Helpers;

let parser$4, builder$a, post$3;

module$q('Unit: Parsers: Mobiledoc 0.3', {
  beforeEach() {
    builder$a = new PostNodeBuilder();
    parser$4 = new MobiledocParser$1(builder$a);
    post$3 = builder$a.createPost();
  },
  afterEach() {
    parser$4 = null;
    builder$a = null;
    post$3 = null;
  }
});

test$q('#parse empty doc returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: []
  };

  const parsed = parser$4.parse(mobiledoc);
  assert.equal(parsed.sections.length, 0, '0 sections');
});

test$q('#parse empty markup section returns an empty post', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [1, 'p', []]
    ]
  };

  const section = builder$a.createMarkupSection('p');
  post$3.sections.append(section);
  assert.deepEqual(parser$4.parse(mobiledoc), post$3);
});

test$q('#parse doc without marker types', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,'P', [[0, [], 0, 'hello world']]
      ]
    ]
  };
  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createMarkupSection('P', [], false);
  let marker  = builder$a.createMarker('hello world');
  section.markers.append(marker);
  post$3.sections.append(section);

  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse doc with blank marker', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,'P', [[0, [], 0, '']]
      ]
    ]
  };
  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createMarkupSection('P', [], false);
  post$3.sections.append(section);

  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse doc with marker type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [
      ['B'],
      ['A', ['href', 'google.com']]
    ],
    sections: [
      [
        1,'P', [
          [0, [1], 0, 'hello'],     // a tag open
          [0, [0], 1, 'brave new'], // b tag open/close
          [0, [], 1, 'world']       // a tag close
        ]
      ]
    ]
  };
  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createMarkupSection('P', [], false);
  let aMarkerType = builder$a.createMarkup('A', {href:'google.com'});
  let bMarkerType = builder$a.createMarkup('B');

  let markers  = [
    builder$a.createMarker('hello', [aMarkerType]),
    builder$a.createMarker('brave new', [aMarkerType, bMarkerType]),
    builder$a.createMarker('world', [aMarkerType])
  ];
  markers.forEach(marker => section.markers.append(marker));
  post$3.sections.append(section);

  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse pull-quote section to aside node', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,'PULL-QUOTE', [
          [0, [], 0, 'quoted']
        ]
      ]
    ]
  };
  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createMarkupSection('ASIDE', [], false);
  let markers  = [
    builder$a.createMarker('quoted', [])
  ];
  markers.forEach(marker => section.markers.append(marker));
  post$3.sections.append(section);

  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse doc with image section', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [2, DATA_URL$2]
    ]
  };

  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createImageSection(DATA_URL$2);
  post$3.sections.append(section);
  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse doc with custom card type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [
      ['custom-card', {}]
    ],
    markups: [],
    sections: [
      [10, 0]
    ]
  };

  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createCardSection('custom-card');
  post$3.sections.append(section);
  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse doc with custom atom type', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [],
    sections: [
      [
        1,'P', [
          [1, [], 0, 0]
        ]
      ]
    ]
  };

  const parsed = parser$4.parse(mobiledoc);

  let section = builder$a.createMarkupSection('P', [], false);
  let atom = builder$a.createAtom('mention', '@bob', { id: 42 });
  section.markers.append(atom);
  post$3.sections.append(section);

  assert.deepEqual(
    parsed,
    post$3
  );
});

test$q('#parse a mobile doc with list-section and list-item', (assert) => {
  const mobiledoc = {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [3, 'ul', [
        [[0, [], 0, "first item"]],
        [[0, [], 0, "second item"]]
      ]]
    ]
  };

  const parsed = parser$4.parse(mobiledoc);

  const items = [
    builder$a.createListItem([builder$a.createMarker('first item')]),
    builder$a.createListItem([builder$a.createMarker('second item')])
  ];
  const section = builder$a.createListSection('ul', items);
  post$3.sections.append(section);
  assert.deepEqual(
    parsed,
    post$3
  );
});

const {module: module$r, test: test$r} = Helpers;

let builder$b, parser$5;
let buildDOM$1 = Helpers.dom.fromHTML;

module$r('Unit: Parser: SectionParser', {
  beforeEach() {
    builder$b = new PostNodeBuilder();
    parser$5 = new SectionParser(builder$b);
  },
  afterEach() {
    builder$b = null;
    parser$5 = null;
  }
});

test$r('#parse parses simple dom', (assert) => {
  let container = buildDOM$1('<p>hello there<b>i am bold</b><p>');
  let element = container.firstChild;

  const [section] = parser$5.parse(element);
  assert.equal(section.tagName, 'p');
  assert.equal(section.markers.length, 2, 'has 2 markers');
  const [m1, m2] = section.markers.toArray();

  assert.equal(m1.value, 'hello there');
  assert.equal(m2.value, 'i am bold');
  assert.ok(m2.hasMarkup('b'), 'm2 is bold');
});

test$r('#parse parses nested markups', (assert) => {
  let container = buildDOM$1(`
    <p><b>i am bold<i>i am bold and italic</i>i am bold again</b></p>
  `);
  let element = container.firstChild;

  const [section] = parser$5.parse(element);
  assert.equal(section.markers.length, 3, 'has 3 markers');
  const [m1, m2, m3] = section.markers.toArray();

  assert.equal(m1.value, 'i am bold');
  assert.equal(m2.value, 'i am bold and italic');
  assert.equal(m3.value, 'i am bold again');
  assert.ok(m1.hasMarkup('b'), 'm1 is bold');
  assert.ok(m2.hasMarkup('b') && m2.hasMarkup('i'), 'm2 is bold and i');
  assert.ok(m3.hasMarkup('b'), 'm3 is bold');
  assert.ok(!m1.hasMarkup('i') && !m3.hasMarkup('i'), 'm1 and m3 are not i');
});

test$r('#parse ignores non-markup elements like spans', (assert) => {
  let container = buildDOM$1(`
    <p><span>i was in span</span></p>
  `);
  let element = container.firstChild;

  const [section] = parser$5.parse(element);
  assert.equal(section.tagName, 'p');
  assert.equal(section.markers.length, 1, 'has 1 markers');
  const [m1] = section.markers.toArray();

  assert.equal(m1.value, 'i was in span');
});

test$r('#parse reads attributes', (assert) => {
  let container = buildDOM$1(`
    <p><a href="google.com">i am a link</a></p>
  `);
  let element = container.firstChild;

  const [section] = parser$5.parse(element);
  assert.equal(section.markers.length, 1, 'has 1 markers');
  const [m1] = section.markers.toArray();
  assert.equal(m1.value, 'i am a link');
  assert.ok(m1.hasMarkup('a'), 'has "a" markup');
  assert.equal(m1.getMarkup('a').attributes.href, 'google.com');
});

test$r('#parse joins contiguous text nodes separated by non-markup elements', (assert) => {
  let container = buildDOM$1(`
    <p><span>span 1</span><span>span 2</span></p>
  `);
  let element = container.firstChild;

  const [section] = parser$5.parse(element);
  assert.equal(section.tagName, 'p');
  assert.equal(section.markers.length, 1, 'has 1 marker');
  const [m1] = section.markers.toArray();

  assert.equal(m1.value, 'span 1span 2');
});

test$r('#parse turns a textNode into a section', (assert) => {
  let container = buildDOM$1(`I am a text node`);
  let element = container.firstChild;
  const [section] = parser$5.parse(element);
  assert.equal(section.tagName, 'p');
  assert.equal(section.markers.length, 1, 'has 1 marker');
  const [m1] = section.markers.toArray();

  assert.equal(m1.value, 'I am a text node');
});

test$r('#parse allows passing in parserPlugins that can override element parsing', (assert) => {
  let container = buildDOM$1(`
    <p>text 1<img src="https://placehold.it/100x100">text 2</p>
  `);

  let element = container.firstChild;
  let plugins = [function(element, builder, {addSection}) {
    if (element.tagName !== 'IMG') {
      return;
    }
    let payload = {url: element.src};
    let cardSection = builder.createCardSection('test-image', payload);
    addSection(cardSection);
  }];
  parser$5 = new SectionParser(builder$b, {plugins});
  const sections = parser$5.parse(element);

  assert.equal(sections.length, 3, '3 sections');

  assert.equal(sections[0].text, 'text 1');
  assert.equal(sections[2].text, 'text 2');

  let cardSection = sections[1];
  assert.equal(cardSection.name, 'test-image');
  assert.deepEqual(cardSection.payload, {url: 'https://placehold.it/100x100'});
});

test$r('#parse allows passing in parserPlugins that can override text parsing', (assert) => {
  let container = buildDOM$1(`
    <p>text 1<img src="https://placehold.it/100x100">text 2</p>
  `);

  let element = container.firstChild;
  let plugins = [function(element, builder, {addMarkerable, nodeFinished}) {
    if (element.nodeType === NODE_TYPES.TEXT) {
      if (element.textContent === 'text 1') {
        addMarkerable(builder.createMarker('oh my'));
      }
      nodeFinished();
    }
  }];
  parser$5 = new SectionParser(builder$b, {plugins});
  const sections = parser$5.parse(element);

  assert.equal(sections.length, 1, '1 section');
  assert.equal(sections[0].text, 'oh my');
});

test$r('#parse only runs text nodes through parserPlugins once', (assert) => {
  let container = buildDOM$1('text');
  let textNode = container.firstChild;

  assert.equal(textNode.nodeType, NODE_TYPES.TEXT);

  let pluginRunCount = 0;
  let plugins = [function (element) {
    if (element.nodeType === NODE_TYPES.TEXT && element.textContent === 'text') {
      pluginRunCount++;
    }
  }];
  parser$5 = new SectionParser(builder$b, {plugins});
  parser$5.parse(textNode);

  assert.equal(pluginRunCount, 1);
});

test$r('#parse ignores blank markup sections', assert => {
  let container = buildDOM$1(`
    <div><p>One</p><p></p><p>Three</p></div>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 2, 'Two sections');
  assert.equal(sections[0].text, 'One');
  assert.equal(sections[1].text, 'Three');
});

test$r('#parse handles section-level elements in list item', assert => {
  let container = buildDOM$1(`
    <ol><li>One</li><li><h4>Two</h4><p>Two - P</p></li><li>Three</li></ol>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 4, '4 sections');

  assert.equal(sections[0].type, 'list-section', 'first section type');
  assert.equal(sections[0].tagName, 'ol', 'first section tagName');
  assert.equal(sections[0].items.length, 1, '1 list item in first list section');
  assert.equal(sections[0].items.objectAt(0).text, 'One');

  assert.equal(sections[1].type, 'markup-section', 'second section type');
  assert.equal(sections[1].tagName, 'h4');
  assert.equal(sections[1].text, 'Two');

  assert.equal(sections[2].type, 'markup-section', 'third section type');
  assert.equal(sections[2].tagName, 'p');
  assert.equal(sections[2].text, 'Two - P');

  assert.equal(sections[3].type, 'list-section', 'fourth section type');
  assert.equal(sections[3].tagName, 'ol', 'fourth section tagName');
  assert.equal(sections[3].items.length, 1, '1 list item in last list section');
  assert.equal(sections[3].items.objectAt(0).text, 'Three');
});

test$r("#parse handles single paragraph in list item", assert => {
  let container = buildDOM$1(`
    <ul><li><p>One</p></li>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1, "single list section");

  let list = sections[0];
  assert.equal(list.type, "list-section");
  assert.equal(list.items.length, 1, "1 list item");
  assert.equal(list.items.objectAt(0).text, "One");
});

test$r("#parse handles multiple paragraphs in list item", assert => {
  let container = buildDOM$1(`
    <ul><li><p>One</p><p>Two</p></li>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 2, '2 sections');

  let p1 = sections[0];
  assert.equal(p1.type, 'markup-section', 'first section type');
  assert.equal(p1.text, 'One');
  let p2 = sections[1];
  assert.equal(p2.type, "markup-section", "second section type");
  assert.equal(p2.text, "Two");
});

test$r("#parse handles multiple headers in list item", assert => {
  let container = buildDOM$1(`
    <ul><li><h1>One</h1><h2>Two</h2></li>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 2, '2 sections');

  let h1 = sections[0];
  assert.equal(h1.type, 'markup-section', 'first section type');
  assert.equal(h1.text, 'One');
  assert.equal(h1.tagName, 'h1');
  let h2 = sections[1];
  assert.equal(h2.type, 'markup-section', 'second section type');
  assert.equal(h2.text, 'Two');
  assert.equal(h2.tagName, 'h2');
});

// see https://github.com/bustle/mobiledoc-kit/issues/656
test$r('#parse handles list following node handled by parserPlugin', (assert) => {
  let container = buildDOM$1(`
    <div><img src="https://placehold.it/100x100"><ul><li>LI One</li></ul></div>
  `);

  let element = container.firstChild;
  let plugins = [function(element, builder, {addSection, nodeFinished}) {
    if (element.tagName !== 'IMG') {
      return;
    }
    let payload = {url: element.src};
    let cardSection = builder.createCardSection('test-image', payload);
    addSection(cardSection);
    nodeFinished();
  }];

  parser$5 = new SectionParser(builder$b, { plugins });
  const sections = parser$5.parse(element);

  assert.equal(sections.length, 2, '2 sections');

  let cardSection = sections[0];
  assert.equal(cardSection.name, 'test-image');
  assert.deepEqual(cardSection.payload, {url: 'https://placehold.it/100x100'});

  let listSection = sections[1];
  assert.equal(listSection.type, 'list-section');
  assert.equal(listSection.items.length, 1, '1 list item');
});

test$r('#parse handles insignificant whitespace', (assert) => {
  let container = buildDOM$1(`
    <ul>
      <li>
        One
      </li>
    </ul>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1, '1 section');
  let [list] = sections;
  assert.equal(list.type, 'list-section');
  assert.equal(list.items.length, 1, '1 list item');
  assert.equal(list.items.objectAt(0).text, 'One');
});

test$r('#parse handles insignificant whitespace (wrapped)', (assert) => {
  let container = buildDOM$1(`
    <div>
      <ul>
        <li>
          One
        </li>
      </ul>
    </div>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1, '1 section');
  let [list] = sections;
  assert.equal(list.type, 'list-section');
  assert.equal(list.items.length, 1, '1 list item');
  assert.equal(list.items.objectAt(0).text, 'One');
});


test$r('#parse avoids empty paragraph around wrapped list', (assert) => {
  let container = buildDOM$1(`
    <div><ul><li>One</li></ul></div>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1, 'single list section');
});

test$r('#parse handles nested lists of different types', assert => {
  let container = buildDOM$1(`
    <ol><li>One</li><li><ul><li>A</li><li>B</li></ul><li>Two</li></ol>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 3, '3 sections');

  assert.equal(sections[0].type, 'list-section', 'first section type');
  assert.equal(sections[0].tagName, 'ol', 'first section tagName');
  assert.equal(sections[0].items.length, 1, '1 list item in first list section');
  assert.equal(sections[0].items.objectAt(0).text, 'One');

  assert.equal(sections[1].type, 'list-section', 'second section type');
  assert.equal(sections[1].tagName, 'ul', 'fourth section tagName');
  assert.equal(sections[1].items.length, 2, '2 list items in second list section');
  assert.equal(sections[1].items.objectAt(0).text, 'A');
  assert.equal(sections[1].items.objectAt(1).text, 'B');

  assert.equal(sections[2].type, 'list-section', 'third section type');
  assert.equal(sections[2].tagName, 'ol', 'third section tagName');
  assert.equal(sections[2].items.length, 1, '1 list item in third list section');
  assert.equal(sections[2].items.objectAt(0).text, 'Two');
});

test$r('#parse handles grouping nested lists', (assert) => {
  let container = buildDOM$1(`
    <div><ul><li>Outer-One<ul><li>Inner-Two</li><li>Inner-Three</li></ul></li><li>Outer-Four</li></ul></div>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1, 'single list section');

  let list = sections[0];
  assert.equal(list.type, 'list-section');
  assert.equal(list.items.length, 4, '4 list items');
  assert.equal(list.items.objectAt(0).text, 'Outer-One');
  assert.equal(list.items.objectAt(1).text, 'Inner-Two');
  assert.equal(list.items.objectAt(2).text, 'Inner-Three');
  assert.equal(list.items.objectAt(3).text, 'Outer-Four');
});

test$r('#parse handles grouping of consecutive lists of same type', (assert) => {
  let container = buildDOM$1(`
    <div><ul><li>One</li></ul><ul><li>Two</li></ul>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1, 'single list section');
  let list = sections[0];
  assert.equal(list.items.objectAt(0).text, 'One');
  assert.equal(list.items.objectAt(1).text, 'Two');
});

test$r('#parse doesn\'t group consecutive lists of different types', (assert) => {
  let container = buildDOM$1(`
    <div><ul><li>One</li></ul><ol><li>Two</li></ol>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 2, 'two list sections');
  let ul = sections[0];
  assert.equal(ul.items.objectAt(0).text, 'One');
  let ol = sections[1];
  assert.equal(ol.items.objectAt(0).text, 'Two');
});

test$r('#parse handles p following list', (assert) => {
  let container = buildDOM$1(`
    <div><ol><li>li1</li><li>li2</li><p>para</p></div>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 2, 'two sections');

  let ol = sections[0];
  assert.equal(ol.items.length, 2, 'two list items');

  let p = sections[1];
  assert.equal(p.text, 'para');
});

test$r('#parse handles link in a heading followed by paragraph', (assert) => {
  let container = buildDOM$1(`
    <div><h4><a href="https://example.com">Linked header</a></h4><p>test</p></div>
  `);

  let element = container.firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 2, '2 sections');
  assert.equal(sections[0].text, 'Linked header');

  let markers = sections[0].markers.toArray();
  assert.equal(markers.length, 1, '1 marker');
  let [marker] = markers;
  assert.equal(marker.value, 'Linked header');
  assert.ok(marker.hasMarkup('a'), 'has A markup');

  let markup = marker.markups[0];
  assert.equal(markup.getAttribute('href'), 'https://example.com');
});

test$r('#parse skips STYLE nodes', (assert) => {
  let element = buildDOM$1(`
    <style>.rule { font-color: red; }</style>
  `).firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 0, 'does not parse style');
});

test$r('#parse skips top-level Comment nodes', (assert) => {
  let element = buildDOM$1(`
    <!--Some comment-->
  `).firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 0, 'does not parse comments');
});

test$r('#parse skips nested Comment nodes', (assert) => {
  let element = buildDOM$1(`
   <p><!--Some comment-->some text<!-- another comment --></p>
  `).firstChild;
  parser$5 = new SectionParser(builder$b);
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 1);
  let section = sections[0];
  assert.equal(section.text, 'some text', 'parses text surrounded by comments');
  assert.equal(section.markers.length, 1, 'only 1 marker');
});

// https://github.com/bustle/mobiledoc-kit/issues/683
test$r('#parse handles card-creating element after plain text', (assert) => {
  let container = buildDOM$1(`
    <div><p>Before<a href="https:/example.com/image.png"><img src="https://example.com/image.png"></a></p><p>After</p></div>
  `);

  let element = container.firstChild;
  let plugins = [function(element, builder, {addSection, nodeFinished}) {
    if (element.tagName !== 'IMG') {
      return;
    }
    let payload = {url: element.src};
    let cardSection = builder.createCardSection('test-image', payload);
    addSection(cardSection);
    nodeFinished();
  }];
  parser$5 = new SectionParser(builder$b, {plugins});
  let sections = parser$5.parse(element);

  assert.equal(sections.length, 3, '3 sections');
  assert.equal(sections[0].text.trim(), 'Before');
  assert.equal(sections[1].type, 'card-section');
  assert.equal(sections[2].text.trim(), 'After');
});

const {module: module$s, test: test$s} = Helpers;

let parser$6;

module$s('Unit: Parser: TextParser', {
  beforeEach() {
    const builder = new PostNodeBuilder();
    parser$6 = new TextParser(builder);
  },
  afterEach() {
    parser$6 = null;
  }
});

test$s('#parse returns a markup section when given single line of text', (assert) => {
  let text = 'some text';
  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('some text')])]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns multiple markup sections when given multiple lines', (assert) => {
  let text = ['first', 'second', 'third'].join(SECTION_BREAK);
  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('first')]),
      markupSection('p', [marker('second')]),
      markupSection('p', [marker('third')])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns multiple sections when lines are separated by CR+LF', (assert) => {
  let text = ['first', 'second', 'third'].join('\r\n');
  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('first')]),
      markupSection('p', [marker('second')]),
      markupSection('p', [marker('third')])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns multiple sections when lines are separated by CR', (assert) => {
  let text = ['first', 'second', 'third'].join('\r');
  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('first')]),
      markupSection('p', [marker('second')]),
      markupSection('p', [marker('third')])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns list section when text starts with "*"', (assert) => {
  let text = '* a list item';

  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(({post, listSection, listItem, marker}) => {
    return post([
      listSection('ul', [listItem([marker('a list item')])])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns list section with multiple items when text starts with "*"', (assert) => {
  let text = ['* first', '* second'].join(SECTION_BREAK);

  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(({post, listSection, listItem, marker}) => {
    return post([
      listSection('ul', [
        listItem([marker('first')]),
        listItem([marker('second')])
      ])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns list sections separated by markup sections', (assert) => {
  let text = ['* first list', 'middle section', '* second list'].join(SECTION_BREAK);

  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([
      listSection('ul', [
        listItem([marker('first list')])
      ]),
      markupSection('p', [marker('middle section')]),
      listSection('ul', [
        listItem([marker('second list')])
      ])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse returns ordered list items', (assert) => {
  let text = '1. first list';

  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([listSection('ol', [listItem([marker('first list')])])]);
  });

  assert.postIsSimilar(post, expected);
});

test$s('#parse can have ordered and unordered lists together', (assert) => {
  let text = ['1. ordered list', '* unordered list'].join(SECTION_BREAK);

  let post = parser$6.parse(text);
  let expected = Helpers.postAbstract.build(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([
      listSection('ol', [listItem([marker('ordered list')])]),
      listSection('ul', [listItem([marker('unordered list')])])
    ]);
  });

  assert.postIsSimilar(post, expected);
});

const { module: module$t, test: test$t } = Helpers;
let builder$c;

let renderer;
function render(renderTree, cards=[], atoms=[]) {
  let editor = {};
  renderer = new Renderer(editor, cards, atoms);
  return renderer.render(renderTree);
}

let editorElement$8;
module$t('Unit: Renderer: Editor-Dom', {
  beforeEach() {
    builder$c = new PostNodeBuilder();
    editorElement$8 = $('#editor')[0];
  },
  afterEach() {
    if (renderer) {
      renderer.destroy();
      renderer = null;
    }
  }
});

test$t("renders a dirty post", (assert) => {
  /*
   * renderTree is:
   *
   * renderNode
   *
   */
  const renderTree = new RenderTree(builder$c.createPost());
  render(renderTree);

  assert.ok(renderTree.rootElement, 'renderTree renders element for post');
  assert.ok(!renderTree.rootNode.isDirty, 'dirty node becomes clean');
  assert.equal(renderTree.rootElement.tagName, 'DIV', 'renderTree renders element for post');
});

test$t("renders a dirty post with un-rendered sections", (assert) => {
  let post = builder$c.createPost();
  let sectionA = builder$c.createMarkupSection('P');
  post.sections.append(sectionA);
  let sectionB = builder$c.createMarkupSection('P');
  post.sections.append(sectionB);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML, '<p><br></p><p><br></p>',
               'correct HTML is rendered');

  assert.ok(renderTree.rootNode.childNodes.head,
            'sectionA creates a first child');
  assert.equal(renderTree.rootNode.childNodes.head.postNode, sectionA,
               'sectionA is first renderNode child');
  assert.ok(!renderTree.rootNode.childNodes.head.isDirty, 'sectionA node is clean');
  assert.equal(renderTree.rootNode.childNodes.tail.postNode, sectionB,
               'sectionB is second renderNode child');
  assert.ok(!renderTree.rootNode.childNodes.tail.isDirty, 'sectionB node is clean');
});

[
  {
    name: 'markup',
    section: (builder) => builder.createMarkupSection('P')
  },
  {
    name: 'image',
    section: (builder) => builder.createImageSection(placeholderImageSrc)
  },
  {
    name: 'card',
    section: (builder) => builder.createCardSection('new-card')
  },
  {
    name: 'list-section',
    section: (builder) => builder.createListSection('ul', [
      builder.createListItem([builder.createMarker('item')])
    ])
  }
].forEach((testInfo) => {
  test$t(`removes nodes with ${testInfo.name} section`, (assert) => {
    let post = builder$c.createPost();
    let section = testInfo.section(builder$c);
    post.sections.append(section);

    let postElement = document.createElement('div');
    let sectionElement = document.createElement('p');
    postElement.appendChild(sectionElement);

    const renderTree = new RenderTree(post);
    const postRenderNode = renderTree.rootNode;
    postRenderNode.element = postElement;

    let sectionRenderNode = renderTree.buildRenderNode(section);
    sectionRenderNode.element = sectionElement;
    sectionRenderNode.scheduleForRemoval();
    postRenderNode.childNodes.append(sectionRenderNode);

    render(renderTree);

    assert.equal(renderTree.rootElement, postElement,
                 'post element remains');

    assert.equal(renderTree.rootElement.firstChild, null,
                 'section element removed');

    assert.equal(renderTree.rootNode.childNodes.length, 0,
                 'section renderNode is removed');
  });
});

test$t('renders a post with marker', (assert) => {
  let post = builder$c.createPost();
  let section = builder$c.createMarkupSection('P');
  post.sections.append(section);
  section.markers.append(
    builder$c.createMarker('Hi', [
      builder$c.createMarkup('STRONG')
    ])
  );

  const renderTree = new RenderTree(post);
  render(renderTree);
  assert.equal(renderTree.rootElement.innerHTML, '<p><strong>Hi</strong></p>');
});

test$t('renders a post with marker with a tab', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker(`a${TAB}b`)])
    ]);
  });

  const renderTree = new RenderTree(post);
  render(renderTree);
  assert.equal(renderTree.rootElement.innerHTML, '<p>a\u2003b</p>',
               'HTML for a tab character is correct');
});

test$t('renders a post with markup empty section', (assert) => {
  let post = builder$c.createPost();
  let section = builder$c.createMarkupSection('P');
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);
  assert.equal(renderTree.rootElement.innerHTML, '<p><br></p>');
});

test$t('renders a post with multiple markers', (assert) => {
  let post = builder$c.createPost();
  let section = builder$c.createMarkupSection('P');
  post.sections.append(section);

  let b = builder$c.createMarkup('B');
  let i = builder$c.createMarkup('I');

  section.markers.append(builder$c.createMarker('hello '));
  section.markers.append(
    builder$c.createMarker('bold, ', [b])
  );
  section.markers.append(
    builder$c.createMarker('italic,', [b,i])
  );
  section.markers.append(
    builder$c.createMarker(' world.')
  );

  const renderTree = new RenderTree(post);
  render(renderTree);
  assert.equal(renderTree.rootElement.innerHTML, '<p>hello <b>bold, <i>italic,</i></b> world.</p>');
});

test$t('renders a post with marker with link markup', (assert) => {
  let post = builder$c.createPost();
  let section = builder$c.createMarkupSection('P');
  post.sections.append(section);

  let href = 'http://google.com';
  let rel = 'nofollow';
  let linkMarkup = builder$c.createMarkup('A', {href, rel});

  section.markers.append(builder$c.createMarker('hello', [linkMarkup]));

  const renderTree = new RenderTree(post);
  render(renderTree);
  let {innerHTML: html} = renderTree.rootElement;
  assert.ok(
    html.match(/<p><a .*>hello<\/a><\/p>/),
    'a tag present'
  );
  assert.ok(
    html.match(new RegExp(`href="${href}"`)),
    'href present'
  );
  assert.ok(
    html.match(new RegExp(`rel="${rel}"`)),
    'rel present'
  );
});

test$t('renders a post with image', (assert) => {
  let url = placeholderImageSrc;
  let post = builder$c.createPost();
  let section = builder$c.createImageSection(url);
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);
  assert.equal(renderTree.rootElement.innerHTML, `<img src="${url}">`);
});

test$t('renders a post with atom', (assert) => {
  let post = Helpers.postAbstract.build(({ markupSection, post, atom }) => {
    return post([markupSection('p', [atom('mention', '@bob', {})])]);
  });

  const renderTree = new RenderTree(post);
  render(renderTree, [], [
    {
      name: 'mention',
      type: 'dom',
      render({value/*, options, env, payload*/}) {
        return document.createTextNode(value);
      }
    }
  ]);
  assert.equal(renderTree.rootElement.innerHTML, `<p><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">@bob</span>${ZWNJ}</span></p>`);
});

test$t('rerenders an atom with markup correctly when adjacent nodes change', (assert) => {
  let bold, italic, marker1, marker2, atom1, markupSection1;
  let post = Helpers.postAbstract.build(({ markupSection, post, atom, marker, markup }) => {
    bold = markup('b');
    italic = markup('em');
    marker1 = marker('abc');
    atom1 = atom('mention', 'bob', {}, [bold]);
    marker2 = marker('def');
    markupSection1 = markupSection('p', [marker1, atom1, marker2]);
    return post([markupSection1]);
  });

  const renderTree = new RenderTree(post);
  let cards = [], atoms = [{
    name: 'mention',
    type: 'dom',
    render({value/*, options, env, payload*/}) {
      return document.createTextNode(value);
    }
  }];
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p>abc<b><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob</span>${ZWNJ}</span></b>def</p>`,
              'initial render correct');

  marker1.value = 'ABC';
  marker1.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);

  assert.equal(renderTree.rootElement.innerHTML,
               `<p>ABC<b><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob</span>${ZWNJ}</span></b>def</p>`,
              'rerender is correct');

  atom1.removeMarkup(bold);
  atom1.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p>ABC<span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob</span>${ZWNJ}</span>def</p>`,
              'rerender is correct');

  marker2.renderNode.scheduleForRemoval();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p>ABC<span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob</span>${ZWNJ}</span></p>`,
              'rerender is correct');

  marker1.addMarkup(bold);
  marker1.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><b>ABC</b><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob</span>${ZWNJ}</span></p>`,
              'rerender is correct');

  marker1.renderNode.scheduleForRemoval();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob</span>${ZWNJ}</span></p>`,
              'rerender is correct');

  atom1.renderNode.scheduleForRemoval();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><br></p>`,
              'rerender is correct');

  let newAtom = builder$c.createAtom('mention', 'bob2', {}, [bold, italic]);
  markupSection1.markers.append(newAtom);
  markupSection1.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><b><em><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob2</span>${ZWNJ}</span></em></b></p>`,
              'rerender is correct');

  let newMarker = builder$c.createMarker('pre', [bold, italic]);
  markupSection1.markers.insertBefore(newMarker, newAtom);
  markupSection1.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><b><em>pre<span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob2</span>${ZWNJ}</span></em></b></p>`,
              'rerender is correct');

  newMarker = builder$c.createMarker('post', [bold, italic]);
  markupSection1.markers.append(newMarker);
  markupSection1.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><b><em>pre<span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob2</span>${ZWNJ}</span>post</em></b></p>`,
              'rerender is correct');

  newAtom.removeMarkup(bold);
  newAtom.renderNode.markDirty();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><b><em>pre</em></b><em><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">bob2</span>${ZWNJ}</span></em><b><em>post</em></b></p>`,
              'rerender is correct');

  newAtom.renderNode.scheduleForRemoval();

  // rerender
  render(renderTree, cards, atoms);
  assert.equal(renderTree.rootElement.innerHTML,
               `<p><b><em>prepost</em></b></p>`,
              'rerender is correct');
});

test$t('renders a post with atom with markup', (assert) => {
  let post = Helpers.postAbstract.build(({ markupSection, post, atom, marker, markup }) => {
    let b = markup('B');
    let i = markup('I');

    return post([markupSection('p', [
      atom('mention', '@bob', {}, [b, i])
    ])]);
  });

  const renderTree = new RenderTree(post);
  render(renderTree, [], [
    {
      name: 'mention',
      type: 'dom',
      render({fragment, value/*, options, env, payload*/}) {
        return document.createTextNode(value);
      }
    }
  ]);

  assert.equal(renderTree.rootElement.innerHTML, `<p><b><i><span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">@bob</span>${ZWNJ}</span></i></b></p>`);
});

test$t('renders a post with mixed markups and atoms', (assert) => {
  let post = Helpers.postAbstract.build(({ markupSection, post, atom, marker, markup }) => {
    let b = markup('B');
    let i = markup('I');

    return post([markupSection('p', [
      marker('bold', [b]),
      marker('italic ', [b, i]),
      atom('mention', '@bob', {}, [b, i]),
      marker(' bold', [b]),
      builder$c.createMarker('text.')
    ])]);
  });

  const renderTree = new RenderTree(post);
  render(renderTree, [], [
    {
      name: 'mention',
      type: 'dom',
      render({fragment, value/*, options, env, payload*/}) {
        return document.createTextNode(value);
      }
    }
  ]);

  assert.equal(renderTree.rootElement.innerHTML, `<p><b>bold<i>italic <span class="-mobiledoc-kit__atom">${ZWNJ}<span contenteditable="false">@bob</span>${ZWNJ}</span></i> bold</b>text.</p>`);
});

test$t('renders a card section', (assert) => {
  let post = builder$c.createPost();
  let cardSection = builder$c.createCardSection('my-card');
  let card = {
    name: 'my-card',
    type: 'dom',
    render() {
      return document.createTextNode('I am a card');
    }
  };
  post.sections.append(cardSection);

  const renderTree = new RenderTree(post);
  render(renderTree, [card]);

  // Use a wrapper an innerHTML to satisfy different browser attribute
  // ordering quirks
  let expectedWrapper = $(`<div>${ZWNJ}<div contenteditable="false" class="__mobiledoc-card">I am a card</div>${ZWNJ}</div>`);
  assert.equal(renderTree.rootElement.firstChild.innerHTML,
               expectedWrapper.html(),
              'card is rendered');
});

test$t('rerender a marker after adding a markup to it', (assert) => {
  let bold, marker2;
  let post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    bold = markup('B');
    marker2 = marker('text2');
    return post([
      markupSection('p', [marker('text1', [bold]), marker2])
    ]);
  });

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><b>text1</b>text2</p>');

  marker2.addMarkup(bold);
  marker2.renderNode.markDirty();

  // rerender
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML, '<p><b>text1text2</b></p>');
});

test$t('rerender a marker after removing a markup from it', (assert) => {
  const post = builder$c.createPost();
  const section = builder$c.createMarkupSection('p');
  const bMarkup = builder$c.createMarkup('B');
  const marker1 = builder$c.createMarker('text1');
  const marker2 = builder$c.createMarker('text2', [bMarkup]);

  section.markers.append(marker1);
  section.markers.append(marker2);
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p>text1<b>text2</b></p>');

  marker2.removeMarkup(bMarkup);
  marker2.renderNode.markDirty();

  // rerender
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p>text1text2</p>');
});

test$t('rerender a marker after removing a markup from it (when changed marker is first marker)', (assert) => {
  const post = builder$c.createPost();
  const section = builder$c.createMarkupSection('p');
  const bMarkup = builder$c.createMarkup('B');
  const marker1 = builder$c.createMarker('text1', [bMarkup]);
  const marker2 = builder$c.createMarker('text2');

  section.markers.append(marker1);
  section.markers.append(marker2);
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><b>text1</b>text2</p>');

  marker1.removeMarkup(bMarkup);
  marker1.renderNode.markDirty();

  // rerender
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p>text1text2</p>');
});

test$t('rerender a marker after removing a markup from it (when both markers have same markup)', (assert) => {
  const post = builder$c.createPost();
  const section = builder$c.createMarkupSection('p');
  const bMarkup = builder$c.createMarkup('B');
  const marker1 = builder$c.createMarker('text1', [bMarkup]);
  const marker2 = builder$c.createMarker('text2', [bMarkup]);

  section.markers.append(marker1);
  section.markers.append(marker2);
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><b>text1text2</b></p>');

  marker1.removeMarkup(bMarkup);
  marker1.renderNode.markDirty();

  // rerender
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p>text1<b>text2</b></p>');
});

test$t('rerender a marker after removing a markup from it (when both markers have same markup)', (assert) => {
  const post = builder$c.createPost();
  const section = builder$c.createMarkupSection('p');
  const bMarkup = builder$c.createMarkup('B');
  const marker1 = builder$c.createMarker('text1', [bMarkup]);
  const marker2 = builder$c.createMarker('text2', [bMarkup]);

  section.markers.append(marker1);
  section.markers.append(marker2);
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><b>text1text2</b></p>');

  marker1.removeMarkup(bMarkup);
  marker1.renderNode.markDirty();

  // rerender
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p>text1<b>text2</b></p>');
});

test$t('render when contiguous markers have out-of-order markups', (assert) => {
  const post = builder$c.createPost();
  const section = builder$c.createMarkupSection('p');

  const b = builder$c.createMarkup('B'),
        i = builder$c.createMarkup('I');

  const markers = [
    builder$c.createMarker('BI', [b,i]),
    builder$c.createMarker('IB', [i,b]),
    builder$c.createMarker('plain', [])
  ];
  const m1 = markers[0];

  markers.forEach(m => section.markers.append(m));
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><b><i>BI</i></b><i><b>IB</b></i>plain</p>');

  // remove 'b' from 1st marker, rerender
  m1.removeMarkup(b);
  m1.renderNode.markDirty();
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><i>BI<b>IB</b></i>plain</p>');
});

test$t('contiguous markers have overlapping markups', (assert) => {
  const b = builder$c.createMarkup('b'),
        i = builder$c.createMarkup('i');
  const post = builder$c.createPost();
  const markers = [
    builder$c.createMarker('W', [i]),
    builder$c.createMarker('XY', [i,b]),
    builder$c.createMarker('Z', [b])
  ];
  const section = builder$c.createMarkupSection('P', markers);
  post.sections.append(section);

  const renderTree = new RenderTree(post);
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               '<p><i>W<b>XY</b></i><b>Z</b></p>');
});

test$t('renders and rerenders list items', (assert) => {
  const post = Helpers.postAbstract.build(({post, listSection, listItem, marker}) =>
    post([
      listSection('ul', [
        listItem([marker('first item')]),
        listItem([marker('second item')])
      ])
    ])
  );

  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t =>
    t('ul', {}, [
      t('li', {}, [t.text('first item')]),
      t('li', {}, [t.text('second item')])
    ])
  );
  const expectedHTML = expectedDOM.outerHTML;

  assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'correct html on initial render');

  // test rerender after dirtying list section
  const listSection = post.sections.head;
  listSection.renderNode.markDirty();
  render(renderTree);
  assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'correct html on rerender after dirtying list-section');

  // test rerender after dirtying list item
  const listItem = post.sections.head.items.head;
  listItem.renderNode.markDirty();
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'correct html on rerender after diryting list-item');
});

test$t('removes list items', (assert) => {
  const post = Helpers.postAbstract.build(({post, listSection, listItem, marker}) =>
    post([
      listSection('ul', [
        listItem([marker('first item')]),
        listItem([marker('second item')]),
        listItem([marker('third item')])
      ])
    ])
  );

  const renderTree = new RenderTree(post);
  render(renderTree);

  // return HTML for a list with the given items
  const htmlWithItems = (itemTexts) => {
    const expectedDOM = Helpers.dom.build(t =>
      t('ul', {}, itemTexts.map(text => t('li', {}, [t.text(text)])))
    );
    return expectedDOM.outerHTML;
  };

  const listItem2 = post.sections.head. // listSection
                         items.objectAt(1); // li
  listItem2.renderNode.scheduleForRemoval();
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               htmlWithItems(['first item', 'third item']),
               'removes middle list item');

  const listItemLast = post.sections.head. // listSection
                            items.tail;
  listItemLast.renderNode.scheduleForRemoval();
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML,
               htmlWithItems(['first item']),
               'removes last list item');
});

test$t('removes list sections', (assert) => {
  const post = Helpers.postAbstract.build(({post, listSection, markupSection, listItem, marker}) =>
    post([
      markupSection('p', [marker('something')]),
      listSection('ul', [
        listItem([marker('first item')])
      ])
    ])
  );

  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t =>
    t('p', {}, [t.text('something')])
  );
  const expectedHTML = expectedDOM.outerHTML;

  const listSection = post.sections.objectAt(1);
  listSection.renderNode.scheduleForRemoval();
  render(renderTree);

  assert.equal(renderTree.rootElement.innerHTML, expectedHTML, 'removes list section');
});

test$t('includes card sections in renderTree element map', (assert) => {
  const post = Helpers.postAbstract.build(({post, cardSection}) =>
    post([cardSection('simple-card')])
  );
  const cards = [{
    name: 'simple-card',
    type: 'dom',
    render() {
      return $('<div id="simple-card"></div>')[0];
    }
  }];

  const renderTree = new RenderTree(post);
  render(renderTree, cards);

  $('#qunit-fixture').append(renderTree.rootElement);

  const element = $('#simple-card')[0].parentNode.parentNode;
  assert.ok(!!element, 'precond - simple card is rendered');
  assert.ok(!!renderTree.getElementRenderNode(element),
            'has render node for card element');
});

test$t('removes nested children of removed render nodes', (assert) => {
  let section;
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    section = markupSection('p', [marker('abc')]);
    return post([section]);
  });

  const renderTree = new RenderTree(post);
  render(renderTree);

  const marker = section.markers.head;
  assert.ok(!!section.renderNode, 'precond - section has render node');
  assert.ok(!!marker.renderNode, 'precond - marker has render node');

  section.renderNode.scheduleForRemoval();
  render(renderTree);

  assert.ok(!marker.renderNode.parent, 'marker render node is orphaned');
  assert.ok(!marker.renderNode.element, 'marker render node has no element');
  assert.equal(section.renderNode.childNodes.length, 0,
               'section render node has all children removed');
});

test$t('renders markup section "aside" as <aside></aside>', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('aside', [marker('abc')])]);
  });
  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t => {
    return t('aside', {}, [t.text('abc')]);
  });

  assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);
});

test$t('renders characters and spaces with nbsps', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('a b  c    d ')])]);
  });
  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t => {
    return t('p', {}, [t.text(`a b ${NO_BREAK_SPACE}c ${NO_BREAK_SPACE} ${NO_BREAK_SPACE}d${NO_BREAK_SPACE}`)]);
  });

  assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);
});

test$t('renders all spaces with nbsps', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('   ')])]);
  });
  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t => {
    return t('p', {}, [t.text(`${NO_BREAK_SPACE}${NO_BREAK_SPACE}${NO_BREAK_SPACE}`)]);
  });

  assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);
});

test$t('renders leading space with nbsp', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker(' a')])]);
  });
  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t => {
    return t('p', {}, [t.text(`${NO_BREAK_SPACE}a`)]);
  });

  assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);
});

test$t('renders trailing space with nbsp', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('a ')])]);
  });
  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t => {
    return t('p', {}, [t.text(`a${NO_BREAK_SPACE}`)]);
  });

  assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);
});

test$t('renders leading and trailing space with nbsp', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker(' a ')])]);
  });
  const renderTree = new RenderTree(post);
  render(renderTree);

  const expectedDOM = Helpers.dom.build(t => {
    return t('p', {}, [t.text(`${NO_BREAK_SPACE}a${NO_BREAK_SPACE}`)]);
  });

  assert.equal(renderTree.rootElement.innerHTML, expectedDOM.outerHTML);
});

test$t('#destroy is safe to call if renderer has not rendered', (assert) => {
  let mockEditor = {}, cards = [];
  let renderer = new Renderer(mockEditor, cards);

  assert.ok(!renderer.hasRendered, 'precond - has not rendered');

  renderer.destroy();

  assert.ok(true, 'ok to destroy');
});

// see https://github.com/bustle/mobiledoc-kit/issues/306
test$t('rerender after adding markup to a marker when the marker siblings have that markup', (assert) => {
  let strong, expected;
  let post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    strong = markup('strong');
    expected = post([markupSection('p', [marker('aXc', [strong])])]);
    return post([markupSection('p', [marker('a', [strong]), marker('X'), marker('c', [strong])])]);
  });

  let renderTree = new RenderTree(post);
  render(renderTree);

  let markers = post.sections.head.markers.toArray();
  assert.equal(markers.length, 3);

  // step 1: add markup to the marker
  markers[1].addMarkup(strong);

  // step 2, join the markers
  markers[1].value = 'aX';
  markers[1].renderNode.markDirty();
  markers[0].renderNode.scheduleForRemoval();
  markers[0].section.markers.remove(markers[0]);

  markers[2].value = 'aXc';
  markers[2].renderNode.markDirty();
  markers[1].renderNode.scheduleForRemoval();
  markers[1].section.markers.remove(markers[1]);

  render(renderTree);

  assert.renderTreeIsEqual(renderTree, expected);

  markers = post.sections.head.markers.toArray();
  assert.equal(markers.length, 1);
  assert.ok(markers[0].hasMarkup(strong), 'marker has strong');
  assert.equal(markers[0].value, 'aXc');
});

/*
test("It renders a renderTree with rendered dirty section", (assert) => {
  /*
   * renderTree is:
   *
   *      post<dirty>
   *       /        \
   *      /          \
   * section      section<dirty>
   *
  let post = builder.createPost
  let postRenderNode = {
    element: null,
    parent: null,
    isDirty: true,
    postNode: builder.createPost()
  }
  let renderTree = {
    node: renderNode
  }

  render(renderTree);

  assert.ok(renderTree.rootElement, 'renderTree renders element for post');
  assert.ok(!renderTree.rootNode.isDirty, 'dirty node becomes clean');
  assert.equal(renderTree.rootElement.tagName, 'DIV', 'renderTree renders element for post');
});
*/

const { module: module$u, test: test$u } = Helpers;

function render$1(post) {
  return mobiledocRenderers.render(post);
}

module$u('Unit: Mobiledoc Renderer');

test$u('renders a blank post', (assert) => {
  let post = Helpers.postAbstract.build(({post}) => post());
  let mobiledoc = render$1(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$4,
    atoms: [],
    cards: [],
    markups: [],
    sections: []
  });
});

const { module: module$v, test: test$v } = Helpers;
function render$2(post) {
  return MobiledocRenderer.render(post);
}
let builder$d;

module$v('Unit: Mobiledoc Renderer 0.2', {
  beforeEach() {
    builder$d = new PostNodeBuilder();
  }
});

test$v('renders a blank post', (assert) => {
  let post = builder$d.createPost();
  let mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [[], []]
  });
});

test$v('renders a post with marker', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [marker('Hi', [markup('strong')])])
    ]);
  });
  const mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [['strong']],
      [
        [1, normalizeTagName('P'), [[[0], 1, 'Hi']]]
      ]
    ]
  });
});

test$v('renders a post section with markers sharing a markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [marker('Hi', [strong]), marker(' Guy', [strong])])
    ]);
  });
  let mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [['strong']],
      [
        [1, normalizeTagName('P'), [
          [[0], 0, 'Hi'],
          [[], 1, ' Guy']
        ]]
      ]
    ]
  });
});

test$v('renders a post with markers with markers with complex attributes', (assert) => {
  let link1,link2;
 const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    link1 = markup('a', {href:'bustle.com'});
    link2 = markup('a', {href:'other.com'});
    return post([
      markupSection('p', [
        marker('Hi', [link1]),
        marker(' Guy', [link2]),
        marker(' other guy', [link1])
      ])
    ]);
  });
  let mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [
        ['a', ['href', 'bustle.com']],
        ['a', ['href', 'other.com']]
      ],
      [
        [1, normalizeTagName('P'), [
          [[0], 1, 'Hi'],
          [[1], 1, ' Guy'],
          [[0], 1, ' other guy']
        ]]
      ]
    ]
  });

});


test$v('renders a post with image', (assert) => {
  let url = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
  let post = builder$d.createPost();
  let section = builder$d.createImageSection(url);
  post.sections.append(section);

  let mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [2, url]
      ]
    ]
  });
});

test$v('renders a post with image and null src', (assert) => {
  let post = builder$d.createPost();
  let section = builder$d.createImageSection();
  post.sections.append(section);

  let mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [2, null]
      ]
    ]
  });
});

test$v('renders a post with card', (assert) => {
  let cardName = 'super-card';
  let payload = { bar: 'baz' };
  let post = builder$d.createPost();
  let section = builder$d.createCardSection(cardName, payload);
  post.sections.append(section);

  let mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [10, cardName, payload]
      ]
    ]
  });
});

test$v('renders a post with a list', (assert) => {
  const items = [
    builder$d.createListItem([builder$d.createMarker('first item')]),
    builder$d.createListItem([builder$d.createMarker('second item')])
  ];
  const section = builder$d.createListSection('ul', items);
  const post = builder$d.createPost([section]);

  const mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [3, 'ul', [
          [[[], 0, 'first item']],
          [[[], 0, 'second item']]
        ]]
      ]
    ]
  });
});

test$v('renders an aside as markup section', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('aside', [marker('abc')])]);
  });
  const mobiledoc = render$2(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION,
    sections: [
      [],
      [
        [1, 'aside', [[[], 0, 'abc']]]
      ]
    ]
  });
});

const { module: module$w, test: test$w } = Helpers;
function render$3(post) {
  return MobiledocRenderer$3.render(post);
}
let builder$e;

module$w('Unit: Mobiledoc Renderer 0.3.2', {
  beforeEach() {
    builder$e = new PostNodeBuilder();
  }
});

test$w('renders a blank post', (assert) => {
  let post = builder$e.createPost();
  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: []
  });
});

test$w('renders a post with marker', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [marker('Hi', [markup('strong')])])
    ]);
  });
  const mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [['strong']],
    sections: [
      [1, normalizeTagName('P'), [[0, [0], 1, 'Hi']]]
    ]
  });
});

test$w('renders a post section with markers sharing a markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [marker('Hi', [strong]), marker(' Guy', [strong])])
    ]);
  });
  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [['strong']],
    sections: [
      [
        1,
        normalizeTagName('P'),
        [
          [0, [0], 0, 'Hi'],
          [0, [], 1, ' Guy']
        ]
      ]
    ]
  });
});

test$w('renders a post with markers with markers with complex attributes', (assert) => {
  let link1,link2;
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    link1 = markup('a', {href:'bustle.com'});
    link2 = markup('a', {href:'other.com'});
    return post([
      markupSection('p', [
        marker('Hi', [link1]),
        marker(' Guy', [link2]),
        marker(' other guy', [link1])
      ])
    ]);
  });
  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [
      ['a', ['href', 'bustle.com']],
      ['a', ['href', 'other.com']]
    ],
    sections: [
      [
        1,
        normalizeTagName('P'),
        [
          [0, [0], 1, 'Hi'],
          [0, [1], 1, ' Guy'],
          [0, [0], 1, ' other guy']
        ]
      ]
    ]
  });
});

test$w('renders a post with image', (assert) => {
  let url = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
  let post = builder$e.createPost();
  let section = builder$e.createImageSection(url);
  post.sections.append(section);

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [2, url]
    ]
  });
});

test$w('renders a post with image and null src', (assert) => {
  let post = builder$e.createPost();
  let section = builder$e.createImageSection();
  post.sections.append(section);

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [2, null]
    ]
  });
});

test$w('renders a post with atom', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, atom}) => {
    return post([
      markupSection('p', [
        marker('Hi'),
        atom('mention', '@bob', { id: 42 })
      ])
    ]);
  });

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [],
    sections: [
      [
        1,
        normalizeTagName('P'),
        [
          [0, [], 0, 'Hi'],
          [1, [], 0, 0]
        ]
      ]
    ]
  });
});

test$w('renders a post with atom and markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup, atom}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [
        atom('mention', '@bob', { id: 42 }, [strong])
      ])
    ]);
  });

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [['strong']],
    sections: [
      [
        1,
        normalizeTagName('P'),
        [
          [1, [0], 1, 0]
        ]
      ]
    ]
  });
});

test$w('renders a post with atom inside markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup, atom}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [
        marker('Hi ', [strong]),
        atom('mention', '@bob', { id: 42 }, [strong]),
        marker(' Bye', [strong])
      ])
    ]);
  });

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [['strong']],
    sections: [
      [
        1,
        normalizeTagName('P'),
        [
          [0, [0], 0, 'Hi '],
          [1, [], 0, 0],
          [0, [], 1, ' Bye']
        ]
      ]
    ]
  });
});

test$w('renders a post with card', (assert) => {
  let cardName = 'super-card';
  let payload = { bar: 'baz' };
  let post = builder$e.createPost();
  let section = builder$e.createCardSection(cardName, payload);
  post.sections.append(section);

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [
      [cardName, payload]
    ],
    markups: [],
    sections: [
      [10, 0]
    ]
  });
});

test$w('renders a post with multiple cards with identical payloads', (assert) => {
  let cardName = 'super-card';
  let payload1 = { bar: 'baz' };
  let payload2 = { bar: 'baz' };
  let post = builder$e.createPost();

  let section1 = builder$e.createCardSection(cardName, payload1);
  post.sections.append(section1);

  let section2 = builder$e.createCardSection(cardName, payload2);
  post.sections.append(section2);

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [
      [cardName, payload1],
      [cardName, payload2]
    ],
    markups: [],
    sections: [
      [10, 0],
      [10, 1]
    ]
  });
});

test$w('renders a post with cards with differing payloads', (assert) => {
  let cardName = 'super-card';
  let payload1 = { bar: 'baz1' };
  let payload2 = { bar: 'baz2' };
  let post = builder$e.createPost();

  let section1 = builder$e.createCardSection(cardName, payload1);
  post.sections.append(section1);

  let section2 = builder$e.createCardSection(cardName, payload2);
  post.sections.append(section2);

  let mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [
      [cardName, payload1],
      [cardName, payload2]
    ],
    markups: [],
    sections: [
      [10, 0],
      [10, 1]
    ]
  });
});

test$w('renders a post with a list', (assert) => {
  const items = [
    builder$e.createListItem([builder$e.createMarker('first item')]),
    builder$e.createListItem([builder$e.createMarker('second item')])
  ];
  const section = builder$e.createListSection('ul', items);
  const post = builder$e.createPost([section]);

  const mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        3,
        'ul',
        [
          [[0, [], 0, 'first item']],
          [[0, [], 0, 'second item']]
        ]
      ]
    ]
  });
});

test$w('renders an aside as markup section', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('aside', [marker('abc')])]);
  });
  const mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,
        'aside',
        [[0, [], 0, 'abc']]
      ]
    ]
  });
});

test$w('renders a post with a paragraph with attribute', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [], true, { 'data-md-text-align': 'center' })
    ]);
  });
  const mobiledoc = render$3(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        1,
        normalizeTagName('P'),
        [],
        ['data-md-text-align', 'center']
      ]
    ]
  });
});

test$w('renders a post with a list with attribute', (assert) => {
  const section = builder$e.createListSection('ul', [], { 'data-md-text-align': 'center' });
  const post = builder$e.createPost([section]);
  const mobiledoc = render$3(post);

  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$3,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [
        3,
        normalizeTagName('UL'),
        [],
        ['data-md-text-align', 'center']
      ]
    ]
  });
});

const { module: module$x, test: test$x } = Helpers;
function render$4(post) {
  return MobiledocRenderer$1.render(post);
}
let builder$f;

module$x('Unit: Mobiledoc Renderer 0.3', {
  beforeEach() {
    builder$f = new PostNodeBuilder();
  }
});

test$x('renders a blank post', (assert) => {
  let post = builder$f.createPost();
  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: []
  });
});

test$x('renders a post with marker', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [marker('Hi', [markup('strong')])])
    ]);
  });
  const mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [['strong']],
    sections: [
      [1, normalizeTagName('P'), [[0, [0], 1, 'Hi']]]
    ]
  });
});

test$x('renders a post section with markers sharing a markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [marker('Hi', [strong]), marker(' Guy', [strong])])
    ]);
  });
  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [['strong']],
    sections: [
      [1, normalizeTagName('P'), [
        [0, [0], 0, 'Hi'],
        [0, [], 1, ' Guy']
      ]]
    ]
  });
});

test$x('renders a post with markers with markers with complex attributes', (assert) => {
  let link1,link2;
 const post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    link1 = markup('a', {href:'bustle.com'});
    link2 = markup('a', {href:'other.com'});
    return post([
      markupSection('p', [
        marker('Hi', [link1]),
        marker(' Guy', [link2]),
        marker(' other guy', [link1])
      ])
    ]);
  });
  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [
      ['a', ['href', 'bustle.com']],
      ['a', ['href', 'other.com']]
    ],
    sections: [
      [1, normalizeTagName('P'), [
        [0, [0], 1, 'Hi'],
        [0, [1], 1, ' Guy'],
        [0, [0], 1, ' other guy']
      ]]
    ]
  });

});


test$x('renders a post with image', (assert) => {
  let url = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=";
  let post = builder$f.createPost();
  let section = builder$f.createImageSection(url);
  post.sections.append(section);

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [2, url]
    ]
  });
});

test$x('renders a post with image and null src', (assert) => {
  let post = builder$f.createPost();
  let section = builder$f.createImageSection();
  post.sections.append(section);

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [2, null]
    ]
  });
});

test$x('renders a post with atom', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, atom}) => {
     return post([
       markupSection('p', [
         marker('Hi'),
         atom('mention', '@bob', { id: 42 })
       ])
     ]);
   });

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [],
    sections: [
      [1, normalizeTagName('P'), [
        [0, [], 0, 'Hi'],
        [1, [], 0, 0]
      ]]
    ]
  });
});

test$x('renders a post with atom and markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup, atom}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [
        atom('mention', '@bob', { id: 42 }, [strong])
      ])
    ]);
  });

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [['strong']],
    sections: [
      [1, normalizeTagName('P'), [
        [1, [0], 1, 0]
      ]]
    ]
  });
});

test$x('renders a post with atom inside markup', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker, markup, atom}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [
        marker('Hi ', [strong]),
        atom('mention', '@bob', { id: 42 }, [strong]),
        marker(' Bye', [strong])
      ])
    ]);
  });

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [
      ['mention', '@bob', { id: 42 }]
    ],
    cards: [],
    markups: [['strong']],
    sections: [
      [1, normalizeTagName('P'), [
        [0, [0], 0, 'Hi '],
        [1, [], 0, 0],
        [0, [], 1, ' Bye']
      ]]
    ]
  });
});

test$x('renders a post with card', (assert) => {
  let cardName = 'super-card';
  let payload = { bar: 'baz' };
  let post = builder$f.createPost();
  let section = builder$f.createCardSection(cardName, payload);
  post.sections.append(section);

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [
      [cardName, payload]
    ],
    markups: [],
    sections: [
      [10, 0]
    ]
  });
});

test$x('renders a post with multiple cards with identical payloads', (assert) => {
  let cardName = 'super-card';
  let payload1 = { bar: 'baz' };
  let payload2 = { bar: 'baz' };
  let post = builder$f.createPost();

  let section1 = builder$f.createCardSection(cardName, payload1);
  post.sections.append(section1);

  let section2 = builder$f.createCardSection(cardName, payload2);
  post.sections.append(section2);

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [
      [cardName, payload1],
      [cardName, payload2]
    ],
    markups: [],
    sections: [
      [10, 0],
      [10, 1]
    ]
  });
});

test$x('renders a post with cards with differing payloads', (assert) => {
  let cardName = 'super-card';
  let payload1 = { bar: 'baz1' };
  let payload2 = { bar: 'baz2' };
  let post = builder$f.createPost();

  let section1 = builder$f.createCardSection(cardName, payload1);
  post.sections.append(section1);

  let section2 = builder$f.createCardSection(cardName, payload2);
  post.sections.append(section2);

  let mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [
      [cardName, payload1],
      [cardName, payload2]
    ],
    markups: [],
    sections: [
      [10, 0],
      [10, 1]
    ]
  });
});

test$x('renders a post with a list', (assert) => {
  const items = [
    builder$f.createListItem([builder$f.createMarker('first item')]),
    builder$f.createListItem([builder$f.createMarker('second item')])
  ];
  const section = builder$f.createListSection('ul', items);
  const post = builder$f.createPost([section]);

  const mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [3, 'ul', [
        [[0, [], 0, 'first item']],
        [[0, [], 0, 'second item']]
      ]]
    ]
  });
});

test$x('renders an aside as markup section', (assert) => {
  const post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('aside', [marker('abc')])]);
  });
  const mobiledoc = render$4(post);
  assert.deepEqual(mobiledoc, {
    version: MOBILEDOC_VERSION$1,
    atoms: [],
    cards: [],
    markups: [],
    sections: [
      [1, 'aside', [[0, [], 0, 'abc']]]
    ]
  });
});

const {module: module$y, test: test$y} = Helpers;

module$y('Unit: Utils: Array Utils');

test$y('#objectToSortedKVArray works', (assert) => {
  assert.deepEqual(objectToSortedKVArray({a: 1, b:2}), ['a', 1, 'b', 2]);
  assert.deepEqual(objectToSortedKVArray({b: 1, a:2}), ['a', 2, 'b', 1]);
  assert.deepEqual(objectToSortedKVArray({}), []);
});

test$y('#kvArrayToObject works', (assert) => {
  assert.deepEqual(kvArrayToObject(['a', 1, 'b', 2]), {a:1, b:2});
  assert.deepEqual(kvArrayToObject([]), {});
});

const {module: module$z, test: test$z} = Helpers;

module$z('Unit: Utils: assert');

test$z('#throws a MobiledocError when conditional is false', (assert) => {
  try {
    mobiledocAssert('The message', false);
  } catch (e) {
    assert.ok(true, 'caught error');
    assert.equal(e.message, 'The message');
    assert.ok(e instanceof MobiledocError, 'e instanceof MobiledocError');
  }
});

const {module: module$A, test: test$A} = Helpers;

module$A('Unit: Utils: copy');

test$A('#shallowCopyObject breaks references', (assert) => {
  let obj = {a: 1, b:'b'};
  let obj2 = shallowCopyObject(obj);
  obj.a = 2;
  obj.b = 'new b';

  assert.ok(obj !== obj2, 'obj !== obj2');
  assert.equal(obj2.a, 1, 'obj2 "a" preserved');
  assert.equal(obj2.b, 'b', 'obj2 "b" preserved');
});

const { FORWARD: FORWARD$3, BACKWARD: BACKWARD$3 } = DIRECTION;

const {module: module$B, test: test$B} = Helpers;

let editor$8, editorElement$9;

module$B('Unit: Utils: Position', {
  beforeEach() {
    editorElement$9 = $('#editor')[0];
  },
  afterEach() {
    if (editor$8) {
      editor$8.destroy();
      editor$8 = null;
    }
  }
});

test$B('#move moves forward and backward in markup section', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abcd')])]);
  });
  let position = post.sections.head.toPosition('ab'.length);
  let rightPosition = post.sections.head.toPosition('abc'.length);
  let leftPosition = post.sections.head.toPosition('a'.length);

  assert.positionIsEqual(position.move(FORWARD$3), rightPosition, 'right position');
  assert.positionIsEqual(position.move(BACKWARD$3), leftPosition, 'left position');
});

test$B('#move is emoji-aware', (assert) => {
  let emoji = '';
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker(`a${emoji}z`)])]);
  });
  let marker = post.sections.head.markers.head;
  assert.equal(marker.length, 'a'.length + 2 + 'z'.length); // precond
  let position = post.sections.head.headPosition();

  position = position.move(FORWARD$3);
  assert.equal(position.offset, 1);
  position = position.move(FORWARD$3);
  assert.equal(position.offset, 3); // l-to-r across emoji
  position = position.move(FORWARD$3);
  assert.equal(position.offset, 4);

  position = position.move(BACKWARD$3);
  assert.equal(position.offset, 3);

  position = position.move(BACKWARD$3); // r-to-l across emoji
  assert.equal(position.offset, 1);

  position = position.move(BACKWARD$3);
  assert.equal(position.offset, 0);
});

test$B('#move moves forward and backward between markup sections', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('a')]),
      markupSection('p', [marker('b')]),
      markupSection('p', [marker('c')])
    ]);
  });
  let midHead = post.sections.objectAt(1).headPosition();
  let midTail = post.sections.objectAt(1).tailPosition();

  let aTail   = post.sections.head.tailPosition();
  let cHead   = post.sections.tail.headPosition();

  assert.positionIsEqual(midHead.move(BACKWARD$3), aTail, 'left to prev section');
  assert.positionIsEqual(midTail.move(FORWARD$3), cHead, 'right to next section');
});

test$B('#move from one nested section to another', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [
      listItem([marker('a')]),
      listItem([marker('b')]),
      listItem([marker('c')])
    ])]);
  });
  let midHead = post.sections.head.items.objectAt(1).headPosition();
  let midTail = post.sections.head.items.objectAt(1).tailPosition();

  let aTail   = post.sections.head.items.head.tailPosition();
  let cHead   = post.sections.tail.items.tail.headPosition();

  assert.positionIsEqual(midHead.move(BACKWARD$3), aTail, 'left to prev section');
  assert.positionIsEqual(midTail.move(FORWARD$3), cHead, 'right to next section');
});

test$B('#move from last nested section to next un-nested section', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('a')]),
      listSection('ul', [listItem([marker('b')])]),
      markupSection('p', [marker('c')])
    ]);
  });
  let midHead = post.sections.objectAt(1).items.head.headPosition();
  let midTail = post.sections.objectAt(1).items.head.tailPosition();

  let aTail   = post.sections.head.tailPosition();
  let cHead   = post.sections.tail.headPosition();

  assert.positionIsEqual(midHead.move(BACKWARD$3), aTail, 'left to prev section');
  assert.positionIsEqual(midTail.move(FORWARD$3), cHead, 'right to next section');
});

test$B('#move across and beyond card section', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, cardSection, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('a')]),
      cardSection('my-card'),
      markupSection('p', [marker('c')])
    ]);
  });
  let midHead = post.sections.objectAt(1).headPosition();
  let midTail = post.sections.objectAt(1).tailPosition();

  let aTail   = post.sections.head.tailPosition();
  let cHead   = post.sections.tail.headPosition();

  assert.positionIsEqual(midHead.move(BACKWARD$3), aTail, 'left to prev section');
  assert.positionIsEqual(midTail.move(FORWARD$3), cHead, 'right to next section');
  assert.positionIsEqual(midHead.move(FORWARD$3), midTail, 'move l-to-r across card');
  assert.positionIsEqual(midTail.move(BACKWARD$3), midHead, 'move r-to-l across card');
});

test$B('#move across and beyond card section into list section', (assert) => {
  let post = Helpers.postAbstract.build(
    ({post, cardSection, listSection, listItem, marker}) => {
    return post([
      listSection('ul', [
        listItem([marker('a1')]),
        listItem([marker('a2')])
      ]),
      cardSection('my-card'),
      listSection('ul', [
        listItem([marker('c1')]),
        listItem([marker('c2')])
      ])
    ]);
  });
  let midHead = post.sections.objectAt(1).headPosition();
  let midTail = post.sections.objectAt(1).tailPosition();

  let aTail   = post.sections.head.items.tail.tailPosition();
  let cHead   = post.sections.tail.items.head.headPosition();

  assert.positionIsEqual(midHead.move(BACKWARD$3), aTail, 'left to prev section');
  assert.positionIsEqual(midTail.move(FORWARD$3), cHead, 'right to next section');
});

test$B('#move left at headPosition or right at tailPosition returns self', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('def')])
    ]);
  });

  let head = post.headPosition(),
      tail = post.tailPosition();
  assert.positionIsEqual(head.move(BACKWARD$3), head, 'head move left is head');
  assert.positionIsEqual(tail.move(FORWARD$3), tail, 'tail move right is tail');
});

test$B('#move can move multiple units', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('def')])
    ]);
  });

  let head = post.headPosition(),
      tail = post.tailPosition();

  assert.positionIsEqual(head.move(FORWARD$3 * ('abc'.length + 1 + 'def'.length)), tail, 'head can move to tail');
  assert.positionIsEqual(tail.move(BACKWARD$3 * ('abc'.length + 1 + 'def'.length)), head, 'tail can move to head');

  assert.positionIsEqual(head.move(0), head, 'move(0) is no-op');
});

test$B('#moveWord in text (backward)', (assert) => {
  let expectations = [
    ['abc def|', 'abc |def'],
    ['abc d|ef', 'abc |def'],
    ['abc |def', '|abc def'],
    ['abc| def', '|abc def'],
    ['|abc def', '|abc def'],
    ['abc-|', '|abc-'],
    ['abc|', '|abc'],
    ['ab|c', '|abc'],
    ['|abc', '|abc'],
    ['abc  |', '|abc'],
    ['abcdf|', '|abcdf']
  ];

  expectations.forEach(([before, after]) => {
    let { post, range: { head: pos } } = Helpers.postAbstract.buildFromText(before);
    let { range: { head: afterPos } } = Helpers.postAbstract.buildFromText(after);

    let expectedPos = post.sections.head.toPosition(afterPos.offset);
    assert.positionIsEqual(pos.moveWord(BACKWARD$3), expectedPos,
                           `move word "${before}"->"${after}"`);
  });
});

test$B('#moveWord stops on word-separators', (assert) => {
  let separators = ['-', '+', '=', '|'];
  separators.forEach(sep => {
    let text = `abc${sep}def`;
    let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
      return post([markupSection('p', [marker(text)])]);
    });
    let pos = post.tailPosition();
    let expectedPos = post.sections.head.toPosition('abc '.length);

    assert.positionIsEqual(pos.moveWord(BACKWARD$3), expectedPos, `move word <- "${text}|"`);
  });
});

test$B('#moveWord does not stop on non-word-separators', (assert) => {
  let nonSeparators = ['_', ':'];
  nonSeparators.forEach(sep => {
    let text = `abc${sep}def`;

    // Have to use `build` function here because "_" is a special char for `buildFromText`
    let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
      return post([markupSection('p', [marker(text)])]);
    });
    let pos = post.tailPosition();
    let nextPos = post.headPosition();

    assert.positionIsEqual(pos.moveWord(BACKWARD$3), nextPos, `move word <- "${text}|"`);
  });
});

test$B('#moveWord across markerable sections', (assert) => {
  let { post } = Helpers.postAbstract.buildFromText(['abc def', '123 456']);

  let [first, second] = post.sections.toArray();
  let pos = (section, text) => section.toPosition(text.length);
  let firstTail = first.tailPosition();
  let secondHead = second.headPosition();

  assert.positionIsEqual(secondHead.moveWord(BACKWARD$3), pos(first, 'abc '),
                         'secondHead <- "abc "');
  assert.positionIsEqual(firstTail.moveWord(FORWARD$3), pos(second, '123'),
                         'firstTail <- "123"');
});

test$B('#moveWord across markerable/non-markerable section boundaries', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, cardSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      cardSection('some-card'),
      markupSection('p', [marker('def')])
    ]);
  });

  let [before, card, after] = post.sections.toArray();
  let cardHead = card.headPosition();
  let cardTail = card.tailPosition();
  let beforeTail = before.tailPosition();
  let afterHead = after.headPosition();

  assert.positionIsEqual(cardHead.moveWord(BACKWARD$3), beforeTail,
                         'cardHead <- beforeTail');
  assert.positionIsEqual(cardHead.moveWord(FORWARD$3), cardTail,
                         'cardHead -> cardTail');
  assert.positionIsEqual(cardTail.moveWord(BACKWARD$3), cardHead,
                         'cardTail <- cardHead');
  assert.positionIsEqual(afterHead.moveWord(BACKWARD$3), cardHead,
                         'afterHead <- cardHead');
  assert.positionIsEqual(beforeTail.moveWord(FORWARD$3), cardTail,
                         'beforeTail -> cardTail');
});

test$B('#moveWord with atoms (backward)', (assert) => {
  let expectations = [
    ['abc @|', 'abc |@'],
    ['abc |@', '|abc @'],
    ['@|', '|@'],
    ['@  |', '@|  '],
    ['@@|', '@|@'],
    ['@|@', '|@@'],
    ['|@@', '|@@']
  ];

  expectations.forEach(([before, after]) => {
    let { post, range: { head: pos } } = Helpers.postAbstract.buildFromText(before);
    let { range: { head: nextPos } } = Helpers.postAbstract.buildFromText(after);
    let section = post.sections.head;
    nextPos = section.toPosition(nextPos.offset);

    assert.positionIsEqual(pos.moveWord(BACKWARD$3), nextPos,
                           `move word with atoms "${before}" -> "${after}"`);
  });
});

test$B('#moveWord in text (forward)', (assert) => {
  let expectations = [
    ['|abc def', 'abc| def'],
    ['a|bc def', 'abc| def'],
    ['abc| def', 'abc def|'],
    ['abc |def', 'abc def|'],
    ['abc def|', 'abc def|'],
    ['abc|', 'abc|'],
    ['ab|c', 'abc|'],
    ['|abc', 'abc|'],
    ['|  abc', '  abc|']
  ];

  expectations.forEach(([before, after]) => {
    let { post, range: { head: pos } } = Helpers.postAbstract.buildFromText(before);
    let { range: { head: nextPos } } = Helpers.postAbstract.buildFromText(after);
    let section = post.sections.head;
    nextPos = section.toPosition(nextPos.offset); // fix section

    assert.positionIsEqual(pos.moveWord(FORWARD$3), nextPos,
                           `move word "${before}"->"${after}"`);
  });
});

test$B('#moveWord with atoms (forward)', (assert) => {
  let expectations = [
    ['|@', '@|'],
    ['@|', '@|'],
    ['|  @', '  @|'],
    ['|  @ x', '  @ |x'],
    ['abc| @', 'abc @|'],
    ['|@@', '@|@'],
    ['@|@', '@@|'],
    ['@@|', '@@|']
  ];

  expectations.forEach(([before, after]) => {
    let { post, range: { head: pos } } = Helpers.postAbstract.buildFromText(before);
    let { range: { head: nextPos } } = Helpers.postAbstract.buildFromText(after);
    let section = post.sections.head;
    nextPos = section.toPosition(nextPos.offset);

    assert.positionIsEqual(pos.moveWord(FORWARD$3), nextPos,
                           `move word with atoms "${before}" -> "${after}"`);
  });
});

test$B('#fromNode when node is marker text node', (assert) => {
  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc'), marker('123')])]);
  });

  let textNode = editorElement$9.firstChild  // p
                              .lastChild; // textNode

  assert.equal(textNode.textContent, '123', 'precond - correct text node');

  let renderTree = editor$8._renderTree;
  let position = Position$1.fromNode(renderTree, textNode, 2);

  let section = editor$8.post.sections.head;
  assert.positionIsEqual(position, section.toPosition('abc'.length + 2));
});

test$B('#fromNode when node is section node with offset', (assert) => {
  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc'), marker('123')])]);
  });

  let pNode = editorElement$9.firstChild;
  assert.equal(pNode.tagName.toLowerCase(), 'p', 'precond - correct node');

  let renderTree = editor$8._renderTree;
  let position = Position$1.fromNode(renderTree, pNode, 0);

  assert.positionIsEqual(position, editor$8.post.sections.head.headPosition());
});

test$B('#fromNode when node is root element and offset is 0', (assert) => {
  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc'), marker('123')])]);
  });

  let renderTree = editor$8._renderTree;
  let position = Position$1.fromNode(renderTree, editorElement$9, 0);

  assert.positionIsEqual(position, editor$8.post.headPosition());
});

test$B('#fromNode when node is root element and offset is > 0', (assert) => {
  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc'), marker('123')])]);
  });

  let renderTree = editor$8._renderTree;
  let position = Position$1.fromNode(renderTree, editorElement$9, 1);

  assert.positionIsEqual(position, editor$8.post.tailPosition());
});

/**
 * On Firefox, triple-clicking results in a different selection that on Chrome
 * and others. Imagine we have the following content:
 *
 * <p>abc</p>
 *
 * Chrome:
 * anchorNode: <TextNode>
 * anchorOffset: 0
 * focusNode: <TextNode>
 * focusOffset: 3
 *
 * Firefox:
 * anchorNode: <p>
 * anchorOffset: 0
 * focusNode: <p>
 * focusOffset: 1
 *
 * So when getting the position for `focusNode`/`focusOffset`, we have to get
 * the tail of section.
 */
test$B('#fromNode when offset refers to one past the number of child nodes of the node', function(assert) {
  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  let renderTree = editor$8._renderTree;
  let elementNode = editorElement$9.firstChild;
  let position = Position$1.fromNode(renderTree, elementNode, 1);

  assert.positionIsEqual(position, editor$8.post.tailPosition());
});

test$B('#fromNode when node is card section element or next to it', (assert) => {
  let editorOptions = { cards: [{
    name: 'some-card',
    type: 'dom',
    render() {
      return $('<div id="the-card">this is the card</div>')[0];
    }
  }]};
  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, cardSection}) => {
    return post([cardSection('some-card')]);
  }, editorOptions);

  let nodes = {
    wrapper:     editorElement$9.firstChild,
    leftCursor:  editorElement$9.firstChild.firstChild,
    rightCursor: editorElement$9.firstChild.lastChild,
    cardDiv:     editorElement$9.firstChild.childNodes[1]
  };

  assert.ok(nodes.wrapper && nodes.leftCursor && nodes.rightCursor &&
            nodes.cardDiv,
            'precond - nodes');

  assert.equal(nodes.wrapper.tagName.toLowerCase(), 'div', 'precond - wrapper');
  assert.equal(nodes.leftCursor.textContent, ZWNJ, 'precond - left cursor');
  assert.equal(nodes.rightCursor.textContent, ZWNJ, 'precond - right cursor');
  assert.ok(nodes.cardDiv.className.indexOf(CARD_ELEMENT_CLASS_NAME) !== -1,
            'precond -card div');

  let renderTree = editor$8._renderTree;
  let cardSection = editor$8.post.sections.head;

  let leftPos  = cardSection.headPosition();
  let rightPos = cardSection.tailPosition();

  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.wrapper, 0),
                         leftPos, 'wrapper offset 0');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.wrapper, 1),
                         leftPos, 'wrapper offset 1');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.wrapper, 2),
                         rightPos, 'wrapper offset 2');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.leftCursor, 0),
                         leftPos, 'left cursor offset 0');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.leftCursor, 1),
                         leftPos, 'left cursor offset 1');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.rightCursor, 0),
                         rightPos, 'right cursor offset 0');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.rightCursor, 1),
                         rightPos, 'right cursor offset 1');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.cardDiv, 0),
                         leftPos, 'card div offset 0');
  assert.positionIsEqual(Position$1.fromNode(renderTree, nodes.cardDiv, 1),
                         leftPos, 'card div offset 1');
});

/**
 * When triple-clicking text in a disabled editor, some browsers will
 * expand the selection to include the start of a node outside the editor.
 * See: https://github.com/bustle/mobiledoc-kit/issues/486
 *
 * Chrome and Safari appear to extend the selection to the next node in the document
 * that has a textNode in it. Firefox does not suffer from this issue.
 */
test$B('#fromNode when selection is outside (after) the editor element', function(assert) {
  let done = assert.async();
  let div$ = $('<div><p>AFTER</p></div>').insertAfter($(editorElement$9));
  let p = div$[0].firstChild;

  editor$8 = Helpers.mobiledoc.renderInto(editorElement$9,
    ({post, markupSection, marker}) => post([markupSection('p', [marker('abcdef')])])
  );

  // If the editor isn't disabled, some browsers will "fix" the selection range we are
  // about to add by constraining it within the contentEditable container div
  editor$8.disableEditing();

  let anchorNode = $(editorElement$9).find('p:contains(abcdef)')[0].firstChild;
  let focusNode = p;
  Helpers.dom.selectRange(anchorNode, 0, focusNode, 0);

  Helpers.wait(() => {
    assert.ok(window.getSelection().anchorNode === anchorNode, 'precond - anchor node');
    assert.ok(window.getSelection().focusNode === focusNode, 'precond - focus node');
    let range = editor$8.range;

    assert.positionIsEqual(range.head, editor$8.post.headPosition(), 'head');
    assert.positionIsEqual(range.tail, editor$8.post.tailPosition(), 'tail');

    div$.remove();
    done();
  });
});

test$B('Position cannot be on list section', (assert) => {
  let post = Helpers.postAbstract.build(({post, listSection, listItem}) => {
    return post([listSection('ul', [listItem()])]);
  });

  let listSection = post.sections.head;
  let listItem = listSection.items.head;

  let position;
  assert.throws(() => {
    position = listSection.toPosition(0);
  }, /addressable by the cursor/);

  position = listItem.toPosition(0);
  assert.ok(position, 'position with list item is ok');
});

const { FORWARD: FORWARD$4, BACKWARD: BACKWARD$4 } = DIRECTION;
const {module: module$C, test: test$C} = Helpers;

module$C('Unit: Utils: Range');

test$C('#trimTo(section) when range covers only one section', (assert) => {
  const section = Helpers.postAbstract.build(({markupSection}) => markupSection());
  const range = Range.create(section, 0, section, 5);

  const newRange = range.trimTo(section);
  assert.ok(newRange.head.section === section, 'head section is correct');
  assert.ok(newRange.tail.section === section, 'tail section is correct');
  assert.equal(newRange.head.offset, 0, 'head offset');
  assert.equal(newRange.tail.offset, 0, 'tail offset');
});

test$C('#trimTo head section', (assert) => {
  const text = 'abcdef';
  const section1 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));
  const section2 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));

  const range = Range.create(section1, 0, section2, 5);
  const newRange = range.trimTo(section1);

  assert.ok(newRange.head.section === section1, 'head section');
  assert.ok(newRange.tail.section === section1, 'tail section');
  assert.equal(newRange.head.offset, 0, 'head offset');
  assert.equal(newRange.tail.offset, text.length, 'tail offset');
});

test$C('#trimTo tail section', (assert) => {
  const text = 'abcdef';
  const section1 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));
  const section2 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));

  const range = Range.create(section1, 0, section2, 5);
  const newRange = range.trimTo(section2);

  assert.ok(newRange.head.section === section2, 'head section');
  assert.ok(newRange.tail.section === section2, 'tail section');
  assert.equal(newRange.head.offset, 0, 'head offset');
  assert.equal(newRange.tail.offset, 5, 'tail offset');
});

test$C('#trimTo middle section', (assert) => {
  const text = 'abcdef';
  const section1 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));
  const section2 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));
  const section3 = Helpers.postAbstract.build(
    ({markupSection, marker}) => markupSection('p', [marker(text)]));

  const range = Range.create(section1, 0, section3, 5);
  const newRange = range.trimTo(section2);

  assert.ok(newRange.head.section === section2, 'head section');
  assert.ok(newRange.tail.section === section2, 'tail section');
  assert.equal(newRange.head.offset, 0, 'head offset');
  assert.equal(newRange.tail.offset, section2.text.length, 'tail offset');
});

test$C('#move moves collapsed range 1 character in direction', (assert) => {
  let section = Helpers.postAbstract.build(({markupSection, marker}) => {
    return markupSection('p', [marker('abc')]);
  });
  let range = Range.create(section, 0);
  let nextRange = Range.create(section, 1);

  assert.ok(range.isCollapsed, 'precond - range.isCollapsed');
  assert.rangeIsEqual(range.move(DIRECTION.FORWARD), nextRange, 'move forward');

  assert.rangeIsEqual(nextRange.move(DIRECTION.BACKWARD), range, 'move backward');
});

test$C('#move collapses non-collapsd range in direction', (assert) => {
  let section = Helpers.postAbstract.build(({markupSection, marker}) => {
    return markupSection('p', [marker('abcd')]);
  });
  let range = Range.create(section, 1, section, 3);
  let collapseForward = Range.create(section, 3);
  let collapseBackward = Range.create(section, 1);

  assert.ok(!range.isCollapsed, 'precond - !range.isCollapsed');
  assert.rangeIsEqual(range.move(FORWARD$4), collapseForward,
                      'collapse forward');
  assert.rangeIsEqual(range.move(BACKWARD$4), collapseBackward,
                      'collapse forward');
});

test$C('#extend expands range in direction', (assert) => {
  let section = Helpers.postAbstract.build(({markupSection, marker}) => {
    return markupSection('p', [marker('abcd')]);
  });
  let collapsedRange = Range.create(section, 1);
  let collapsedRangeForward = Range.create(section, 1, section, 2, FORWARD$4);
  let collapsedRangeBackward = Range.create(section, 0, section, 1, BACKWARD$4);

  let nonCollapsedRange = Range.create(section, 1, section, 2);
  let nonCollapsedRangeForward = Range.create(section, 1, section, 3, FORWARD$4);
  let nonCollapsedRangeBackward = Range.create(section, 0, section, 2, BACKWARD$4);

  assert.ok(collapsedRange.isCollapsed, 'precond - collapsedRange.isCollapsed');
  assert.rangeIsEqual(collapsedRange.extend(FORWARD$4), collapsedRangeForward,
                      'collapsedRange extend forward');
  assert.rangeIsEqual(collapsedRange.extend(BACKWARD$4), collapsedRangeBackward,
                      'collapsedRange extend backward');

  assert.ok(!nonCollapsedRange.isCollapsed, 'precond -nonCollapsedRange.isCollapsed');
  assert.rangeIsEqual(nonCollapsedRange.extend(FORWARD$4), nonCollapsedRangeForward,
                      'nonCollapsedRange extend forward');
  assert.rangeIsEqual(nonCollapsedRange.extend(BACKWARD$4), nonCollapsedRangeBackward,
                      'nonCollapsedRange extend backward');
});

test$C('#extend expands range in multiple units in direction', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abcd')]),
      markupSection('p', [marker('1234')])
    ]);
  });

  let headSection = post.sections.head;
  let tailSection = post.sections.tail;

  // FORWARD
  let collapsedRange = Range.create(headSection, 0);
  let nonCollapsedRange = Range.create(headSection, 0, headSection, 1);
  assert.rangeIsEqual(collapsedRange.extend(FORWARD$4*2),
                      Range.create(headSection, 0, headSection, 2, FORWARD$4),
                      'extend forward 2');

  assert.rangeIsEqual(collapsedRange.extend(FORWARD$4*('abcd12'.length+1)),
                      Range.create(headSection, 0, tailSection, 2, FORWARD$4),
                      'extend forward across sections');

  assert.rangeIsEqual(nonCollapsedRange.extend(FORWARD$4*2),
                      Range.create(headSection, 0, headSection, 3, FORWARD$4),
                      'extend non-collapsed forward 2');

  assert.rangeIsEqual(nonCollapsedRange.extend(FORWARD$4*('bcd12'.length+1)),
                      Range.create(headSection, 0, tailSection, 2, FORWARD$4),
                      'extend non-collapsed across sections');

  // BACKWARD
  collapsedRange = Range.create(tailSection, '1234'.length);
  nonCollapsedRange = Range.create(tailSection, '12'.length, tailSection, '1234'.length);
  assert.rangeIsEqual(collapsedRange.extend(BACKWARD$4*'12'.length),
                      Range.create(tailSection, '12'.length, tailSection, '1234'.length, BACKWARD$4),
                      'extend backward 2');

  assert.rangeIsEqual(collapsedRange.extend(BACKWARD$4*('1234cd'.length+1)),
                      Range.create(headSection, 'ab'.length, tailSection, '1234'.length, BACKWARD$4),
                      'extend backward across sections');

  assert.rangeIsEqual(nonCollapsedRange.extend(BACKWARD$4*2),
                      Range.create(tailSection, 0, tailSection, '1234'.length, BACKWARD$4),
                      'extend non-collapsed backward 2');

  assert.rangeIsEqual(nonCollapsedRange.extend(BACKWARD$4*('bcd12'.length+1)),
                      Range.create(headSection, 'a'.length, tailSection, '1234'.length, BACKWARD$4),
                      'extend non-collapsed backward across sections');
});

test$C('#extend(0) returns same range', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abcd')]),
      markupSection('p', [marker('1234')])
    ]);
  });

  let headSection = post.sections.head;

  let collapsedRange = Range.create(headSection, 0);
  let nonCollapsedRange = Range.create(headSection, 0, headSection, 1);

  assert.rangeIsEqual(collapsedRange.extend(0), collapsedRange, 'extending collapsed range 0 is no-op');
  assert.rangeIsEqual(nonCollapsedRange.extend(0), nonCollapsedRange, 'extending non-collapsed range 0 is no-op');
});

test$C('#expandByMarker processed markers in a callback and continues as long as the callback returns true', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    let bold = markup('b');
    let italic = markup('i');
    return post([
      markupSection('p', [
        marker('aiya', []),
        marker('biya', [bold, italic]),
        marker('ciya', [bold]),
        marker('diya', [bold]),
      ])
    ]);
  });

  let section = post.sections.head;
  let head = section.toPosition(9); // i in the third hiya
  let tail = section.toPosition(15); // y in the last hiya
  let range = head.toRange(tail);
  let expandedRange = range.expandByMarker(marker => {
    return !!(detect(marker.markups, markup => markup.tagName === 'b'));
  });

  assert.positionIsEqual(
    expandedRange.head, section.toPosition(4),
    'range head is start of second marker'
  );
  assert.positionIsEqual(
    expandedRange.tail, section.toPosition(16),
    'range tail did not change'
  );
});

// https://github.com/bustle/mobiledoc-kit/issues/676
test$C('#expandByMarker can expand to beginning of section with matching markups', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    let bold = markup('b');
    let italic = markup('i');
    return post([
      markupSection('p', [
        marker('aiya', [bold]),
        marker('biya', [bold, italic]),
        marker('ciya', [bold]),
        marker('diya', [bold]),
      ])
    ]);
  });

  let section = post.sections.head;
  let head = section.toPosition(14); // i in 4th hiya
  let tail = section.toPosition(14); // i in 4th hiya
  let range = head.toRange(tail);
  let expandedRange = range.expandByMarker(marker => {
    return !!(detect(marker.markups, markup => markup.tagName === 'b'));
  });

  assert.positionIsEqual(
    expandedRange.head, section.toPosition(0),
    'range head is start of first marker'
  );
  assert.positionIsEqual(
    expandedRange.tail, section.toPosition(16),
    'range tail is at end of last marker'
  );
});

test$C('#expandByMarker can expand to end of section with matching markups', (assert) => {
  let post = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
    let bold = markup('b');
    let italic = markup('i');
    return post([
      markupSection('p', [
        marker('aiya', [bold]),
        marker('biya', [bold, italic]),
        marker('ciya', [bold]),
        marker('diya', [bold]),
      ])
    ]);
  });

  let section = post.sections.head;
  let head = section.toPosition(2); // i in 4th hiya
  let tail = section.toPosition(2); // i in 4th hiya
  let range = head.toRange(tail);
  let expandedRange = range.expandByMarker(marker => {
    return !!(detect(marker.markups, markup => markup.tagName === 'b'));
  });

  assert.positionIsEqual(
    expandedRange.head, section.toPosition(0),
    'range head is start of first marker'
  );
  assert.positionIsEqual(
    expandedRange.tail, section.toPosition(16),
    'range tail is at end of last marker'
  );
});

const {module: module$D, test: test$D} = Helpers;

module$D('Unit: Utils: FixedQueue');

test$D('basic implementation', (assert) => {
  let queue = new FixedQueue(3);
  for (let i=0; i < 3; i++) {
    queue.push(i);
  }

  assert.equal(queue.length, 3);

  let popped = [];
  while (queue.length) {
    popped.push(queue.pop());
  }

  assert.deepEqual(popped, [2,1,0]);
});

test$D('empty queue', (assert) => {
  let queue = new FixedQueue(0);
  assert.equal(queue.length, 0);
  assert.equal(queue.pop(), undefined);
  queue.push(1);

  assert.equal(queue.length, 0);
  assert.deepEqual(queue.toArray(), []);
});

test$D('push onto full queue ejects first item', (assert) => {
  let queue = new FixedQueue(1);
  queue.push(0);
  queue.push(1);

  assert.deepEqual(queue.toArray(), [1]);
});

const {module: module$E, test: test$E} = Helpers;

module$E('Unit: Utils: Key');

test$E('#hasModifier with no modifier', (assert) => {
  const event = Helpers.dom.createMockEvent('keydown', null, { keyCode: 42 });
  const key = Key.fromEvent(event);

  assert.ok(!key.hasModifier(MODIFIERS.META), "META not pressed");
  assert.ok(!key.hasModifier(MODIFIERS.CTRL), "CTRL not pressed");
  assert.ok(!key.hasModifier(MODIFIERS.SHIFT), "SHIFT not pressed");
});

test$E('#hasModifier with META', (assert) => {
  const event = Helpers.dom.createMockEvent('keyup', null, { metaKey: true });
  const key = Key.fromEvent(event);

  assert.ok(key.hasModifier(MODIFIERS.META), "META pressed");
  assert.ok(!key.hasModifier(MODIFIERS.CTRL), "CTRL not pressed");
  assert.ok(!key.hasModifier(MODIFIERS.SHIFT), "SHIFT not pressed");
});

test$E('#hasModifier with CTRL', (assert) => {
  const event = Helpers.dom.createMockEvent('keypress', null, { ctrlKey: true });
  const key = Key.fromEvent(event);

  assert.ok(!key.hasModifier(MODIFIERS.META), "META not pressed");
  assert.ok(key.hasModifier(MODIFIERS.CTRL), "CTRL pressed");
  assert.ok(!key.hasModifier(MODIFIERS.SHIFT), "SHIFT not pressed");
});

test$E('#hasModifier with SHIFT', (assert) => {
  const event = Helpers.dom.createMockEvent('keydown', null, { shiftKey: true });
  const key = Key.fromEvent(event);

  assert.ok(!key.hasModifier(MODIFIERS.META), "META not pressed");
  assert.ok(!key.hasModifier(MODIFIERS.CTRL), "CTRL not pressed");
  assert.ok(key.hasModifier(MODIFIERS.SHIFT), "SHIFT pressed");
});

// Firefox will fire keypress events for some keys that should not be printable
test$E('firefox: non-printable are treated as not printable', (assert) => {
  const KEYS = [
    Keys.DOWN,
    Keys.HOME,
    Keys.END,
    Keys.PAGEUP,
    Keys.PAGEDOWN,
    Keys.INS,
    Keys.CLEAR,
    Keys.PAUSE,
    Keys.ESC
  ];

  KEYS.forEach((key) => {
    let element = $('#qunit-fixture')[0];
    let event = Helpers.dom.createMockEvent('keypress', element, {
      key,
    });
    let keyInstance = Key.fromEvent(event);

    assert.ok(!keyInstance.isPrintable(), `key ${key} is not printable`);
  });
});

test$E('uses keyCode as a fallback if key is not supported', (assert) => {
  let element = $('#qunit-fixture')[0];

  let event = Helpers.dom.createMockEvent('keypress', element, {
    key: Keys.ESC,
    keyCode: Keycodes.SPACE
  });
  let keyInstance = Key.fromEvent(event);
  assert.ok(
    keyInstance.isEscape(),
    'key is preferred over keyCode if supported'
  );

  event = Helpers.dom.createMockEvent('keypress', element, {
    keyCode: Keycodes.SPACE
  });
  keyInstance = Key.fromEvent(event);
  assert.ok(
    keyInstance.isSpace(),
    'keyCode is used if key is not supported'
  );
});

const {module: module$F, test: test$F} = Helpers;

const INSERTION_METHODS = ['append', 'prepend', 'insertBefore', 'insertAfter'];

module$F('Unit: Utils: LinkedList');

test$F('initial state', (assert) => {
  let list = new LinkedList();
  assert.equal(list.head, null, 'head is null');
  assert.equal(list.tail, null ,'tail is null');
  assert.equal(list.length, 0, 'length is one');
  assert.equal(list.isEmpty, true, 'isEmpty is true');
});

INSERTION_METHODS.forEach(method => {
  test$F(`#${method} initial item`, (assert) => {
    let list = new LinkedList();
    let item = new LinkedItem();
    list[method](item);
    assert.equal(list.length, 1, 'length is one');
    assert.equal(list.isEmpty, false, 'isEmpty is false');
    assert.equal(list.head, item, 'head is item');
    assert.equal(list.tail, item, 'tail is item');
    assert.equal(item.next, null, 'item next is null');
    assert.equal(item.prev, null, 'item prev is null');
  });

  test$F(`#${method} calls adoptItem`, (assert) => {
    let adoptedItem;
    let list = new LinkedList({
      adoptItem(item) {
        adoptedItem = item;
      }
    });
    let item = new LinkedItem();
    list[method](item);
    assert.equal(adoptedItem, item, 'item is adopted');
  });

  test$F(`#${method} throws when inserting item that is already in this list`, (assert) => {
    let list = new LinkedList();
    let item = new LinkedItem();
    list[method](item);

    assert.throws(
      () => list[method](item),
      /Cannot insert.*already in a list/
    );
  });

  test$F(`#${method} throws if item is in another list`, (assert) => {
    let [list, otherList] = [new LinkedList(), new LinkedList()];
    let [item, otherItem] = [new LinkedItem(), new LinkedItem()];
    list[method](item);
    otherList[method](otherItem);

    assert.throws(
      () => list[method](otherItem),
      /Cannot insert.*already in a list/
    );
  });
});

test$F(`#append second item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  assert.equal(list.length, 2, 'length is two');
  assert.equal(list.head, itemOne, 'head is itemOne');
  assert.equal(list.tail, itemTwo, 'tail is itemTwo');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');
  assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');
  assert.equal(itemTwo.next, null, 'itemTwo next is null');
});

test$F(`#prepend additional item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  list.prepend(itemTwo);
  list.prepend(itemOne);
  assert.equal(list.length, 2, 'length is two');
  assert.equal(list.head, itemOne, 'head is itemOne');
  assert.equal(list.tail, itemTwo, 'tail is itemTwo');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');
  assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');
  assert.equal(itemTwo.next, null, 'itemTwo next is null');
});

test$F(`#insertBefore a middle item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.prepend(itemOne);
  list.append(itemThree);
  list.insertBefore(itemTwo, itemThree);
  assert.equal(list.length, 3, 'length is three');
  assert.equal(list.head, itemOne, 'head is itemOne');
  assert.equal(list.tail, itemThree, 'tail is itemThree');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');
  assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');
  assert.equal(itemTwo.next, itemThree, 'itemTwo next is itemThree');
  assert.equal(itemThree.prev, itemTwo, 'itemThree prev is itemTwo');
  assert.equal(itemThree.next, null, 'itemThree next is null');
});

test$F('#insertBefore null reference item appends the item', (assert) => {
  let list = new LinkedList();
  let item1 = new LinkedItem();
  let item2 = new LinkedItem();
  list.append(item1);
  list.insertBefore(item2, null);

  assert.equal(list.length, 2);
  assert.equal(list.tail, item2, 'item2 is appended');
  assert.equal(list.head, item1, 'item1 is at head');
  assert.equal(item2.prev, item1, 'item2.prev');
  assert.equal(item1.next, item2, 'item1.next');
  assert.equal(item2.next, null);
  assert.equal(item1.prev, null);
});

test$F(`#insertAfter a middle item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.prepend(itemOne);
  list.append(itemThree);
  list.insertAfter(itemTwo, itemOne);

  assert.equal(list.length, 3);
  assert.equal(list.head, itemOne, 'head is itemOne');
  assert.equal(list.tail, itemThree, 'tail is itemThree');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, itemTwo, 'itemOne next is itemTwo');
  assert.equal(itemTwo.prev, itemOne, 'itemTwo prev is itemOne');
  assert.equal(itemTwo.next, itemThree, 'itemTwo next is itemThree');
  assert.equal(itemThree.prev, itemTwo, 'itemThree prev is itemTwo');
  assert.equal(itemThree.next, null, 'itemThree next is null');
});

test$F('#insertAfter null reference item prepends the item', (assert) => {
  let list = new LinkedList();
  let item1 = new LinkedItem();
  let item2 = new LinkedItem();
  list.append(item2);
  list.insertAfter(item1, null);

  assert.equal(list.length, 2);
  assert.equal(list.head, item1,  'item2 is appended');
  assert.equal(list.tail, item2,  'item1 is at tail');
  assert.equal(item1.next, item2, 'item1.next = item2');
  assert.equal(item1.prev, null,  'item1.prev = null');
  assert.equal(item2.prev, item1, 'item2.prev = item1');
  assert.equal(item2.next, null,  'item2.next = null');
});

test$F(`#remove an only item`, (assert) => {
  let list = new LinkedList();
  let item = new LinkedItem();
  list.append(item);
  list.remove(item);
  assert.equal(list.length, 0, 'length is zero');
  assert.equal(list.isEmpty, true, 'isEmpty is true');
  assert.equal(list.head, null, 'head is null');
  assert.equal(list.tail, null, 'tail is null');
  assert.equal(item.prev, null, 'item prev is null');
  assert.equal(item.next, null, 'item next is null');
});

test$F(`#remove calls freeItem`, (assert) => {
  let freed = [];
  let list = new LinkedList({
    freeItem(item) {
      freed.push(item);
    }
  });
  let item = new LinkedItem();
  list.append(item);
  list.remove(item);
  assert.deepEqual(freed, [item]);
});

test$F(`#remove a first item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.remove(itemOne);

  assert.equal(list.length, 1);
  assert.equal(list.head, itemTwo, 'head is itemTwo');
  assert.equal(list.tail, itemTwo, 'tail is itemTwo');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, null, 'itemOne next is null');
  assert.equal(itemTwo.prev, null, 'itemTwo prev is null');
  assert.equal(itemTwo.next, null, 'itemTwo next is null');
});

test$F(`#remove a last item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.remove(itemTwo);
  assert.equal(list.length, 1);
  assert.equal(list.head, itemOne, 'head is itemOne');
  assert.equal(list.tail, itemOne, 'tail is itemOne');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, null, 'itemOne next is null');
  assert.equal(itemTwo.prev, null, 'itemTwo prev is null');
  assert.equal(itemTwo.next, null, 'itemTwo next is null');
});

test$F(`#remove a middle item`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  list.remove(itemTwo);

  assert.equal(list.length, 2);
  assert.equal(list.head, itemOne, 'head is itemOne');
  assert.equal(list.tail, itemThree, 'tail is itemThree');
  assert.equal(itemOne.prev, null, 'itemOne prev is null');
  assert.equal(itemOne.next, itemThree, 'itemOne next is itemThree');
  assert.equal(itemTwo.prev, null, 'itemTwo prev is null');
  assert.equal(itemTwo.next, null, 'itemTwo next is null');
  assert.equal(itemThree.prev, itemOne, 'itemThree prev is itemOne');
  assert.equal(itemThree.next, null, 'itemThree next is null');
});

test$F(`#remove item that is not in the list is no-op`, (assert) => {
  let list = new LinkedList();
  let otherItem = new LinkedItem();

  list.remove(otherItem);
  assert.equal(list.length, 0);
});

test$F(`#remove throws if item is in another list`, (assert) => {
  let list      = new LinkedList();
  let otherList = new LinkedList();
  let otherItem = new LinkedItem();
  
  otherList.append(otherItem);

  assert.throws(
    () => list.remove(otherItem),
    /Cannot remove.*other list/
  );
});

test$F(`#forEach iterates many`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  let items = [];
  let indexes = [];
  list.forEach((item, index) => {
    items.push(item);
    indexes.push(index);
  });
  assert.deepEqual(items, [itemOne, itemTwo, itemThree], 'items correct');
  assert.deepEqual(indexes, [0, 1, 2], 'indexes correct');
});

test$F(`#forEach iterates one`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  list.append(itemOne);
  let items = [];
  let indexes = [];
  list.forEach((item, index) => {
    items.push(item);
    indexes.push(index);
  });
  assert.deepEqual(items, [itemOne], 'items correct');
  assert.deepEqual(indexes, [0], 'indexes correct');
});

test$F('#forEach exits early if item is removed by callback', (assert) => {
  let list = new LinkedList();
  [0,1,2].forEach(val => {
    let i = new LinkedItem();
    i.value = val;
    list.append(i);
  });

  let iterated = [];
  list.forEach((item, index) => {
    iterated.push(item.value);
    if (index === 1) {
      list.remove(item); // iteration stops, skipping value 2
    }
  });

  assert.deepEqual(iterated, [0,1], 'iteration stops when item.next is null');
});

test$F(`#readRange walks from start to end`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  list.forEach((item, index) => {
  });
  assert.deepEqual(list.readRange(itemOne, itemOne), [itemOne], 'items correct');
  assert.deepEqual(list.readRange(itemTwo, itemThree), [itemTwo, itemThree], 'items correct');
  assert.deepEqual(list.readRange(itemOne, itemTwo), [itemOne, itemTwo], 'items correct');
  assert.deepEqual(list.readRange(itemOne, null), [itemOne, itemTwo, itemThree], 'items correct');
});

test$F(`#toArray builds array`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  list.append(itemOne);
  assert.deepEqual(list.toArray(), [itemOne], 'items correct');
});

test$F(`#toArray builds many array`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  assert.deepEqual(list.toArray(), [itemOne, itemTwo, itemThree], 'items correct');
});

test$F(`#detect finds`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  assert.equal(list.detect(item => item === itemOne), itemOne, 'itemOne detected');
  assert.equal(list.detect(item => item === itemTwo), itemTwo, 'itemTwo detected');
  assert.equal(list.detect(item => item === itemThree), itemThree, 'itemThree detected');
  assert.equal(list.detect(() => false), undefined, 'no item detected');
});

test$F(`#detect finds w/ start`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  assert.equal(list.detect(item => item === itemOne, itemOne), itemOne, 'itemOne detected');
  assert.equal(list.detect(item => item === itemTwo, itemThree), null, 'no item detected');
});

test$F(`#detect finds w/ reverse`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);
  assert.equal(list.detect(item => item === itemOne, itemOne, true), itemOne, 'itemTwo detected');
  assert.equal(list.detect(item => item === itemThree, itemThree, true), itemThree, 'itemThree');
});

test$F(`#objectAt looks up by index`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  list.append(itemOne);
  assert.equal(list.objectAt(0), itemOne, 'itemOne looked up');

  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemTwo);
  list.append(itemThree);
  assert.equal(list.objectAt(0), itemOne, 'itemOne looked up');
  assert.equal(list.objectAt(1), itemTwo, 'itemTwo looked up');
  assert.equal(list.objectAt(2), itemThree, 'itemThree looked up');
});

test$F(`#splice removes a target and inserts an array of items`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemThree);

  list.splice(itemOne, 1, [itemTwo]);

  assert.equal(list.head, itemTwo, 'itemOne is head');
  assert.equal(list.objectAt(1), itemThree, 'itemThree is present');
});

test$F(`#splice remove nothing and inserts an array of nothing`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);

  list.splice(itemTwo, 0, []);

  assert.equal(list.head, itemOne, 'itemOne is head');
  assert.equal(list.objectAt(1), itemTwo, 'itemTwo is present');
});

test$F(`#splice can reorganize items`, (assert) => {
  let list = new LinkedList();
  let itemOne = new LinkedItem();
  let itemTwo = new LinkedItem();
  let itemThree = new LinkedItem();
  list.append(itemOne);
  list.append(itemTwo);
  list.append(itemThree);

  list.splice(itemOne, 3, [itemThree, itemOne, itemTwo]);

  assert.equal(list.head, itemThree, 'itemThree is head');
  assert.equal(list.objectAt(1), itemOne, 'itemOne is present');
  assert.equal(list.objectAt(2), itemTwo, 'itemTwo is present');
});

test$F(`#removeBy mutates list when item is in middle`, (assert) => {
  let list = new LinkedList();
  let items = [
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem()
  ];
  items[1].shouldRemove = true;
  items.forEach(i => list.append(i));

  assert.equal(list.length, 4);
  list.removeBy(i => i.shouldRemove);
  assert.equal(list.length, 3);
  assert.equal(list.head, items[0]);
  assert.equal(list.objectAt(1), items[2]);
  assert.equal(list.objectAt(2), items[3]);
  assert.equal(list.tail, items[3]);
});

test$F(`#removeBy mutates list when item is first`, (assert) => {
  let list = new LinkedList();
  let items = [
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem()
  ];
  items[0].shouldRemove = true;
  items.forEach(i => list.append(i));

  assert.equal(list.length, 4);
  list.removeBy(i => i.shouldRemove);
  assert.equal(list.length, 3);
  assert.equal(list.head, items[1]);
  assert.equal(list.objectAt(1), items[2]);
  assert.equal(list.tail, items[3]);
});

test$F(`#removeBy mutates list when item is last`, (assert) => {
  let list = new LinkedList();
  let items = [
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem()
  ];
  items[3].shouldRemove = true;
  items.forEach(i => list.append(i));

  assert.equal(list.length, 4);
  list.removeBy(i => i.shouldRemove);
  assert.equal(list.length, 3);
  assert.equal(list.head, items[0]);
  assert.equal(list.objectAt(1), items[1]);
  assert.equal(list.tail, items[2]);
});

test$F('#removeBy calls `freeItem` for each item removed', (assert) => {
  let freed = [];

  let list = new LinkedList({
    freeItem(item) {
      freed.push(item);
    }
  });

  let items = [
    new LinkedItem(),
    new LinkedItem(),
    new LinkedItem()
  ];
  items[0].name = '0';
  items[1].name = '1';
  items[2].name = '2';

  items[0].shouldRemove = true;
  items[1].shouldRemove = true;

  items.forEach(i => list.append(i));

  list.removeBy(i => i.shouldRemove);

  assert.deepEqual(freed, [items[0], items[1]]);
});

test$F('#every', (assert) => {
  let list = new LinkedList();
  [2,3,4].forEach(n => list.append({val: n}));

  assert.ok(list.every(i => i.val > 0), '> 0');
  assert.ok(!list.every(i => i.val % 2 === 0), 'even');
});

const { module: module$G, test: test$G } = Helpers;

module$G('Unit: Utils: Object Utils');

test$G('#entries works', assert => {
  assert.deepEqual(entries({ hello: 'world', goodbye: 'moon' }), [
    ['hello', 'world'],
    ['goodbye', 'moon']
  ]);
});

const {module: module$H, test: test$H} = Helpers;

module$H('Unit: Utils: Parse Utils');

test$H('#getContentFromPasteEvent reads from clipboardData', (assert) => {
  let element = null;
  let expected = {
    [MIME_TEXT_PLAIN]: 'text',
    [MIME_TEXT_HTML]: '<p>html</p>'
  };
  let event = Helpers.dom.createMockEvent('paste', element, {
    clipboardData: {
      getData(type) {
        return expected[type];
      }
    }
  });
  let mockWindow = {
    clipboardData: {
      getData() {
        assert.ok(false, 'should not get clipboard data from window');
      }
    }
  };

  let { html, text } = getContentFromPasteEvent(event, mockWindow);

  assert.equal(html, expected[MIME_TEXT_HTML], 'correct html');
  assert.equal(text, expected[MIME_TEXT_PLAIN], 'correct text');
});

test$H('#getContentFromPasteEvent reads data from window.clipboardData when event.clipboardData is not present (IE compat)', (assert) => {
  assert.expect(3);
  let element = null;
  let event = Helpers.dom.createMockEvent('paste', element, {clipboardData:null});
  let requestedType;
  let expectedHTML = 'hello';
  let expectedText = '';
  let mockWindow = {
    clipboardData: {
      getData(type) {
        requestedType = type;
        return expectedHTML;
      }
    }
  };

  let { html, text } = getContentFromPasteEvent(event, mockWindow);

  assert.equal(requestedType, NONSTANDARD_IE_TEXT_TYPE, 'requests IE nonstandard mime type');
  assert.equal(html, expectedHTML, 'correct html');
  assert.equal(text, expectedText, 'correct text');
});

test$H('#setClipboardData uses event.clipboardData.setData when available', (assert) => {
  let element = null;
  let setData = {};
  let data = {
    html: '<p>html</p>',
    text: 'text'
  };
  let event = Helpers.dom.createMockEvent('copy', element, {
    clipboardData: {
      setData(type, value) {
        setData[type] = value;
      }
    }
  });
  let mockWindow = {
    clipboardData: {
      setData() {
        assert.ok(false, 'should not set clipboard data on window');
      }
    }
  };

  setClipboardData(event, data, mockWindow);

  assert.equal(setData[MIME_TEXT_HTML], data.html);
  assert.equal(setData[MIME_TEXT_PLAIN], data.text);
});

test$H('#setClipboardData uses window.clipboardData.setData when event.clipboardData not present (IE compat)', (assert) => {
  let element = null;
  let setData = {};
  let data = {
    html: '<p>html</p>',
    text: 'text'
  };
  let event = Helpers.dom.createMockEvent('paste', element, {
    clipboardData: null
  });
  let mockWindow = {
    clipboardData: {
      setData(type, value) {
        setData[type] = value;
      }
    }
  };

  setClipboardData(event, data, mockWindow);

  assert.equal(setData[NONSTANDARD_IE_TEXT_TYPE], data.html, 'sets NONSTANDARD_IE_TEXT_TYPE type');
  assert.ok(!setData[MIME_TEXT_HTML], 'does not set MIME_TEXT_HTML');
  assert.ok(!setData[MIME_TEXT_PLAIN], 'does not set MIME_TEXT_PLAIN');
});

const {module: module$I, test: test$I} = Helpers;

module$I('Unit: Utils: Selection Utils');

test$I('#comparePosition returns the forward direction of selection', (assert) => {
  let div = document.createElement('div');
  div.innerHTML = 'Howdy';
  let selection = {
    anchorNode: div,
    anchorOffset: 0,
    focusNode: div,
    focusOffset: 1
  };
  let result = comparePosition(selection);
  assert.equal(DIRECTION.FORWARD, result.direction);
});

test$I('#comparePosition returns the backward direction of selection', (assert) => {
  let div = document.createElement('div');
  div.innerHTML = 'Howdy';
  let selection = {
    anchorNode: div,
    anchorOffset: 1,
    focusNode: div,
    focusOffset: 0
  };
  let result = comparePosition(selection);
  assert.equal(DIRECTION.BACKWARD, result.direction);
});

test$I('#comparePosition returns the direction of selection across nodes', (assert) => {
  let div = document.createElement('div');
  div.innerHTML = '<span>Howdy</span> <span>Friend</span>';
  let selection = {
    anchorNode: div.childNodes[0],
    anchorOffset: 1,
    focusNode: div.childNodes[2],
    focusOffset: 0
  };
  let result = comparePosition(selection);
  assert.equal(DIRECTION.FORWARD, result.direction);
});

test$I('#comparePosition returns the backward direction of selection across nodes', (assert) => {
  let div = document.createElement('div');
  div.innerHTML = '<span>Howdy</span> <span>Friend</span>';
  let selection = {
    anchorNode: div.childNodes[2],
    anchorOffset: 1,
    focusNode: div.childNodes[1],
    focusOffset: 0
  };
  let result = comparePosition(selection);
  assert.equal(DIRECTION.BACKWARD, result.direction);
});

test$I('#comparePosition returns the direction of selection with nested nodes', (assert) => {
  let div = document.createElement('div');
  div.innerHTML = '<span>Howdy</span> <span>Friend</span>';
  let selection = {
    anchorNode: div,
    anchorOffset: 1,
    focusNode: div.childNodes[1],
    focusOffset: 1
  };
  let result = comparePosition(selection);
  assert.equal(DIRECTION.FORWARD, result.direction);
});

test$I('#comparePosition returns the backward direction of selection with nested nodes', (assert) => {
  let div = document.createElement('div');
  div.innerHTML = '<span>Howdy</span> <span>Friend</span>';
  let selection = {
    anchorNode: div.childNodes[2],
    anchorOffset: 1,
    focusNode: div,
    focusOffset: 2
  };
  let result = comparePosition(selection);
  assert.equal(DIRECTION.BACKWARD, result.direction);
});

const { test: test$J, module: module$J } = Helpers;

const cards = [{
  name: 'my-card',
  type: 'dom',
  render() {},
  edit() {}
}];

let editor$9, editorElement$a;

module$J('Acceptance: editor: basic', {
  beforeEach() {
    editorElement$a = $('#editor')[0];
  },
  afterEach() {
    if (editor$9) { editor$9.destroy(); }
  }
});

test$J('sets element as contenteditable', (assert) => {
  editor$9 = new Editor();
  editor$9.render(editorElement$a);

  assert.equal(editorElement$a.getAttribute('contenteditable'),
               'true',
               'element is contenteditable');
});

test$J('clicking outside the editor does not raise an error', (assert) => {
  const done = assert.async();
  editor$9 = new Editor({autofocus: false});
  editor$9.render(editorElement$a);

  let secondEditorElement = document.createElement('div');
  document.body.appendChild(secondEditorElement);

  let secondEditor = new Editor(); // This editor will be focused
  secondEditor.render(secondEditorElement);

  Helpers.dom.triggerEvent(editorElement$a, 'click');

  Helpers.wait(() => {
    assert.ok(true, 'can click external item without error');
    secondEditor.destroy();
    document.body.removeChild(secondEditorElement);

    done();
  });
});

test$J('typing in empty post correctly adds a section to it', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post}) => post());
  editor$9 = new Editor({mobiledoc});
  editor$9.render(editorElement$a);

  assert.hasElement('#editor');
  assert.hasNoElement('#editor p');

  Helpers.dom.moveCursorTo(editor$9, editorElement$a);
  Helpers.dom.insertText(editor$9, 'X');
  assert.hasElement('#editor p:contains(X)');
  Helpers.dom.insertText(editor$9, 'Y');
  assert.hasElement('#editor p:contains(XY)', 'inserts text at correct spot');
});

test$J('typing when on the end of a card is blocked', (assert) => {
  editor$9 = Helpers.editor.buildFromText('[my-card]', {element: editorElement$a, cards});

  let endingZWNJ = $('#editor')[0].firstChild.lastChild;
  Helpers.dom.moveCursorTo(editor$9, endingZWNJ, 0);
  Helpers.dom.insertText(editor$9, 'X');
  assert.hasNoElement('#editor div:contains(X)');
  Helpers.dom.moveCursorTo(editor$9, endingZWNJ, 1);
  Helpers.dom.insertText(editor$9, 'Y');
  assert.hasNoElement('#editor div:contains(Y)');
});

test$J('typing when on the start of a card is blocked', (assert) => {
  editor$9 = Helpers.editor.buildFromText('[my-card]', {element: editorElement$a, cards});

  let startingZWNJ = $('#editor')[0].firstChild.firstChild;
  Helpers.dom.moveCursorTo(editor$9, startingZWNJ, 0);
  Helpers.dom.insertText(editor$9, 'X');
  assert.hasNoElement('#editor div:contains(X)');
  Helpers.dom.moveCursorTo(editor$9, startingZWNJ, 1);
  Helpers.dom.insertText(editor$9, 'Y');
  assert.hasNoElement('#editor div:contains(Y)');
});

test$J('typing tab enters a tab character', (assert) => {
  editor$9 = Helpers.editor.buildFromText('|', {element: editorElement$a});

  Helpers.dom.insertText(editor$9, TAB);
  Helpers.dom.insertText(editor$9, 'Y');

  let {post: expected} = Helpers.postAbstract.buildFromText(`${TAB}Y`);
  assert.postIsSimilar(editor$9.post, expected);
});

// see https://github.com/bustle/mobiledoc-kit/issues/215
test$J('select-all and type text works ok', (assert) => {
  editor$9 = Helpers.editor.buildFromText('<abc>', {element: editorElement$a});

  assert.selectedText('abc', 'precond - abc is selected');
  assert.hasElement('#editor p:contains(abc)', 'precond - renders p');

  Helpers.dom.insertText(editor$9, 'X');

  assert.hasNoElement('#editor p:contains(abc)', 'replaces existing text');
  assert.hasElement('#editor p:contains(X)', 'inserts text');
});

test$J('typing enter splits lines, sets cursor', (assert) => {
  editor$9 = Helpers.editor.buildFromText('hi|hey', {element: editorElement$a});

  assert.hasElement('#editor p:contains(hihey)');

  Helpers.dom.insertText(editor$9, ENTER);
  let {post: expected, range: expectedRange} = Helpers.postAbstract.buildFromText(['hi','|hey']);
  assert.postIsSimilar(editor$9.post, expected, 'correctly encoded');
  assert.rangeIsEqual(editor$9.range, Helpers.editor.retargetRange(expectedRange, editor$9.post));
});

// see https://github.com/bustle/mobiledoc-kit/issues/306
test$J('adding/removing bold text between two bold markers works', (assert) => {
  editor$9 = Helpers.editor.buildFromText('*abc*123*def*', {element: editorElement$a});

  // preconditions
  assert.hasElement('#editor b:contains(abc)');
  assert.hasElement('#editor b:contains(def)');
  assert.hasNoElement('#editor b:contains(123)');

  Helpers.dom.selectText(editor$9, '123', editorElement$a);
  editor$9.run(postEditor => postEditor.toggleMarkup('b'));

  assert.hasElement('#editor b:contains(abc123def)', 'adds B to selection');

  assert.equal(Helpers.dom.getSelectedText(), '123', '123 still selected');

  editor$9.run(postEditor => postEditor.toggleMarkup('b'));

  assert.hasElement('#editor b:contains(abc)', 'removes B from middle, leaves abc');
  assert.hasElement('#editor b:contains(def)', 'removes B from middle, leaves def');
  assert.hasNoElement('#editor b:contains(123)', 'removes B from middle');
});

test$J('keypress events when the editor does not have selection are ignored', (assert) => {
  let done = assert.async();
  let expected;
  editor$9 = Helpers.mobiledoc.renderInto(editorElement$a, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('abc')])]);
    return post([
      markupSection('p', [marker('abc')])
    ]);
  });

  Helpers.dom.clearSelection();

  Helpers.wait(() => {
    assert.ok(!editor$9.hasCursor(), 'precond - editor does not have cursor');
    Helpers.dom.insertText(editor$9, 'v');

    assert.postIsSimilar(editor$9.post, expected, 'post is not changed');
    done();
  });
});

test$J('prevent handling newline', (assert) => {
  editor$9 = Helpers.editor.buildFromText('', {element: editorElement$a});

  editor$9.willHandleNewline(event => {
    assert.ok(true, 'willHandleNewline should be triggered');
    event.preventDefault();
  });
  let {post: expected} = Helpers.postAbstract.buildFromText(['Line1']);

  Helpers.dom.insertText(editor$9, 'Line1');
  Helpers.dom.insertText(editor$9, ENTER);
  assert.postIsSimilar(editor$9.post, expected);
});

const { test: test$K, module: module$K } = Helpers;

const cards$1 = [{
  name: 'my-card',
  type: 'dom',
  render() {},
  edit() {}
}];

const atoms = [{
  name: 'my-atom',
  type: 'dom',
  render() {
    return document.createTextNode('my-atom');
  }
}];

let editor$a, editorElement$b;
let editorOptions = {cards: cards$1, atoms};

module$K('Acceptance: Cursor Movement', {
  beforeEach() {
    editorElement$b = $('#editor')[0];
  },

  afterEach() {
    if (editor$a) { editor$a.destroy(); }
  }
});

test$K('left arrow when at the end of a card moves the cursor across the card', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) => {
    return post([
      cardSection('my-card')
    ]);
  });
  editor$a = new Editor({mobiledoc, cards: cards$1});
  editor$a.render(editorElement$b);
  let cardHead = editor$a.post.sections.head.headPosition();

  // Before zwnj
  Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 0);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  let { range } = editor$a;

  assert.positionIsEqual(range.head, cardHead);
  assert.positionIsEqual(range.tail, cardHead);

  // After zwnj
  Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 1);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, cardHead);
  assert.positionIsEqual(range.tail, cardHead);

  // On wrapper
  Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild, 2);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, cardHead);
  assert.positionIsEqual(range.tail, cardHead);
});

test$K('left arrow when at the start of a card moves the cursor to the previous section', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([
      markupSection('p'),
      cardSection('my-card')
    ]);
  });
  editor$a = new Editor({mobiledoc, cards: cards$1});
  editor$a.render(editorElement$b);
  let sectionTail = editor$a.post.sections.head.tailPosition();

  // Before zwnj
  let sectionElement = editor$a.post.sections.tail.renderNode.element;
  Helpers.dom.moveCursorTo(editor$a, sectionElement.firstChild, 0);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  let { range } = editor$a;

  assert.positionIsEqual(range.head, sectionTail);
  assert.positionIsEqual(range.tail, sectionTail);

  // After zwnj
  Helpers.dom.moveCursorTo(editor$a, sectionElement.firstChild, 1);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, sectionTail);
  assert.positionIsEqual(range.tail, sectionTail);
});

test$K('left arrow when at the start of a card moves to previous list item', assert => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, listSection, listItem, marker, cardSection}) => {
    return post([
      listSection('ul', [listItem([marker('abc')])]),
      cardSection('my-card')
    ]);
  });
  editor$a = new Editor({mobiledoc, cards: cards$1});
  editor$a.render(editorElement$b);
  let itemTail = editor$a.post.sections.head.items.head.tailPosition();

  // Before zwnj
  let sectionElement = editor$a.post.sections.tail.renderNode.element;
  Helpers.dom.moveCursorTo(editor$a, sectionElement.firstChild, 0);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  let { range } = editor$a;

  assert.positionIsEqual(range.head, itemTail);
  assert.positionIsEqual(range.tail, itemTail);

  // After zwnj
  sectionElement = editor$a.post.sections.tail.renderNode.element;
  Helpers.dom.moveCursorTo(editor$a, sectionElement.firstChild, 1);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, itemTail);
  assert.positionIsEqual(range.tail, itemTail);
});

test$K('right arrow at start of card moves the cursor across the card', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) => {
    return post([
      cardSection('my-card')
    ]);
  });
  editor$a = new Editor({mobiledoc, cards: cards$1});
  editor$a.render(editorElement$b);
  let cardTail = editor$a.post.sections.head.tailPosition();

  // Before zwnj
  Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.firstChild, 0);
  Helpers.dom.triggerRightArrowKey(editor$a);
  let { range } = editor$a;

  assert.positionIsEqual(range.head, cardTail);
  assert.positionIsEqual(range.tail, cardTail);

  // After zwnj
  Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.firstChild, 1);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, cardTail);
  assert.positionIsEqual(range.tail, cardTail);
});

test$K('right arrow at end of card moves cursor to next section', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([
      cardSection('my-card'),
      markupSection('p')
    ]);
  });
  editor$a = new Editor({mobiledoc, cards: cards$1});
  editor$a.render(editorElement$b);
  let sectionHead = editor$a.post.sections.tail.headPosition();

  // Before zwnj
  let sectionElement = editor$a.post.sections.head.renderNode.element;
  Helpers.dom.moveCursorTo(editor$a, sectionElement.lastChild, 0);
  Helpers.dom.triggerRightArrowKey(editor$a);
  let { range } = editor$a;

  assert.positionIsEqual(range.head, sectionHead);
  assert.positionIsEqual(range.tail, sectionHead);

  // After zwnj
  Helpers.dom.moveCursorTo(editor$a, sectionElement.lastChild, 1);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  // On wrapper
  Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild, 2);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, sectionHead);
  assert.positionIsEqual(range.tail, sectionHead);
});

test$K('right arrow at end of card moves cursor to next list item', assert => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, listSection, listItem, marker, cardSection}) => {
    return post([
      cardSection('my-card'),
      listSection('ul', [listItem([marker('abc')])])
    ]);
  });
  editor$a = new Editor({mobiledoc, cards: cards$1});
  editor$a.render(editorElement$b);
  let itemHead = editor$a.post.sections.tail.items.head.headPosition();

  // Before zwnj
  let sectionElement = editor$a.post.sections.head.renderNode.element;
  Helpers.dom.moveCursorTo(editor$a, sectionElement.lastChild, 0);
  Helpers.dom.triggerRightArrowKey(editor$a);
  let { range } = editor$a;

  assert.positionIsEqual(range.head, itemHead);
  assert.positionIsEqual(range.tail, itemHead);

  // After zwnj
  Helpers.dom.moveCursorTo(editor$a, sectionElement.lastChild, 1);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  assert.positionIsEqual(range.head, itemHead);
  assert.positionIsEqual(range.tail, itemHead);
});

test$K('left arrow when at the head of an atom moves the cursor left off the atom', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, atom}) => {
    return post([
      markupSection('p', [
        marker('aa'),
        atom('my-atom'),
        marker('cc')
      ])
    ]);
  // TODO just make 0.3.1 default
  }, '0.3.1');
  editor$a = new Editor({mobiledoc, atoms});
  editor$a.render(editorElement$b);

  let atomWrapper = editor$a.post.sections.head.markers.objectAt(1).renderNode.element;

  // Before zwnj, assert moving left
  Helpers.dom.moveCursorTo(editor$a, atomWrapper.lastChild, 0);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  let range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 2,
               'Cursor is positioned at offset 2');

  // After zwnj, assert moving left
  Helpers.dom.moveCursorTo(editor$a, atomWrapper.lastChild, 1);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 2,
               'Cursor is positioned at offset 2');

  // On wrapper, assert moving left
  Helpers.dom.moveCursorTo(editor$a, atomWrapper, 3);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 2,
               'Cursor is positioned at offset 2');

  // After wrapper, asseat moving left
  Helpers.dom.moveCursorTo(editor$a, atomWrapper.nextSibling, 0);
  Helpers.dom.triggerLeftArrowKey(editor$a);
  range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 2,
               'Cursor is positioned at offset 2');
});

test$K('right arrow when at the head of an atom moves the cursor across the atom', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, atom}) => {
    return post([
      markupSection('p', [
        marker('aa'),
        atom('my-atom'),
        marker('cc')
      ])
    ]);
  // TODO just make 0.3.1 default
  }, '0.3.1');
  editor$a = new Editor({mobiledoc, atoms});
  editor$a.render(editorElement$b);

  let atomWrapper = editor$a.post.sections.head.markers.objectAt(1).renderNode.element;

  // Before zwnj, assert moving right
  Helpers.dom.moveCursorTo(editor$a, atomWrapper.firstChild, 0);
  Helpers.dom.triggerRightArrowKey(editor$a);
  let range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 3,
               'Cursor is positioned at offset 3');

  // After zwnj, assert moving right
  Helpers.dom.moveCursorTo(editor$a, atomWrapper.firstChild, 1);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 3,
               'Cursor is positioned at offset 3');

  // On wrapper, assert moving right
  Helpers.dom.moveCursorTo(editor$a, atomWrapper, 1);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 3,
               'Cursor is positioned at offset 3');

  // After wrapper, assert moving right
  Helpers.dom.moveCursorTo(editor$a, atomWrapper.previousSibling, 2);
  Helpers.dom.triggerRightArrowKey(editor$a);
  range = editor$a.range;

  assert.ok(range.head.section === editor$a.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 3,
               'Cursor is positioned at offset 3');
});

test$K('left/right arrows moves cursor l-to-r and r-to-l across atom', (assert) => {
  editor$a = Helpers.mobiledoc.renderInto(editorElement$b, ({post, markupSection, marker, atom}) => {
    return post([markupSection('p', [atom('my-atom', 'first')])]);
  }, editorOptions);

  editor$a.selectRange(editor$a.post.tailPosition());
  Helpers.dom.triggerLeftArrowKey(editor$a);
  assert.positionIsEqual(editor$a.range.head, editor$a.post.headPosition());
  assert.positionIsEqual(editor$a.range.tail, editor$a.post.headPosition());

  editor$a.selectRange(editor$a.post.headPosition());
  Helpers.dom.triggerRightArrowKey(editor$a);
  assert.positionIsEqual(editor$a.range.head, editor$a.post.tailPosition());
  assert.positionIsEqual(editor$a.range.tail, editor$a.post.tailPosition());
});

test$K('left arrow at start atom moves to end of prev section', (assert) => {
  editor$a = Helpers.mobiledoc.renderInto(editorElement$b, ({post, markupSection, marker, atom}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [atom('my-atom', 'first')])
    ]);
  }, editorOptions);

  editor$a.selectRange(editor$a.post.sections.tail.headPosition());
  Helpers.dom.triggerLeftArrowKey(editor$a);
  assert.positionIsEqual(editor$a.range.head, editor$a.post.sections.head.tailPosition());
});

test$K('right arrow at end of end atom moves to start of next section', (assert) => {
  editor$a = Helpers.mobiledoc.renderInto(editorElement$b, ({post, markupSection, marker, atom}) => {
    return post([
      markupSection('p', [atom('my-atom', 'first')]),
      markupSection('p', [marker('abc')])
    ]);
  }, editorOptions);

  editor$a.selectRange(editor$a.post.sections.head.tailPosition());
  Helpers.dom.triggerRightArrowKey(editor$a);
  assert.positionIsEqual(editor$a.range.head, editor$a.post.sections.tail.headPosition());
});

module$K('Acceptance: Cursor Movement w/ shift', {
  beforeEach() {
    editorElement$b = $('#editor')[0];
  },

  afterEach() {
    if (editor$a) { editor$a.destroy(); }
  }
});

if (supportsSelectionExtend()) {
  // FIXME: Older versions of IE do not support `extends` on selection
  // objects, and thus cannot support highlighting left until we implement
  // selections without native APIs.
  test$K('left arrow when at the end of a card moves the selection across the card', assert => {
    let mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) => {
      return post([
        cardSection('my-card')
      ]);
    });
    editor$a = new Editor({mobiledoc, cards: cards$1});
    editor$a.render(editorElement$b);

    let cardHead = editor$a.post.sections.head.headPosition();
    let cardTail = editor$a.post.sections.head.tailPosition();

    // Before zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 0);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    let { range } = editor$a;

    assert.positionIsEqual(range.head, cardHead);
    assert.positionIsEqual(range.tail, cardTail);

    // After zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 1);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, cardHead);
    assert.positionIsEqual(range.tail, cardTail);

    // On wrapper
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild, 2);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, cardHead);
    assert.positionIsEqual(range.tail, cardTail);
  });

  test$K('left arrow at start of card moves selection to prev section', assert => {
    let mobiledoc = Helpers.mobiledoc.build(
      ({post, markupSection, marker, cardSection}) => {
      return post([
        markupSection('p', [marker('abc')]),
        cardSection('my-card')
      ]);
    });
    editor$a = new Editor({mobiledoc, cards: cards$1});
    editor$a.render(editorElement$b);

    let cardHead = editor$a.post.sections.tail.headPosition();
    let sectionTail = editor$a.post.sections.head.tailPosition();

    // Before zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.lastChild.firstChild, 0);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    let { range } = editor$a;

    assert.positionIsEqual(range.head, sectionTail);
    assert.positionIsEqual(range.tail, cardHead);

    // After zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.lastChild.firstChild, 1);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, sectionTail);
    assert.positionIsEqual(range.tail, cardHead);
  });

  test$K('left arrow at start of card moves selection to prev list item', assert => {
    let mobiledoc = Helpers.mobiledoc.build(
      ({post, listSection, listItem, marker, cardSection}) => {
      return post([
        listSection('ul', [listItem([marker('abc')])]),
        cardSection('my-card')
      ]);
    });
    editor$a = new Editor({mobiledoc, cards: cards$1});
    editor$a.render(editorElement$b);

    let cardHead = editor$a.post.sections.tail.headPosition();
    let sectionTail = editor$a.post.sections.head.items.head.tailPosition();

    // Before zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.lastChild.firstChild, 0);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    let { range } = editor$a;

    assert.positionIsEqual(range.head, sectionTail);
    assert.positionIsEqual(range.tail, cardHead);

    // After zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.lastChild.firstChild, 1);
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, sectionTail);
    assert.positionIsEqual(range.tail, cardHead);
  });

  test$K('right arrow at start of card moves the cursor across the card', assert => {
    let mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) => {
      return post([
        cardSection('my-card')
      ]);
    });
    editor$a = new Editor({mobiledoc, cards: cards$1});
    editor$a.render(editorElement$b);

    let cardHead = editor$a.post.sections.head.headPosition();
    let cardTail = editor$a.post.sections.head.tailPosition();

    // Before zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.firstChild, 0);
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    let { range } = editor$a;

    assert.positionIsEqual(range.head, cardHead);
    assert.positionIsEqual(range.tail, cardTail);

    // After zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.firstChild, 1);
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, cardHead);
    assert.positionIsEqual(range.tail, cardTail);
  });

  test$K('right arrow at end of card moves to next section', (assert) => {
    let mobiledoc = Helpers.mobiledoc.build(
      ({post, markupSection, marker, cardSection}) => {
      return post([
        cardSection('my-card'),
        markupSection('p', [marker('abc')])
      ]);
    });
    editor$a = new Editor({mobiledoc, cards: cards$1});
    editor$a.render(editorElement$b);

    let cardTail = editor$a.post.sections.head.tailPosition();
    let sectionHead = editor$a.post.sections.tail.headPosition();

    // Before zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 0);
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    let { range } = editor$a;

    assert.positionIsEqual(range.head, cardTail);
    assert.positionIsEqual(range.tail, sectionHead);

    // After zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 1);
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, cardTail);
    assert.positionIsEqual(range.tail, sectionHead);
  });

  test$K('right arrow at end of card moves to next list item', (assert) => {
    let mobiledoc = Helpers.mobiledoc.build(
      ({post, listSection, listItem, marker, cardSection}) => {
      return post([
        cardSection('my-card'),
        listSection('ul', [listItem([marker('abc')])])
      ]);
    });
    editor$a = new Editor({mobiledoc, cards: cards$1});
    editor$a.render(editorElement$b);

    let cardTail = editor$a.post.sections.head.tailPosition();
    let itemHead = editor$a.post.sections.tail.items.head.headPosition();

    // Before zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 0);
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    let { range } = editor$a;

    assert.positionIsEqual(range.head, cardTail);
    assert.positionIsEqual(range.tail, itemHead);

    // After zwnj
    Helpers.dom.moveCursorTo(editor$a, editorElement$b.firstChild.lastChild, 1);
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    range = editor$a.range;

    assert.positionIsEqual(range.head, cardTail);
    assert.positionIsEqual(range.tail, itemHead);
  });

  test$K('left/right arrows move selection l-to-r and r-to-l across atom', (assert) => {
    editor$a = Helpers.mobiledoc.renderInto(editorElement$b, ({post, markupSection, marker, atom}) => {
      return post([markupSection('p', [atom('my-atom', 'first')])]);
    }, editorOptions);

    editor$a.selectRange(editor$a.post.tailPosition());
    Helpers.dom.triggerLeftArrowKey(editor$a, MODIFIERS.SHIFT);
    assert.positionIsEqual(editor$a.range.head, editor$a.post.headPosition());
    assert.positionIsEqual(editor$a.range.tail, editor$a.post.tailPosition());

    editor$a.selectRange(editor$a.post.headPosition());
    Helpers.dom.triggerRightArrowKey(editor$a, MODIFIERS.SHIFT);
    assert.positionIsEqual(editor$a.range.head, editor$a.post.headPosition());
    assert.positionIsEqual(editor$a.range.tail, editor$a.post.tailPosition());
  });
}

const { test: test$L, module: module$L } = Helpers;

const cards$2 = [{
  name: 'my-card',
  type: 'dom',
  render() {},
  edit() {}
}];

const atoms$1 = [{
  name: 'my-atom',
  type: 'dom',
  render() {
    return document.createTextNode('my-atom');
  }
}];

let editor$b, editorElement$c;

module$L('Acceptance: Cursor Position', {
  beforeEach() {
    editorElement$c = $('#editor')[0];
  },

  afterEach() {
    if (editor$b) { editor$b.destroy(); }
  }
});

test$L('cursor in a markup section reports its position correctly', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$b = new Editor({mobiledoc});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c.firstChild.firstChild, 1);
  let { range } = editor$b;

  assert.ok(range.head.section === editor$b.post.sections.head,
            'Cursor is positioned on first section');
  assert.equal(range.head.offset, 1,
               'Cursor is positioned at offset 1');
});

test$L('cursor blank section reports its position correctly', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection}) => {
    return post([markupSection('p')]);
  });
  editor$b = new Editor({mobiledoc});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c.firstChild.firstChild, 0);
  let { range } = editor$b;

  assert.positionIsEqual(range.head, editor$b.post.sections.head.headPosition());
});

test$L('cursor moved left from section after card is reported as on the card with offset 1', (assert) => {
  // Cannot actually move a cursor, so just emulate what things looks like after
  // the arrow key is pressed
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([cardSection('my-card'), markupSection('p')]);
  });
  editor$b = new Editor({mobiledoc, cards: cards$2});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c.firstChild.lastChild, 1);
  let { range } = editor$b;

  assert.positionIsEqual(range.head, editor$b.post.sections.head.toPosition(1));
});

test$L('cursor moved up from end of section after card is reported as on the card with offset 1', (assert) => {
  // Cannot actually move a cursor, so just emulate what things looks like after
  // the arrow key is pressed
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([
      cardSection('my-card'),
      markupSection('p')
    ]);
  });
  editor$b = new Editor({mobiledoc, cards: cards$2});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c.firstChild.lastChild, 0);
  let { range } = editor$b;

  assert.positionIsEqual(range.head, editor$b.post.sections.head.tailPosition());
});

test$L('cursor moved right from end of section before card is reported as on the card with offset 0', (assert) => {
  // Cannot actually move a cursor, so just emulate what things looks like after
  // the arrow key is pressed
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([markupSection('p'), cardSection('my-card')]);
  });
  editor$b = new Editor({mobiledoc, cards: cards$2});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c.lastChild.firstChild, 0);
  let { range } = editor$b;

  assert.positionIsEqual(range.head, editor$b.post.sections.tail.headPosition());
});

test$L('cursor moved right from end of section before card is reported as on the card with offset 0', (assert) => {
  // Cannot actually move a cursor, so just emulate what things looks like after
  // the arrow key is pressed
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([markupSection('p'), cardSection('my-card')]);
  });
  editor$b = new Editor({mobiledoc, cards: cards$2});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c.lastChild.firstChild, 1);
  let { range } = editor$b;

  assert.positionIsEqual(range.head, editor$b.post.sections.tail.headPosition());
});

test$L('cursor focused on card wrapper with 2 offset', (assert) => {
  // Cannot actually move a cursor, so just emulate what things looks like after
  // the arrow key is pressed
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([markupSection('p'), cardSection('my-card')]);
  });
  editor$b = new Editor({mobiledoc, cards: cards$2});
  editor$b.render(editorElement$c);

  // We need to create a selection starting from the markup section's node
  // in order for the tail to end up focused on a div instead of a text node
  // This only happens in Firefox
  Helpers.dom.moveCursorTo(editor$b, editorElement$c.firstChild.firstChild, 0, 
                           editorElement$c.lastChild, 2);

  let { range } = editor$b;

  assert.positionIsEqual(range.tail, editor$b.post.sections.tail.tailPosition());
});

// This can happen when using arrow+shift keys to select left across a card
test$L('cursor focused on card wrapper with 0 offset', (assert) => {
  // Cannot actually move a cursor, so just emulate what things looks like after
  // the arrow key is pressed
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, cardSection}) => {
    return post([markupSection('p'), cardSection('my-card')]);
  });
  editor$b = new Editor({mobiledoc, cards: cards$2});
  editor$b.render(editorElement$c);

  // We need to create a selection starting from the markup section's node
  // in order for the tail to end up focused on a div instead of a text node
  Helpers.dom.moveCursorTo(editor$b, editorElement$c.firstChild.firstChild, 0,
                           editorElement$c.lastChild, 0);
  let { range } = editor$b;

  assert.positionIsEqual(range.tail, editor$b.post.sections.tail.headPosition());
});

// see https://github.com/bustle/mobiledoc-kit/issues/215
test$L('selecting the entire editor element reports a selection range of the entire post', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('1234')])
    ]);
  });
  editor$b = new Editor({mobiledoc});
  editor$b.render(editorElement$c);

  Helpers.dom.moveCursorTo(editor$b, editorElement$c, 0,
                           editorElement$c, editorElement$c.childNodes.length);
  let { range } = editor$b;

  assert.positionIsEqual(range.head, editor$b.post.sections.head.headPosition());
  assert.positionIsEqual(range.tail, editor$b.post.sections.tail.tailPosition());
});

test$L('when at the head of an atom', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, atom}) => {
    return post([markupSection('p', [
      marker('aa'), atom('my-atom'), marker('cc')
    ])]);
  });
  editor$b = new Editor({mobiledoc, atoms: atoms$1});
  editor$b.render(editorElement$c);

  let atomWrapper = editor$b.post.sections.head.markers.objectAt(1).renderNode.element;

  // Before zwnj
  //
  Helpers.dom.moveCursorTo(editor$b, atomWrapper.firstChild, 0);
  let range = editor$b.range;

  let positionBeforeAtom = editor$b.post.sections.head.toPosition('aa'.length);

  assert.positionIsEqual(range.head, positionBeforeAtom);

  // After zwnj
  //
  Helpers.dom.moveCursorTo(editor$b, atomWrapper.firstChild, 1);
  range = editor$b.range;

  assert.positionIsEqual(range.head, positionBeforeAtom);

  // On wrapper
  //
  [0, 1].forEach(index => {
    Helpers.dom.moveCursorTo(editor$b, atomWrapper, index);
    range = editor$b.range;

    assert.positionIsEqual(range.head, positionBeforeAtom);
  });

  // text node before wrapper
  Helpers.dom.moveCursorTo(editor$b, atomWrapper.previousSibling, 2);
  range = editor$b.range;

  assert.positionIsEqual(range.head, positionBeforeAtom);
});

test$L('when at the tail of an atom', assert => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, atom}) => {
    return post([markupSection('p', [
      marker('aa'), atom('my-atom'), marker('cc')
    ])]);
  });
  editor$b = new Editor({mobiledoc, atoms: atoms$1});
  editor$b.render(editorElement$c);

  let atomWrapper = editor$b.post.sections.head.markers.objectAt(1).renderNode.element;
  let positionAfterAtom = editor$b.post.sections.head.toPosition('aa'.length + 1);

  // Before zwnj
  //
  Helpers.dom.moveCursorTo(editor$b, atomWrapper.lastChild, 0);
  let range = editor$b.range;

  assert.positionIsEqual(range.head, positionAfterAtom);

  // After zwnj
  //
  Helpers.dom.moveCursorTo(editor$b, atomWrapper.lastChild, 1);
  range = editor$b.range;

  assert.positionIsEqual(range.head, positionAfterAtom);

  // On wrapper
  //
  [2, 3].forEach(index => {
    Helpers.dom.moveCursorTo(editor$b, atomWrapper, index);
    range = editor$b.range;
    assert.positionIsEqual(range.head, positionAfterAtom);
  });


  // After wrapper
  //
  Helpers.dom.moveCursorTo(editor$b, atomWrapper.nextSibling, 0);
  range = editor$b.range;

  assert.positionIsEqual(range.head, positionAfterAtom);
});

const { test: test$M, module: module$M } = Helpers;

const simpleAtom = {
  name: 'simple-atom',
  type: 'dom',
  render({value}) {
    let element = document.createElement('span');
    element.setAttribute('id', 'simple-atom');
    element.appendChild(document.createTextNode(value));
    return element;
  }
};

let editor$c, editorElement$d;
const mobiledocWithAtom = {
  version: MOBILEDOC_VERSION$2,
  atoms: [
    ['simple-atom', 'Bob']
  ],
  cards: [],
  markups: [],
  sections: [
    [1, "P", [
      [0, [], 0, "text before atom"],
      [1, [], 0, 0],
      [0, [], 0, "text after atom"]
    ]]
  ]
};
let editorOptions$1 = { atoms: [simpleAtom] };

module$M('Acceptance: Atoms', {
  beforeEach() {
    editorElement$d = $('#editor')[0];
  },

  afterEach() {
    if (editor$c) {
      editor$c.destroy();
      editor$c = null;
    }
  }
});

test$M('keystroke of character before starting atom inserts character', (assert) => {
  let done = assert.async();
  assert.expect(2);
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, atom, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('A'), atom('simple-atom', 'first')])]);
    return post([markupSection('p', [atom('simple-atom', 'first')])]);
  }, editorOptions$1);

  editor$c.selectRange(editor$c.post.headPosition());
  Helpers.dom.insertText(editor$c, 'A');

  Helpers.wait(() => {
    assert.postIsSimilar(editor$c.post, expected);
    assert.renderTreeIsEqual(editor$c._renderTree, expected);
    done();
  });
});

test$M('keystroke of character before mid-text atom inserts character', (assert) => {
  let done = assert.async();
  assert.expect(2);
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, atom, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('ABC'), atom('simple-atom', 'first')])]);
    return post([markupSection('p', [marker('AB'), atom('simple-atom', 'first')])]);
  }, editorOptions$1);

  editor$c.selectRange(Range.create(editor$c.post.sections.head, 'AB'.length));
  Helpers.dom.insertText(editor$c, 'C');

  Helpers.wait(() => {
    assert.postIsSimilar(editor$c.post, expected);
    assert.renderTreeIsEqual(editor$c._renderTree, expected);
    done();
  });
});

test$M('keystroke of character after mid-text atom inserts character', (assert) => {
  let done = assert.async();
  assert.expect(2);
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, atom, markupSection, marker}) => {
    expected = post([markupSection('p', [atom('simple-atom', 'first'), marker('ABC')])]);
    return post([markupSection('p', [atom('simple-atom', 'first'), marker('BC')])]);
  }, editorOptions$1);

  editor$c.selectRange(Range.create(editor$c.post.sections.head, 1));
  Helpers.dom.insertText(editor$c, 'A');

  Helpers.wait(() => {
    assert.postIsSimilar(editor$c.post, expected);
    assert.renderTreeIsEqual(editor$c._renderTree, expected);
    done();
  });
});

test$M('keystroke of character after end-text atom inserts character', (assert) => {
  let done = assert.async();
  assert.expect(2);
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, atom, markupSection, marker}) => {
    expected = post([markupSection('p', [atom('simple-atom', 'first'), marker('A')])]);
    return post([markupSection('p', [atom('simple-atom', 'first')])]);
  }, editorOptions$1);

  editor$c.selectRange(Range.create(editor$c.post.sections.head, 1));
  Helpers.dom.insertText(editor$c, 'A');

  Helpers.wait(() => {
    assert.postIsSimilar(editor$c.post, expected);
    assert.renderTreeIsEqual(editor$c._renderTree, expected);
    done();
  });
});

test$M('keystroke of delete removes character after atom', (assert) => {
  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.moveCursorTo(editor$c, pNode.lastChild, 1);
  Helpers.dom.triggerDelete(editor$c);

  assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
    ({post, markupSection, atom, marker}) => {
      return post([markupSection('p', [
        marker('text before atom'),
        atom('simple-atom', 'Bob'),
        marker('ext after atom')
      ])]);
    }));
});

test$M('keystroke of delete removes atom', (assert) => {
  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.moveCursorTo(editor$c, pNode.lastChild, 0);
  Helpers.dom.triggerDelete(editor$c);

  assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
    ({post, markupSection, atom, marker}) => {
      return post([markupSection('p', [
        marker('text before atomtext after atom')
      ])]);
    }));
});

test$M('keystroke of forward delete removes atom', (assert) => {
  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.moveCursorTo(editor$c, pNode.firstChild, 16);
  Helpers.dom.triggerForwardDelete(editor$c);

  assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
    ({post, markupSection, atom, marker}) => {
      return post([markupSection('p', [
        marker('text before atomtext after atom')
      ])]);
    }));
});

test$M('keystroke of enter in section with atom creates new section', (assert) => {
  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.moveCursorTo(editor$c, pNode.lastChild, 1);
  Helpers.dom.triggerEnter(editor$c);

  assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
    ({post, markupSection, atom, marker}) => {
      return post([
        markupSection('p', [
          marker('text before atom'),
          atom('simple-atom', 'Bob'),
          marker('t')
        ]),
        markupSection('p', [
          marker('ext after atom')
        ])
      ]);
    }));
});

test$M('keystroke of enter after atom and before marker creates new section', (assert) => {
  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.moveCursorTo(editor$c, pNode.lastChild, 0);
  Helpers.dom.triggerEnter(editor$c);

  assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
    ({post, markupSection, atom, marker}) => {
      return post([
        markupSection('p', [
          marker('text before atom'),
          atom('simple-atom', 'Bob')
        ]),
        markupSection('p', [
          marker('text after atom')
        ])
      ]);
    }));
});

test$M('keystroke of enter before atom and after marker creates new section', (assert) => {
  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.moveCursorTo(editor$c, pNode.firstChild, 16);
  Helpers.dom.triggerEnter(editor$c);

  assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
    ({post, markupSection, atom, marker}) => {
      return post([
        markupSection('p', [
          marker('text before atom')
        ]),
        markupSection('p', [
          atom('simple-atom', 'Bob'),
          marker('text after atom')
        ])
      ]);
    }));
});

// see https://github.com/bustle/mobiledoc-kit/issues/313
test$M('keystroke of enter at markup section head before atom creates new section', (assert) => {
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, markupSection, atom}) => {
    expected = post([
      markupSection('p'), markupSection('p', [atom('simple-atom')])
    ]);
    return post([markupSection('p', [atom('simple-atom')])]);
  }, editorOptions$1);

  editor$c.run(postEditor => {
    postEditor.setRange(editor$c.post.headPosition());
  });
  Helpers.dom.triggerEnter(editor$c);

  assert.postIsSimilar(editor$c.post, expected);
  assert.renderTreeIsEqual(editor$c._renderTree, expected);
  assert.positionIsEqual(editor$c.range.head,
                         editor$c.post.sections.tail.headPosition());
});

// see https://github.com/bustle/mobiledoc-kit/issues/313
test$M('keystroke of enter at list item head before atom creates new section', (assert) => {
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, listSection, listItem, atom, marker}) => {
    let blankMarker = marker();
    expected = post([
      listSection('ul', [
        listItem([blankMarker]),
        listItem([atom('simple-atom', 'X')])
      ])
    ]);
    return post([listSection('ul', [listItem([atom('simple-atom', 'X')])])]);
  }, editorOptions$1);

  editor$c.run(postEditor => {
    postEditor.setRange(editor$c.post.headPosition());
  });
  Helpers.dom.triggerEnter(editor$c);

  assert.postIsSimilar(editor$c.post, expected);
  // FIXME the render tree does not have the blank marker render node
  // because ListItem#isBlank is true, so it simply renders a cursor-positioning
  // `<br>` tag instead of an empy marker, so the following render tree check
  // is not accurate:
  // assert.renderTreeIsEqual(editor._renderTree, expected);
  assert.positionIsEqual(editor$c.range.head,
                         editor$c.post.sections.head.items.tail.headPosition());
});

test$M('marking atom with markup adds markup', (assert) => {
  assert.expect(1);
  let done = assert.async();

  editor$c = new Editor({mobiledoc: mobiledocWithAtom, atoms: [simpleAtom]});
  editor$c.render(editorElement$d);

  let pNode = $('#editor p')[0];
  Helpers.dom.selectRange(pNode.firstChild, 16, pNode.lastChild, 0);

  Helpers.wait(() => {
    editor$c.run(postEditor => {
      let markup = editor$c.builder.createMarkup('strong');
      postEditor.addMarkupToRange(editor$c.range, markup);
    });

    assert.postIsSimilar(editor$c.post, Helpers.postAbstract.build(
      ({post, markupSection, atom, marker, markup}) => {
        return post([
          markupSection('p', [
            marker('text before atom'),
            atom('simple-atom', 'Bob', {}, [markup('strong')]),
            marker('text after atom')
          ])
        ]);
      }));

    done();
  });
});

test$M('typing between two atoms inserts character', (assert) => {
  let done = assert.async();
  assert.expect(2);

  let expected;
  editor$c = Helpers.mobiledoc.renderInto(
    editorElement$d, ({post, markupSection, atom, marker}) => {
      expected = post([markupSection('p', [
        atom('simple-atom', 'first'),
        marker('A'),
        atom('simple-atom', 'last')
      ])]);
      return post([markupSection('p', [
        atom('simple-atom', 'first'),
        atom('simple-atom', 'last')
      ])]);
    }, editorOptions$1);

    editor$c.selectRange(Range.create(editor$c.post.sections.head, 1));

    Helpers.dom.insertText(editor$c, 'A');

    Helpers.wait(() => {
      assert.postIsSimilar(editor$c.post, expected);
      assert.renderTreeIsEqual(editor$c._renderTree, expected);
      done();
    });
});

test$M('delete selected text including atom deletes atom', (assert) => {
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, markupSection, marker, atom}) => {
    expected = post([markupSection('p', [marker('abc')])]);
    return post([markupSection('p', [
      marker('ab'), atom('simple-atom', 'deleteme'), marker('c')
    ])]);
  }, editorOptions$1);

  let section = editor$c.post.sections.head;
  editor$c.selectRange(Range.create(section, 'ab'.length,
                                  section, 'ab'.length + 1));

  Helpers.dom.triggerDelete(editor$c);

  assert.postIsSimilar(editor$c.post, expected);
  assert.renderTreeIsEqual(editor$c._renderTree, expected);
});

test$M('delete selected text that ends between atoms deletes first atom', (assert) => {
  let expected;
  editor$c = Helpers.mobiledoc.renderInto(editorElement$d, ({post, markupSection, marker, atom}) => {
    expected = post([markupSection('p', [
      marker('abd'),
      atom('simple-atom', 'keepme')
    ])]);
    return post([markupSection('p', [
      marker('ab'), atom('simple-atom', 'deleteme'),
      marker('cd'), atom('simple-atom', 'keepme')
    ])]);
  }, editorOptions$1);

  let section = editor$c.post.sections.head;
  editor$c.selectRange(Range.create(section, 'ab'.length,
                                  section, 'ab'.length + 1 + 'c'.length));

  Helpers.dom.triggerDelete(editor$c);

  assert.postIsSimilar(editor$c.post, expected);
  assert.renderTreeIsEqual(editor$c._renderTree, expected);
});

const { module: module$N, test: test$N } = Helpers;

let editor$d, editorElement$e;

function renderEditor(...args) {
  editor$d = Helpers.mobiledoc.renderInto(editorElement$e, ...args);
  editor$d.selectRange(editor$d.post.tailPosition());
  return editor$d;
}

module$N('Acceptance: Editor: Attributes', {
  beforeEach() {
    editorElement$e = $('#editor')[0];
  },
  afterEach() {
    if (editor$d) { editor$d.destroy(); }
  }
});

test$N('pressing ENTER at the end of an aligned paragraph maintains the alignment (bug #694)', (assert) => {
  renderEditor(({post, markupSection, marker}) => {
    return post([
      markupSection(
        'p',
        [marker('abc')],
        false,
        { 'data-md-text-align': 'center' }
      )
    ]);
  });

  Helpers.dom.triggerEnter(editor$d);

  const firstParagraph = document.querySelector('#editor p:first-of-type');
  assert.equal(firstParagraph.getAttribute('data-md-text-align'), 'center');
});

test$N('toggling the section inside an aligned list maintains the alignment of the list (bug #694)', (assert) => {
  renderEditor(({post, listSection, listItem, marker}) => {
    return post([
      listSection(
        'ul',
        [
          listItem([marker('abc')]),
          listItem([marker('123')])
        ],
        { 'data-md-text-align': 'center' }
      )
    ]);
  });

  editor$d.run(postEditor => postEditor.toggleSection('h1'));

  const ul = document.querySelector('#editor ul');
  assert.equal(ul.getAttribute('data-md-text-align'), 'center');
});

const { test: test$O, module: module$O } = Helpers;
const { editor: { buildFromText: buildFromText$5 } } = Helpers;

let editor$e, editorElement$f;
let editorOpts$1;
const cardText = 'card text';

const cards$3 = [{
  name: 'simple',
  type: 'dom',
  render({env}) {
    let element = document.createElement('div');

    let button = document.createElement('button');
    button.setAttribute('id', 'display-button');
    element.appendChild(button);
    element.appendChild(document.createTextNode(cardText));
    button.onclick = env.edit;

    return element;
  },
  edit({env}) {
    let button = document.createElement('button');
    button.setAttribute('id', 'edit-button');
    button.onclick = env.save;
    return button;
  }
}, {
  name: 'input',
  type: 'dom',
  render() {
    return $('<input id="simple-card-input">')[0];
  }
}, {
  name: 'position',
  type: 'dom',
  render() {
    return $('<div id="my-simple-card"></div>')[0];
  }
}];

module$O('Acceptance: editor: cards', {
  beforeEach() {
    editorElement$f = $('#editor')[0];
    editorOpts$1 = {element: editorElement$f, cards: cards$3};
  },
  afterEach() {
    if (editor$e) { editor$e.destroy(); }
  }
});

test$O('changing to display state triggers update on editor', (assert) => {
  editor$e = buildFromText$5(['[simple]'], editorOpts$1);

  let updateCount = 0,
      triggeredUpdate = () => updateCount++;
  editor$e.postDidChange(triggeredUpdate);

  let displayButton = document.getElementById('display-button');
  assert.ok(!!displayButton, 'precond - display button is there');

  Helpers.dom.triggerEvent(displayButton, 'click');

  let editButton = document.getElementById('edit-button');
  assert.ok(!!editButton, 'precond - edit button is there after clicking the display button');

  let currentUpdateCount = updateCount;

  Helpers.dom.triggerEvent(editButton, 'click');

  assert.equal(updateCount, currentUpdateCount+1,
               'update is triggered after switching to display mode');
});

test$O('editor listeners are quieted for card actions', (assert) => {
  const done = assert.async();

  editor$e = buildFromText$5(['[simple]'], editorOpts$1);

  Helpers.dom.selectText(editor$e, cardText, editorElement$f);
  Helpers.dom.triggerEvent(document, 'mouseup');

  Helpers.wait(() => {
    // FIXME should have a better assertion here
    assert.ok(true, 'made it here with no javascript errors');
    done();
  });
});

test$O('removing last card from mobiledoc allows additional editing', (assert) => {
  const done = assert.async();
  let button;
  const cards = [{
    name: 'removable',
    type: 'dom',
    render({env}) {
      button = $('<button id="removable-button">Click me</button>');
      button.on('click', env.remove);
      return button[0];
    }
  }];
  editor$e = buildFromText$5(['[removable]'], {element: editorElement$f, cards});

  assert.hasElement('#editor button:contains(Click me)', 'precond - button');

  button.click();

  Helpers.wait(() => {
    assert.hasNoElement('#editor button:contains(Click me)', 'button is removed');
    assert.hasNoElement('#editor p');
    Helpers.dom.moveCursorTo(editor$e, $('#editor')[0]);
    Helpers.dom.insertText(editor$e, 'X');
    assert.hasElement('#editor p:contains(X)');

    done();
  });
});

test$O('delete when cursor is positioned at end of a card deletes card, replace with empty markup section', (assert) => {
  editor$e = buildFromText$5(['[position]|'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasNoElement('#editor p', 'precond - has no markup section');

  Helpers.dom.triggerDelete(editor$e);

  assert.hasNoElement('#my-simple-card', 'removes card after delete');
  assert.hasElement('#editor p', 'has markup section after delete');
});

test$O('delete when cursor is at start of a card and prev section is blank deletes prev section', (assert) => {
  editor$e = buildFromText$5(['','|[position]'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasElement('#editor p', 'precond - has blank markup section');

  Helpers.dom.triggerDelete(editor$e);

  assert.hasElement('#my-simple-card', 'card still exists after delete');
  assert.hasNoElement('#editor p', 'blank markup section deleted');
});

test$O('forward-delete when cursor is positioned at start of a card deletes card, replace with empty markup section', (assert) => {
  editor$e = buildFromText$5(['|[position]'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasNoElement('#editor p', 'precond - has no markup section');

  Helpers.dom.triggerDelete(editor$e, DIRECTION.FORWARD);

  assert.hasNoElement('#my-simple-card', 'removes card after delete');
  assert.hasElement('#editor p', 'has markup section after delete');
});

test$O('forward-delete when cursor is positioned at end of a card and next section is blank deletes next section', (assert) => {
  editor$e = buildFromText$5(['[position]|',''], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasElement('#editor p', 'precond - has blank markup section');

  Helpers.dom.triggerDelete(editor$e, DIRECTION.FORWARD);

  assert.hasElement('#my-simple-card', 'still has card after delete');
  assert.hasNoElement('#editor p', 'deletes blank markup section');
});

test$O('selecting a card and deleting deletes the card', (assert) => {
  editor$e = buildFromText$5(['<[position]>'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasNoElement('#editor p', 'precond - has no markup section');

  Helpers.dom.triggerDelete(editor$e);

  assert.hasNoElement('#my-simple-card', 'has no card after delete');
  assert.hasElement('#editor p', 'has blank markup section');
});

test$O('selecting a card and some text after and deleting deletes card and text', (assert) => {
  editor$e = buildFromText$5(['<[position]','a>bc'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasElement('#editor p:contains(abc)', 'precond - has markup section');

  Helpers.dom.triggerDelete(editor$e);

  assert.hasNoElement('#my-simple-card', 'has no card after delete');
  assert.hasElement('p:contains(bc)', 'p with bc');
  assert.hasNoElement('p:contains(abc)', '"a" is deleted');
});

test$O('deleting at start of empty markup section with prev card deletes the markup section', (assert) => {
  editor$e = buildFromText$5(['[position]','|'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasElement('#editor p', 'precond - has blank markup section');

  Helpers.dom.triggerDelete(editor$e);

  assert.hasElement('#my-simple-card', 'has card after delete');
  assert.hasNoElement('#editor p', 'paragraph is gone');
});

test$O('press enter at end of card inserts section after card', (assert) => {
  editor$e = buildFromText$5(['[position]|'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasNoElement('#editor p', 'precond - has no markup section');

  Helpers.dom.triggerEnter(editor$e);

  assert.hasElement('#my-simple-card', 'has card after enter');
  assert.hasElement('#editor p', 'markup section is added');
});

test$O('press enter at start of card inserts section before card', (assert) => {
  editor$e = buildFromText$5(['|[position]'], editorOpts$1);

  assert.hasElement('#my-simple-card', 'precond - renders card');
  assert.hasNoElement('#editor p', 'precond - has no markup section');

  Helpers.dom.triggerEnter(editor$e);

  assert.hasElement('#my-simple-card', 'has card after enter');
  assert.hasElement('#editor p', 'markup section is added');
});

test$O('editor ignores events when focus is inside a card', (assert) => {
  editor$e = buildFromText$5(['','[input]'], editorOpts$1);

  assert.hasElement('#simple-card-input', 'precond - renders card');

  let inputEvents = 0;
  editor$e._eventManager.keyup = () => inputEvents++;

  let input = $('#simple-card-input')[0];
  Helpers.dom.triggerEvent(input, 'keyup');

  assert.equal(inputEvents, 0, 'editor does not handle keyup event when in card');

  let p = $('#editor p')[0];
  Helpers.dom.triggerEvent(p, 'keyup');

  assert.equal(inputEvents, 1, 'editor handles keyup event outside of card');
});

test$O('a moved card retains its inital editing mode', (assert) => {
  editorOpts$1.beforeRender = (editor) => {
    editor.post.sections.tail.setInitialMode(CARD_MODES.EDIT);
  };
  editor$e = buildFromText$5(['','[simple]'], editorOpts$1);

  assert.hasElement('#edit-button', 'precond - card is in edit mode');

  editor$e.run(postEditor => {
    let card = editor$e.post.sections.tail;
    postEditor.moveSectionUp(card);
  });

  assert.hasElement('#edit-button', 'card is still in edit mode');
});

test$O('a moved card retains its current editing mode', (assert) => {
  editor$e = buildFromText$5(['','[simple]'], editorOpts$1);

  assert.hasNoElement('#edit-button', 'precond - card is not in edit mode');

  editor$e.editCard(editor$e.post.sections.tail);
  assert.hasElement('#edit-button', 'precond - card is in edit mode');

  editor$e.run(postEditor => postEditor.moveSectionUp(editor$e.post.sections.tail));

  assert.hasElement('#edit-button', 'card is still in edit mode');
});

// see https://github.com/bustle/mobiledoc-kit/issues/475
test$O('when editing is disabled, cards can be moved and deleted', (assert) => {
  let removeHook;
  editorOpts$1.unknownCardHandler = ({env: {name, remove}}) => {
    if (name === 'card-b') {
      removeHook = remove;
    }
    return $(`<h1>${name}</h1>`)[0];
  };
  editor$e = buildFromText$5(['[card-a]','[card-b]|'], editorOpts$1);
  editor$e.disableEditing();

  let card = editor$e.post.sections.tail;
  editor$e.run(postEditor => {
    // In order to recreate the problematic scenario, we must explicitly set the range
    // here to the moved section's tail position
    let movedSection = postEditor.moveSectionUp(card);
    postEditor.setRange(movedSection.tailPosition());
  });

  assert.hasElement('h1:contains(card-a)');
  assert.hasElement('h1:contains(card-b)');
  let text = $(editorElement$f).text();
  assert.ok(text.indexOf('card-b') < text.indexOf('card-a'), 'card b is moved up');

  removeHook();

  assert.hasNoElement('h1:contains(card-b)');
});

const { module: module$P, test: test$P } = Helpers;

const cards$4 = [{
  name: 'my-card',
  type: 'dom',
  render() {},
  edit() {}
}];

let editor$f, editorElement$g;

module$P('Acceptance: editor: copy-paste', {
  beforeEach() {
    editorElement$g = $('#editor')[0];
  },
  afterEach() {
    if (editor$f) {
      editor$f.destroy();
      editor$f = null;
    }
    Helpers.dom.clearCopyData();
  }
});

// TODO: Modify these tests to use IE's nonstandard clipboard access pattern
// See: https://remysharp.com/2015/10/14/the-art-of-debugging
test$P('simple copy-paste at end of section works', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.selectText(editor$f, 'abc', editorElement$g);
  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[0].childNodes[0];
  assert.equal(textNode.textContent, 'abc'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, textNode.length);

  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');
});

test$P('paste plain text', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  let textNode = $('#editor p')[0].childNodes[0];
  assert.equal(textNode.textContent, 'abc'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, textNode.length);

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, 'abc');
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');
});

test$P('paste plain text with line breaks', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  let textNode = $('#editor p')[0].childNodes[0];
  assert.equal(textNode.textContent, 'abc'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, textNode.length);

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, ['abc', 'def'].join('\n'));
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');
  assert.hasElement('#editor p:contains(def)', 'second section is pasted');
  assert.equal($('#editor p').length, 2, 'adds a second section');
});

test$P('paste plain text with list items', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  let textNode = $('#editor p')[0].childNodes[0];
  assert.equal(textNode.textContent, 'abc'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, textNode.length);

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, ['* abc', '* def'].join('\n'));
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abcabc)', 'pastes the text');
  assert.hasElement('#editor ul li:contains(def)', 'list item is pasted');
});

test$P('paste plain text into an empty Mobiledoc', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post}) => {
    return post();
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, 'abc');
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abc)', 'pastes the text');
});

test$P('can cut and then paste content', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  assert.hasElement('#editor p:contains(abc)', 'precond - has p');

  Helpers.dom.selectText(editor$f, 'abc', editorElement$g);
  Helpers.dom.triggerCutEvent(editor$f);

  assert.hasNoElement('#editor p:contains(abc)',
                      'content removed after cutting');

  let textNode = $('#editor p')[0].childNodes[0];
  Helpers.dom.moveCursorTo(editor$f, textNode, textNode.length);

  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abc)', 'pastes the text');
});

test$P('paste when text is selected replaces that text', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  assert.hasElement('#editor p:contains(abc)', 'precond - has p');

  Helpers.dom.selectText(editor$f, 'bc', editorElement$g);
  Helpers.dom.triggerCopyEvent(editor$f);

  Helpers.dom.selectText(editor$f, 'a', editorElement$g);

  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(bcbc)',
                    'pastes, replacing the selection');
});

test$P('simple copy-paste with markup at end of section works', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker, markup}) => {
    return post([markupSection('p', [
      marker('a', [markup('strong')]),
      marker('bc')
    ])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.selectText(editor$f, 'a', editorElement$g, 'b', editorElement$g);
  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[0].childNodes[1];
  assert.equal(textNode.textContent, 'bc'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, textNode.length);

  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(abcab)', 'pastes the text');
  assert.equal($('#editor p strong:contains(a)').length, 2, 'two bold As');
});

test$P('simple copy-paste in middle of section works', (assert) => {
   const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abcd')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.selectText(editor$f, 'c', editorElement$g);
  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[0].childNodes[0];
  assert.equal(textNode.textContent, 'abcd'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, 1);

  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(acbcd)', 'pastes the text');
  Helpers.dom.insertText(editor$f, 'X');
  assert.hasElement('#editor p:contains(acXbcd)', 'inserts text in right spot');
});

test$P('simple copy-paste at start of section works', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abcd')])]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.selectText(editor$f, 'c', editorElement$g);
  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[0].childNodes[0];
  assert.equal(textNode.textContent, 'abcd'); //precond
  Helpers.dom.moveCursorTo(editor$f, textNode, 0);

  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor p:contains(cabcd)', 'pastes the text');
  Helpers.dom.insertText(editor$f, 'X');
  assert.hasElement('#editor p:contains(cXabcd)', 'inserts text in right spot');
});

test$P('copy-paste can copy cards', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker, cardSection}) => {
    return post([
      markupSection('p', [marker('abc')]),
      cardSection('test-card', {foo: 'bar'}),
      markupSection('p', [marker('123')])
    ]);
  });
  let cards = [{
    name: 'test-card',
    type: 'dom',
    render({payload}) {
      return $(`<div class='${payload.foo}'>${payload.foo}</div>`)[0];
    }
  }];
  editor$f = new Editor({mobiledoc, cards});
  editor$f.render(editorElement$g);

  assert.hasElement('#editor .bar', 'precond - renders card');

  let startEl = $('#editor p:eq(0)')[0],
      endEl = $('#editor p:eq(1)')[0];
  assert.equal(endEl.textContent, '123', 'precond - endEl has correct text');
  Helpers.dom.selectText(editor$f, 'c', startEl, '1', endEl);

  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[1].childNodes[0];
  assert.equal(textNode.textContent, '123', 'precond - correct textNode');

  Helpers.dom.moveCursorTo(editor$f, textNode, 2); // '3'
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.equal($('#editor .bar').length, 2, 'renders a second card');
});

test$P('copy-paste can copy list sections', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker, listSection, listItem}) => {
    return post([
      markupSection('p', [marker('abc')]),
      listSection('ul', [
        listItem([marker('list')])
      ]),
      markupSection('p', [marker('123')])
    ]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.selectText(editor$f, 'c', editor$f.element, '1', editor$f.element);

  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[1].childNodes[0];
  assert.equal(textNode.textContent, '123', 'precond - correct textNode');

  Helpers.dom.moveCursorTo(editor$f, textNode, 3); // end of node
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.equal($('#editor ul').length, 2, 'pastes the list');
  assert.hasElement($('#editor ul:eq(0) li:contains(list)'));
});

test$P('copy-paste can copy card following list section', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker, listSection, listItem, cardSection}) => {
      return post([
        markupSection('p', [marker('abc')]),
        listSection('ul', [
          listItem([marker('list')])
        ]),
        cardSection('test-card', {foo: 'bar'}),
        markupSection('p', [marker('123')])
      ]);
    });
  let cards = [{
    name: 'test-card',
    type: 'dom',
    render({ payload }) {
      return $(`<div class='${payload.foo}'>${payload.foo}</div>`)[0];
    }
  }];
  editor$f = new Editor({mobiledoc, cards});
  editor$f.render(editorElement$g);

  assert.hasElement('#editor .bar', 'precond - renders card');

  Helpers.dom.selectText(editor$f, 'c', editor$f.element, '3', editor$f.element);

  Helpers.dom.triggerCopyEvent(editor$f);

  let textNode = $('#editor p')[1].childNodes[0];
  assert.equal(textNode.textContent, '123', 'precond - correct textNode');

  Helpers.dom.moveCursorTo(editor$f, textNode, 3); // end of node
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.equal($('#editor ul').length, 2, 'pastes the list');
  assert.hasElement('#editor ul:eq(1) li:contains(list)');

  assert.equal($('#editor .bar').length, 2, 'renders a second card');
});

test$P('copy sets html & text for pasting externally', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker}) => {
      return post([
        markupSection('h1', [marker('h1 heading')]),
        markupSection('h2', [marker('h2 subheader')]),
        markupSection('p', [marker('The text')])
      ]);
  });
  editor$f = new Editor({mobiledoc});
  editor$f.render(editorElement$g);

  Helpers.dom.selectText(editor$f, 'heading', editor$f.element,
                         'The text', editor$f.element);

  Helpers.dom.triggerCopyEvent(editor$f);

  let html = Helpers.dom.getCopyData(MIME_TEXT_HTML);
  let text = Helpers.dom.getCopyData(MIME_TEXT_PLAIN);
  assert.equal(text, ["heading", "h2 subheader", "The text" ].join('\n'),
               'gets plain text');

  assert.ok(html.indexOf("<h1>heading") !== -1, 'html has h1');
  assert.ok(html.indexOf("<h2>h2 subheader") !== -1, 'html has h2');
  assert.ok(html.indexOf("<p>The text") !== -1, 'html has p');
});

test$P('pasting when cursor is on left/right side of card adds content before/after card', (assert) => {
  let expected1, expected2;
  editor$f = Helpers.mobiledoc.renderInto(editorElement$g, ({post, markupSection, cardSection, marker}) => {
    expected1 = post([
      markupSection('p', [marker('abc')]),
      cardSection('my-card')
    ]);

    expected2 = post([
      markupSection('p', [marker('abc')]),
      cardSection('my-card'),
      markupSection('p', [marker('123')])
    ]);

    return post([
      cardSection('my-card')
    ]);
  }, {cards: cards$4});

  let card = editor$f.post.sections.objectAt(0);
  assert.ok(card.isCardSection, 'precond - get card');

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, 'abc');
  editor$f.selectRange(card.headPosition());
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.postIsSimilar(editor$f.post, expected1, 'content pasted before card');

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, '123');
  editor$f.selectRange(card.tailPosition());
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.postIsSimilar(editor$f.post, expected2, 'content pasted after card');
});

// see https://github.com/bustle/mobiledoc-kit/issues/249
test$P('pasting when replacing a list item works', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, listSection, listItem, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('X')]),
      listSection('ul', [
        listItem([marker('Y')])
      ])
    ]);
  });

  editor$f = new Editor({mobiledoc, cards: cards$4});
  editor$f.render(editorElement$g);

  assert.hasElement('#editor li:contains(Y)', 'precond: has li with Y');

  Helpers.dom.selectText(editor$f, 'X', editorElement$g);
  Helpers.dom.triggerCopyEvent(editor$f);

  Helpers.dom.selectText(editor$f, 'Y', editorElement$g);
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.hasElement('#editor li:contains(X)', 'replaces Y with X in li');
  assert.hasNoElement('#editor li:contains(Y)', 'li with Y is gone');
});

test$P('paste with shift key pastes plain text', (assert) => {
  let expected;
  editor$f = Helpers.mobiledoc.renderInto(editorElement$g, ({post, markupSection, marker, markup}) => {
    expected = post([
      markupSection('p', [
        marker('a'), marker('b', [markup('b')]), marker('cabc')
      ])
    ]);
    return post([
      markupSection('p', [
        marker('a'), marker('b', [markup('b')]), marker('c')
      ])
    ]);
  });

  editor$f.selectRange(editor$f.post.toRange());
  Helpers.dom.triggerCopyEvent(editor$f);
  editor$f.selectRange(editor$f.post.tailPosition());

  Helpers.dom.triggerKeyEvent(editor$f, 'keydown', { keyCode: Keycodes.SHIFT });
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.postIsSimilar(editor$f.post, expected);
});

test$P('paste with html that parses to blank doc doesn\'t error', (assert) => {
  let expected;
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    expected = post([
      markupSection('p', [])
    ]);

    return post([
      markupSection('p', [marker('abcd')])
    ]);
  });

  editor$f = new Editor({mobiledoc, cards: cards$4});
  editor$f.render(editorElement$g);

  Helpers.dom.setCopyData('text/html', `<div></div>`);
  editor$f.selectRange(editor$f.post.toRange());
  Helpers.dom.triggerPasteEvent(editor$f);

  assert.postIsSimilar(editor$f.post, expected);
});

const { test: test$Q, module: module$Q } = Helpers;

let editor$g, editorElement$h;

module$Q('Acceptance: editor: #disableEditing', {
  beforeEach() {
    editorElement$h = $('#editor')[0];
  },
  afterEach() {
    if (editor$g) { editor$g.destroy(); }
  }
});

test$Q('#disableEditing before render is meaningful', (assert) => {
  editor$g = new Editor();
  editor$g.disableEditing();
  editor$g.render(editorElement$h);

  assert.equal(editorElement$h.getAttribute('contenteditable'),'false',
            'element is not contenteditable');
  editor$g.enableEditing();
  assert.equal(editorElement$h.getAttribute('contenteditable'), 'true',
               'element is contenteditable');
});

test$Q('when editing is disabled, the placeholder is not shown', (assert) => {
  editor$g = new Editor({placeholder: 'the placeholder'});
  editor$g.disableEditing();
  editor$g.render(editorElement$h);

  assert.isBlank(Helpers.dom.getData(editorElement$h, 'placeholder'),
    'no placeholder when disabled');
  editor$g.enableEditing();
  assert.equal(Helpers.dom.getData(editorElement$h, 'placeholder'), 'the placeholder',
               'placeholder is shown when editable');
});

test$Q('#disableEditing and #enableEditing toggle contenteditable', (assert) => {
  editor$g = new Editor();
  editor$g.render(editorElement$h);

  assert.equal(editorElement$h.getAttribute('contenteditable'),
               'true',
               'element is contenteditable');
  editor$g.disableEditing();
  assert.equal(editorElement$h.getAttribute('contenteditable'),
               'false',
               'element is not contenteditable');
  editor$g.enableEditing();
  assert.equal(editorElement$h.getAttribute('contenteditable'),
               'true',
               'element is contenteditable');
});

// https://github.com/bustle/mobiledoc-kit/issues/572
test$Q('pasting after #disableEditing does not insert text', function(assert) {
  editor$g = Helpers.editor.buildFromText('abc|', {element: editorElement$h});

  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, 'def');
  Helpers.dom.triggerPasteEvent(editor$g);
  assert.hasElement('#editor:contains(abcdef)', 'precond - text is pasted');

  editor$g.disableEditing();

  Helpers.dom.selectText(editor$g, 'def');
  Helpers.dom.setCopyData(MIME_TEXT_PLAIN, 'ghi');
  Helpers.dom.triggerPasteEvent(editor$g);
  assert.hasNoElement('#editor:contains(ghi)', 'text is not pasted after #disableEditing');
});

const { module: module$R, test: test$R } = Helpers;

let editor$h, editorElement$i;

function findCenterPointOfTextNode(node) {
  let range = document.createRange();
  range.setStart(node, 0);
  range.setEnd(node, node.textContent.length);

  let {left, top, width, height} = range.getBoundingClientRect();

  let clientX = left + width/2;
  let clientY = top + height/2;

  return {clientX, clientY};
}

module$R('Acceptance: editor: drag-drop', {
  beforeEach() {
    editorElement$i = $('#editor')[0];

    /**
     * `document.elementFromPoint` return `null` if the element is outside the
     * viewport, so force the editor element to be in the viewport for this test suite
     */
    $(editorElement$i).css({
      position: 'fixed',
      top: '100px',
      left: '100px'
    });
  },
  afterEach() {
    if (editor$h) {
      editor$h.destroy();
      editor$h = null;
    }
  }
});

test$R('inserts dropped HTML content at the drop position', (assert) => {
  let expected;
  editor$h = Helpers.mobiledoc.renderInto(editorElement$i, ({post, markupSection, marker}) => {
    expected = post([markupSection('h2', [marker('--->some text<---')])]);
    return post([markupSection('h2', [marker('---><---')])]);
  });

  let html = '<p>some text</p>';
  let node = Helpers.dom.findTextNode(editorElement$i, '---><---');
  let {clientX, clientY} = findCenterPointOfTextNode(node);
  Helpers.dom.triggerDropEvent(editor$h, {html, clientX, clientY});

  assert.postIsSimilar(editor$h.post, expected);
});

test$R('inserts dropped text content at the drop position if no html data', (assert) => {
  let expected;
  editor$h = Helpers.mobiledoc.renderInto(editorElement$i, ({post, markupSection, marker}) => {
    expected = post([markupSection('h2', [marker('--->some text<---')])]);
    return post([markupSection('h2', [marker('---><---')])]);
  });

  let text = 'some text';
  let node = Helpers.dom.findTextNode(editorElement$i, '---><---');
  let {clientX, clientY} = findCenterPointOfTextNode(node);
  Helpers.dom.triggerDropEvent(editor$h, {text, clientX, clientY});

  assert.postIsSimilar(editor$h.post, expected);
});

const { module: module$S, test: test$S } = Helpers;
const { editor: { buildFromText: buildFromText$6 } } = Helpers;
const { postAbstract: { DEFAULT_ATOM_NAME: DEFAULT_ATOM_NAME$2 } } = Helpers;

let editor$i, editorElement$j;

function renderEditor$1(...args) {
  editor$i = Helpers.mobiledoc.renderInto(editorElement$j, ...args);
  editor$i.selectRange(editor$i.post.tailPosition());
  return editor$i;
}

let atom = {
  name: DEFAULT_ATOM_NAME$2,
  type: 'dom',
  render() {}
};

module$S('Acceptance: Editor: Text Input Handlers', {
  beforeEach() {
    editorElement$j = $('#editor')[0];
  },
  afterEach() {
    if (editor$i) { editor$i.destroy(); }
  }
});

const headerTests = [{
  text: '#',
  toInsert: ' ',
  headerTagName: 'h1'
}, {
  text: '##',
  toInsert: ' ',
  headerTagName: 'h2'
}, {
  text: '###',
  toInsert: ' ',
  headerTagName: 'h3'
}, {
  text: '####',
  toInsert: ' ',
  headerTagName: 'h4'
}, {
  text: '#####',
  toInsert: ' ',
  headerTagName: 'h5'
}, {
  text: '######',
  toInsert: ' ',
  headerTagName: 'h6'
}];

headerTests.forEach(({text, toInsert, headerTagName}) => {
  test$S(`typing "${text}${toInsert}" converts to ${headerTagName}`, (assert) => {
    renderEditor$1(({post, markupSection, marker}) => {
      return post([markupSection('p',[marker(text)])]);
    });
    assert.hasElement('#editor p', 'precond - has p');
    Helpers.dom.insertText(editor$i, toInsert);
    assert.hasNoElement('#editor p', 'p is gone');
    assert.hasElement(`#editor ${headerTagName}`, `p -> ${headerTagName}`);

    // Different browsers report different selections, so we grab the selection
    // here and then set it to what we expect it to be, and compare what
    // window.getSelection() reports.
    // E.g., in Firefox getSelection() reports that the anchorNode is the "br",
    // but Safari and Chrome report that the anchorNode is the header element
    let selection = window.getSelection();

    let cursorElement = $(`#editor ${headerTagName} br`)[0];
    assert.ok(cursorElement, 'has cursorElement');
    Helpers.dom.selectRange(cursorElement, 0, cursorElement, 0);

    let newSelection = window.getSelection();
    assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');
    assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');
    assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');
    assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');

    Helpers.dom.insertText(editor$i, 'X');
    assert.hasElement(`#editor ${headerTagName}:contains(X)`, 'text is inserted correctly');
  });

  test$S(`typing "${text}" but not "${toInsert}" does not convert to ${headerTagName}`, (assert) => {
    editor$i = buildFromText$6(text, {element: editorElement$j});
    assert.hasElement('#editor p', 'precond - has p');
    Helpers.dom.insertText(editor$i, 'X');

    assert.hasElement('#editor p', 'still has p');
    assert.hasNoElement(`#editor ${headerTagName}`, `does not change to ${headerTagName}`);
  });
});

test$S('typing "* " converts to ul > li', (assert) => {
  renderEditor$1(({post, markupSection, marker}) => {
    return post([markupSection('p',[marker('*')])]);
  });

  Helpers.dom.insertText(editor$i, ' ');
  assert.hasNoElement('#editor p', 'p is gone');
  assert.hasElement('#editor ul > li', 'p -> "ul > li"');

  // Store the selection so we can compare later
  let selection = window.getSelection();
  let cursorElement = $('#editor ul > li > br')[0];
  assert.ok(cursorElement, 'has cursorElement for cursor position');
  Helpers.dom.selectRange(cursorElement, 0, cursorElement, 0);

  let newSelection = window.getSelection();
  assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');
  assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');
  assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');
  assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');

  Helpers.dom.insertText(editor$i, 'X');
  assert.hasElement('#editor ul > li:contains(X)', 'text is inserted correctly');
});

// see https://github.com/bustle/mobiledoc-kit/issues/280
test$S('typing "* " at start of markup section does not remove it', (assert) => {
  renderEditor$1(({post, markupSection, marker}) => {
    return post([markupSection('p',[marker('*abc')])]);
  });

  editor$i.selectRange(editor$i.post.sections.head.toPosition(1));

  Helpers.dom.insertText(editor$i, ' ');
  assert.hasElement('#editor p:contains(* abc)', 'p is still there');
});

test$S('typing "* " inside of a list section does not create a new list section', (assert) => {
  renderEditor$1(({post, listSection, listItem, marker}) => {
    return post([listSection('ul', [listItem([marker('*')])])]);
  });
  let position = editor$i.post.sections.head.items.head.tailPosition();
  editor$i.selectRange(position);

  assert.hasElement('#editor ul > li:contains(*)', 'precond - has li');

  Helpers.dom.insertText(editor$i, ' ');
  // note: the actual text is "*&nbsp;", so only check that the "*" is there,
  assert.hasElement('#editor ul > li', 'still has li');
  let el = $('#editor ul > li')[0];
  assert.equal(el.textContent, `*${NO_BREAK_SPACE}`);
});

test$S('typing "1 " converts to ol > li', (assert) => {
  editor$i = buildFromText$6(['1|'], {element: editorElement$j});
  Helpers.dom.insertText(editor$i, ' ');
  assert.hasNoElement('#editor p', 'p is gone');
  assert.hasElement('#editor ol > li', 'p -> "ol > li"');

  // Store the selection so we can compare later
  let selection = window.getSelection();
  let cursorElement = $('#editor ol > li > br')[0];
  assert.ok(cursorElement, 'has cursorElement for cursor position');
  Helpers.dom.selectRange(cursorElement, 0, cursorElement, 0);

  let newSelection = window.getSelection();
  assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');
  assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');
  assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');
  assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');

  Helpers.dom.insertText(editor$i, 'X');

  assert.hasElement('#editor li:contains(X)', 'text is inserted correctly');
});

test$S('typing "1. " converts to ol > li', (assert) => {
  editor$i = buildFromText$6('1.|', {element: editorElement$j});
  Helpers.dom.insertText(editor$i, ' ');
  assert.hasNoElement('#editor p', 'p is gone');
  assert.hasElement('#editor ol > li', 'p -> "ol > li"');
  Helpers.dom.insertText(editor$i, 'X');

  assert.hasElement('#editor li:contains(X)', 'text is inserted correctly');
});

test$S('an input handler will trigger anywhere in the text', (assert) => {
  editor$i = buildFromText$6('@abc@', {element: editorElement$j, atoms: [atom]});

  let expandCount = 0;
  let lastMatches;
  editor$i.onTextInput({
    name: 'at',
    text: '@',
    run: (editor, matches) => {
      expandCount++;
      lastMatches = matches;
    }
  });

  // at start
  editor$i.selectRange(editor$i.post.headPosition());
  Helpers.dom.insertText(editor$i, '@');
  assert.equal(expandCount, 1, 'expansion was run at start');
  assert.deepEqual(lastMatches, ['@'], 'correct match at start');

  // middle
  editor$i.selectRange(editor$i.post.sections.head.toPosition('@'.length + 1 + 'ab'.length));
  Helpers.dom.insertText(editor$i, '@');
  assert.equal(expandCount, 2, 'expansion was run at middle');
  assert.deepEqual(lastMatches, ['@'], 'correct match at middle');

  // end
  editor$i.selectRange(editor$i.post.tailPosition());
  Helpers.dom.insertText(editor$i, '@');
  assert.equal(expandCount, 3, 'expansion was run at end');
  assert.deepEqual(lastMatches, ['@'], 'correct match at end');
});

test$S('an input handler can provide a `match` instead of `text`', (assert) => {
  editor$i = buildFromText$6('@abc@', {element: editorElement$j, atoms: [atom]});

  let expandCount = 0;
  let lastMatches;
  let regex = /.(.)X$/;
  editor$i.onTextInput({
    name: 'test',
    match: regex,
    run: (editor, matches) => {
      expandCount++;
      lastMatches = matches;
    }
  });

  // at start
  editor$i.selectRange(new Range(editor$i.post.headPosition()));
  Helpers.dom.insertText(editor$i, 'abX');
  assert.equal(expandCount, 1, 'expansion was run at start');
  assert.deepEqual(lastMatches, regex.exec('abX'), 'correct match at start');

  // middle
  editor$i.selectRange(editor$i.post.sections.head.toPosition('abX'.length + 1 + 'ab'.length));
  Helpers.dom.insertText(editor$i, '..X');
  assert.equal(expandCount, 2, 'expansion was run at middle');
  assert.deepEqual(lastMatches, regex.exec('..X'), 'correct match at middle');

  // end
  editor$i.selectRange(new Range(editor$i.post.tailPosition()));
  Helpers.dom.insertText(editor$i, '**X');
  assert.equal(expandCount, 3, 'expansion was run at end');
  assert.deepEqual(lastMatches, regex.exec('**X'), 'correct match at end');
});

test$S('an input handler can provide a `match` that matches at start and end', (assert) => {
  editor$i = Helpers.editor.buildFromText(['@abc@'], {element: editorElement$j, atoms: [atom]});

  let expandCount = 0;
  let lastMatches;
  let regex = /^\d\d\d$/;
  editor$i.onTextInput({
    name: 'test',
    match: regex,
    run: (editor, matches) => {
      expandCount++;
      lastMatches = matches;
    }
  });

  // at start
  editor$i.selectRange(editor$i.post.headPosition());
  Helpers.dom.insertText(editor$i, '123');
  assert.equal(expandCount, 1, 'expansion was run at start');
  assert.deepEqual(lastMatches, regex.exec('123'), 'correct match at start');

  // middle
  editor$i.selectRange(editor$i.post.sections.head.toPosition('123'.length+2));
  Helpers.dom.insertText(editor$i, '123');
  assert.equal(expandCount, 1, 'expansion was not run at middle');

  // end
  editor$i.selectRange(editor$i.post.tailPosition());
  Helpers.dom.insertText(editor$i, '123');
  assert.equal(expandCount, 1, 'expansion was not run at end');
});

// See https://github.com/bustle/mobiledoc-kit/issues/400
test$S('input handler can be triggered by TAB', (assert) => {
  editor$i = Helpers.editor.buildFromText('abc|', {element: editorElement$j});

  let didMatch;
  editor$i.onTextInput({
    name: 'test',
    match: /abc\t/,
    run() {
      didMatch = true;
    }
  });

  Helpers.dom.insertText(editor$i, TAB);

  assert.ok(didMatch);
});

test$S('input handler can be triggered by ENTER', (assert) => {
  editor$i = Helpers.editor.buildFromText('abc|', {element: editorElement$j});

  let didMatch;
  editor$i.onTextInput({
    name: 'test',
    match: /abc\n/,
    run() {
      didMatch = true;
    }
  });

  Helpers.dom.insertText(editor$i, ENTER);

  assert.ok(didMatch);
});

// See https://github.com/bustle/mobiledoc-kit/issues/565
test$S('typing ctrl-TAB does not insert TAB text', (assert) => {
  editor$i = Helpers.editor.buildFromText('abc|', {element: editorElement$j});

  Helpers.dom.triggerKeyCommand(editor$i, TAB, [MODIFIERS.CTRL]);

  assert.equal(editorElement$j.textContent, 'abc', 'no TAB is inserted');
});

test$S('can unregister all handlers', (assert) => {
  editor$i = Helpers.editor.buildFromText('');
  // there are 3 default helpers
  assert.equal(editor$i._eventManager._textInputHandler._handlers.length, 3);
  editor$i.onTextInput({
    name: 'first',
    match: /abc\t/,
    run() {}
  });
  editor$i.onTextInput({
    name: 'second',
    match: /abc\t/,
    run() {}
  });
  assert.equal(editor$i._eventManager._textInputHandler._handlers.length, 5);
  editor$i.unregisterAllTextInputHandlers();
  assert.equal(editor$i._eventManager._textInputHandler._handlers.length, 0);
});

test$S('can unregister handler by name', (assert) => {
  editor$i = Helpers.editor.buildFromText('');
  const handlerName = 'ul';
  let handlers = editor$i._eventManager._textInputHandler._handlers;
  assert.ok(handlers.filter(handler => handler.name === handlerName).length);
  editor$i.unregisterTextInputHandler(handlerName);
  assert.notOk(handlers.filter(handler => handler.name === handlerName).length);
});

test$S('can unregister handlers by duplicate name', (assert) => {
  editor$i = Helpers.editor.buildFromText('');
  const handlerName = 'ul';
  editor$i.onTextInput({
    name: handlerName,
    match: /abc/,
    run() {}
  });
  let handlers = editor$i._eventManager._textInputHandler._handlers;
  assert.equal(handlers.length, 4); // 3 default + 1 custom handlers
  editor$i.unregisterTextInputHandler(handlerName);
  assert.equal(handlers.length, 2);
  assert.notOk(handlers.filter(handler => handler.name === handlerName).length);
});

const { module: module$T, test: test$T, skip: skip$1 } = Helpers;

let editor$j, editorElement$k;

function labelForModifier(key) {
  switch (key) {
  case MODIFIERS.META: return 'META';
  case MODIFIERS.CTRL: return 'CTRL';
  }
}

module$T('Acceptance: Editor: Key Commands', {
  beforeEach() {
    editorElement$k = $('#editor')[0];
  },
  afterEach() {
    if (editor$j) {
      editor$j.destroy();
      editor$j = null;
    }
  }
});

function testStatefulCommand({modifierName, key, command, markupName}) {
  test$T(`${command} applies markup ${markupName} to highlighted text`, (assert) => {
    assert.expect(3);
    let done = assert.async();

    let modifier = MODIFIERS[modifierName];
    let modifierKeyCode = Keycodes[modifierName];
    let initialText = 'something';
    editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
      markupSection('p', [marker(initialText)])
    ]));

    assert.ok(editor$j.hasCursor(), 'precond - editor should have cursor');

    assert.hasNoElement(`#editor ${markupName}`, `precond - no ${markupName} text`);
    Helpers.dom.selectText(editor$j ,initialText, editorElement$k);
    Helpers.dom.triggerKeyCommand(editor$j, key, modifier);
    Helpers.dom.triggerKeyEvent(editor$j, 'keyup', {charCode: 0, keyCode: modifierKeyCode});

    Helpers.wait(() => {
      assert.hasElement(`#editor ${markupName}:contains(${initialText})`,
                        `text wrapped in ${markupName}`);
      done();
    });
  });

  test$T(`${command} toggles ${markupName} for next entered text`, (assert) => {
    let done = assert.async();
    assert.expect(8);

    let modifier = MODIFIERS[modifierName];
    let modifierKeyCode = Keycodes[modifierName];
    let initialText = 'something';

    editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
      markupSection('p', [marker(initialText)])
    ]));

    assert.ok(editor$j.hasCursor(), 'has cursor');

    assert.hasNoElement(`#editor ${markupName}`, `precond - no ${markupName} text`);
    Helpers.dom.moveCursorTo(editor$j,
      editor$j.post.sections.head.markers.head.renderNode.element,
      initialText.length);

    Helpers.wait(() => {
      Helpers.dom.triggerKeyCommand(editor$j, key, modifier);
      // simulate meta/ctrl keyup
      Helpers.dom.triggerKeyEvent(editor$j, 'keyup', { charCode: 0, keyCode:  modifierKeyCode});

      Helpers.wait(() => {
        Helpers.dom.insertText(editor$j, 'z');

        let expected1 = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
          return post([
            markupSection('p', [
              marker(initialText),
              marker('z', [markup(markupName)])
            ])
          ]);
        });
        let expected2 = Helpers.postAbstract.build(({post, markupSection, marker, markup}) => {
          return post([
            markupSection('p', [
              marker(initialText),
              marker('z', [markup(markupName)]),
              marker('x')
            ])
          ]);
        });

        assert.postIsSimilar(editor$j.post, expected1);
        assert.renderTreeIsEqual(editor$j._renderTree, expected1);
        assert.positionIsEqual(editor$j.range.head, editor$j.post.tailPosition());

        Helpers.wait(() => {
          // un-toggles markup
          Helpers.dom.triggerKeyCommand(editor$j, key, modifier);
          Helpers.dom.triggerKeyEvent(editor$j, 'keyup', {charCode: 0, keyCode: modifierKeyCode});

          Helpers.wait(() => {
            Helpers.dom.insertText(editor$j, 'x');

            assert.postIsSimilar(editor$j.post, expected2);
            assert.renderTreeIsEqual(editor$j._renderTree, expected2);
            assert.positionIsEqual(editor$j.range.head, editor$j.post.tailPosition());

            done();
          });
        });
      });
    });
  });
}

testStatefulCommand({
  modifierName: 'META',
  key: 'B',
  command: 'command-B',
  markupName: 'strong'
});

testStatefulCommand({
  modifierName: 'CTRL',
  key: 'B',
  command: 'ctrl-B',
  markupName: 'strong'
});

testStatefulCommand({
  modifierName: 'META',
  key: 'I',
  command: 'command-I',
  markupName: 'em'
});

testStatefulCommand({
  modifierName: 'CTRL',
  key: 'I',
  command: 'ctrl-I',
  markupName: 'em'
});

testStatefulCommand({
  modifierName: 'META',
  key: 'U',
  command: 'command-U',
  markupName: 'u'
});

testStatefulCommand({
  modifierName: 'CTRL',
  key: 'U',
  command: 'ctrl-U',
  markupName: 'u'
});

if (Browser.isMac()) {
  test$T(`[Mac] ctrl-k clears to the end of a line`, (assert) => {
    let initialText = 'something';
    editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
      markupSection('p', [marker(initialText)])
    ]));

    assert.ok(editor$j.hasCursor(), 'has cursor');

    let textElement = editor$j.post.sections.head.markers.head.renderNode.element;
    Helpers.dom.moveCursorTo(editor$j, textElement, 4);
    Helpers.dom.triggerKeyCommand(editor$j, 'K', MODIFIERS.CTRL);

    let changedMobiledoc = editor$j.serialize();
    let expectedMobiledoc = Helpers.mobiledoc.build(
      ({post, markupSection, marker}) => {
        return post([
          markupSection('p', [
            marker('some')
          ])
        ]);
    });
    assert.deepEqual(changedMobiledoc, expectedMobiledoc,
                     'mobiledoc updated appropriately');
  });

  test$T(`[Mac] ctrl-k clears selected text`, (assert) => {
    let initialText = 'something';
    editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
      markupSection('p', [marker(initialText)])
    ]));

    assert.ok(editor$j.hasCursor(), 'has cursor');

    let textElement = editor$j.post.sections.head.markers.head.renderNode.element;
    Helpers.dom.moveCursorTo(editor$j, textElement, 4, textElement, 8);
    Helpers.dom.triggerKeyCommand(editor$j, 'K', MODIFIERS.CTRL);

    let changedMobiledoc = editor$j.serialize();
    let expectedMobiledoc = Helpers.mobiledoc.build(
      ({post, markupSection, marker}) => {
        return post([
          markupSection('p', [
            marker('someg')
          ])
        ]);
    });
    assert.deepEqual(changedMobiledoc, expectedMobiledoc,
                     'mobiledoc updated appropriately');
  });
}

let toggleLinkTest = (assert, modifier) => {
  assert.expect(3);

  let url = 'http://bustle.com';
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  editor$j.registerKeyCommand({
    str: `${labelForModifier(modifier)}+K`,
    run(editor) {
      toggleLink(editor, (prompt, defaultUrl, callback) => {
        assert.ok(true, 'calls showPrompt');
        callback(url);
      });
    }
  });

  assert.ok(editor$j.hasCursor(), 'has cursor');

  Helpers.dom.selectText(editor$j ,'something', editorElement$k);
  Helpers.dom.triggerKeyCommand(editor$j, 'K', modifier);

  assert.hasElement(`#editor a[href="${url}"]:contains(something)`);
};

let toggleLinkUnlinkTest = (assert, modifier) => {
  assert.expect(4);

  let url = 'http://bustle.com';
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker, markup}) => post([
    markupSection('p', [marker('something', [markup('a', {href:url})])])
  ]));

  editor$j.registerKeyCommand({
    str: `${labelForModifier(modifier)}+K`,
    run(editor) {
      toggleLink(editor, (prompt, defaultUrl, callback) => {
        assert.ok(false, 'should not call showPrompt');
        callback(url);
      });
    }
  });

  assert.ok(editor$j.hasCursor(), 'has cursor');

  assert.hasElement(`#editor a[href="${url}"]:contains(something)`,
                    'precond -- has link');

  Helpers.dom.selectText(editor$j ,'something', editorElement$k);
  Helpers.dom.triggerKeyCommand(editor$j, 'K', modifier);

  assert.hasNoElement(`#editor a[href="${url}"]:contains(something)`,
                     'removes linked text');
  assert.hasElement(`#editor p:contains(something)`, 'unlinked text remains');
};

let toggleTests = [
  {
    precondition: () => Browser.isMac(),
    msg: '[Mac] cmd-k links selected text',
    testFn: toggleLinkTest,
    modifier: MODIFIERS.META
  },
  {
    precondition: () => Browser.isMac(),
    msg: '[Mac] cmd-k unlinks selected text if it was already linked',
    testFn: toggleLinkUnlinkTest,
    modifier: MODIFIERS.META
  },
  {
    precondition: () => Browser.isWin(),
    msg: '[Windows] ctrl-k links selected text',
    testFn: toggleLinkTest,
    modifier: MODIFIERS.CTRL
  },
  {
    precondition: () => Browser.isWin(),
    msg: '[Windows] ctrl-k unlinks selected text if it was already linked',
    testFn: toggleLinkUnlinkTest,
    modifier: MODIFIERS.CTRL
  },
];

toggleTests.forEach(({precondition, msg, testFn, modifier}) => {
  if (!precondition()) {
    skip$1(msg);
  } else {
    test$T(msg, (assert) => {
      testFn(assert, modifier);
    });
  }
});

test$T('new key commands can be registered', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');

  let passedEditor;
  editor$j.registerKeyCommand({
    str: 'ctrl+x',
    run(editor) { passedEditor = editor; }
  });

  Helpers.dom.triggerKeyCommand(editor$j, 'Y', MODIFIERS.CTRL);

  assert.ok(!passedEditor, 'incorrect key combo does not trigger key command');

  Helpers.dom.triggerKeyCommand(editor$j, 'X', MODIFIERS.CTRL);

  assert.ok(!!passedEditor && passedEditor === editor$j, 'run method is called');
});

test$T('new key commands can be registered without modifiers', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');

  let passedEditor;
  editor$j.registerKeyCommand({
    str: 'X',
    run(editor) { passedEditor = editor; }
  });

  Helpers.dom.triggerKeyCommand(editor$j, 'Y', MODIFIERS.CTRL);

  assert.ok(!passedEditor, 'incorrect key combo does not trigger key command');

  Helpers.dom.triggerKeyCommand(editor$j, 'X', MODIFIERS.CTRL);

  assert.ok(!passedEditor, 'key with modifier combo does not trigger key command');

  Helpers.dom.triggerKeyCommand(editor$j, 'X');

  assert.ok(!!passedEditor && passedEditor === editor$j, 'run method is called');
});

test$T('duplicate key commands can be registered with the last registered winning', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');

  let firstCommandRan, secondCommandRan;

  editor$j.registerKeyCommand({
    str: 'ctrl+x',
    run() { firstCommandRan = true; }
  });
  editor$j.registerKeyCommand({
    str: 'ctrl+x',
    run() { secondCommandRan = true; }
  });

  Helpers.dom.triggerKeyCommand(editor$j, 'X', MODIFIERS.CTRL);

  assert.ok(!firstCommandRan, 'first registered method not called');
  assert.ok(!!secondCommandRan, 'last registered method is called');
});

test$T('returning false from key command causes next match to run', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');

  let firstCommandRan, secondCommandRan;

  editor$j.registerKeyCommand({
    str: 'ctrl+x',
    run() { firstCommandRan = true; }
  });
  editor$j.registerKeyCommand({
    str: 'ctrl+x',
    run() {
      secondCommandRan = true;
      return false;
    }
  });

  Helpers.dom.triggerKeyCommand(editor$j, 'X', MODIFIERS.CTRL);

  assert.ok(!!secondCommandRan, 'last registered method is called');
  assert.ok(!!firstCommandRan, 'first registered method is called');
});

test$T('key commands can override built-in functionality', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');

  let passedEditor;
  editor$j.registerKeyCommand({
    str: 'enter',
    run(editor) { passedEditor = editor; }
  });

  assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');

  Helpers.dom.moveCursorTo(editor$j, editorElement$k.childNodes[0].childNodes[0], 5);
  Helpers.dom.triggerEnter(editor$j);

  assert.ok(!!passedEditor && passedEditor === editor$j, 'run method is called');

  assert.equal($('#editor p').length, 1, 'still has just one paragraph');
});

test$T('returning false from key command still runs built-in functionality', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');

  let passedEditor;
  editor$j.registerKeyCommand({
    str: 'enter',
    run(editor) {
      passedEditor = editor;
      return false;
    }
  });

  assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');

  Helpers.dom.moveCursorTo(editor$j, editorElement$k.childNodes[0].childNodes[0], 5);
  Helpers.dom.triggerEnter(editor$j);

  assert.ok(!!passedEditor && passedEditor === editor$j, 'run method is called');

  assert.equal($('#editor p').length, 2, 'has added a new paragraph');
});

test$T('new key commands can be registered and then unregistered', (assert) => {
  editor$j = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$k, ({post, markupSection, marker}) => post([
    markupSection('p', [marker('something')])
  ]));

  assert.ok(editor$j.hasCursor(), 'has cursor');
  let passedEditorCount = 0;
  let passedEditor;
  editor$j.registerKeyCommand({
    name: 'cut',
    str: 'ctrl+x',
    run(editor) { passedEditor = editor; passedEditorCount++; }
  });

  editor$j.registerKeyCommand({
    name: 'cut',
    str: 'ctrl+d',
    run(editor) { passedEditor = editor; passedEditorCount++; }
  });

  Helpers.dom.triggerKeyCommand(editor$j, 'x', MODIFIERS.CTRL);
  Helpers.dom.triggerKeyCommand(editor$j, 'd', MODIFIERS.CTRL);

  assert.ok(!!passedEditor && passedEditor === editor$j, 'run method is called');
  assert.ok(passedEditorCount === 2, 'the passedEditor has been called twice');

  editor$j.unregisterKeyCommands('cut');

  Helpers.dom.triggerKeyCommand(editor$j, 'x', MODIFIERS.CTRL);
  Helpers.dom.triggerKeyCommand(editor$j, 'd', MODIFIERS.CTRL);

  assert.ok(passedEditorCount === 2, 'the passedEditor has still only been called twice');
});

const { module: module$U, test: test$U } = Helpers;

let editor$k, editorElement$l;


function listMobileDoc() {
  return Helpers.mobiledoc.build(({post, listSection, listItem, marker}) =>
    post([
      listSection('ul', [
        listItem([marker('first item')]),
        listItem([marker('second item')])
      ])
    ])
  );
}

function createEditorWithMobiledoc(mobiledoc) {
  editor$k = new Editor({mobiledoc});
  editor$k.render(editorElement$l);
}

function createEditorWithListMobiledoc() {
  createEditorWithMobiledoc(listMobileDoc());
}

module$U('Acceptance: Editor: Lists', {
  beforeEach() {
    editorElement$l = $('#editor')[0];
  },
  afterEach() {
    if (editor$k) { editor$k.destroy(); }
  }
});

test$U('can type in middle of a list item', (assert) => {
  createEditorWithListMobiledoc();

  const listItem = $('#editor li:contains(first item)')[0];
  assert.ok(!!listItem, 'precond - has li');

  Helpers.dom.moveCursorTo(editor$k, listItem.childNodes[0], 'first'.length);
  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(firstX item)', 'inserts text at right spot');
});

test$U('can type at end of a list item', (assert) => {
  createEditorWithListMobiledoc();

  const listItem = $('#editor li:contains(first item)')[0];
  assert.ok(!!listItem, 'precond - has li');

  Helpers.dom.moveCursorTo(editor$k, listItem.childNodes[0], 'first item'.length);
  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(first itemX)', 'inserts text at right spot');
});

test$U('can type at start of a list item', (assert) => {
  createEditorWithListMobiledoc();

  const listItem = $('#editor li:contains(first item)')[0];
  assert.ok(!!listItem, 'precond - has li');

  Helpers.dom.moveCursorTo(editor$k, listItem.childNodes[0], 0);
  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(Xfirst item)', 'inserts text at right spot');
});

test$U('can delete selection across list items', (assert) => {
  createEditorWithListMobiledoc();

  const listItem = $('#editor li:contains(first item)')[0];
  assert.ok(!!listItem, 'precond - has li1');

  const listItem2 = $('#editor li:contains(second item)')[0];
  assert.ok(!!listItem2, 'precond - has li2');

  Helpers.dom.selectText(editor$k ,' item', listItem, 'secon', listItem2);
  Helpers.dom.triggerDelete(editor$k);

  assert.hasElement('#editor li:contains(d item)', 'results in correct text');
  assert.equal($('#editor li').length, 1, 'only 1 remaining li');
});

test$U('can exit list section altogether by deleting', (assert) => {
  createEditorWithListMobiledoc();

  const listItem2 = $('#editor li:contains(second item)')[0];
  assert.ok(!!listItem2, 'precond - has listItem2');

  Helpers.dom.moveCursorTo(editor$k, listItem2.childNodes[0], 0);
  Helpers.dom.triggerDelete(editor$k);

  assert.hasElement('#editor li:contains(first item)', 'still has first item');
  assert.hasNoElement('#editor li:contains(second item)', 'second li is gone');
  assert.hasElement('#editor p:contains(second item)', 'second li becomes p');

  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor p:contains(Xsecond item)', 'new text is in right spot');
});

test$U('can split list item with <enter>', (assert) => {
  createEditorWithListMobiledoc();

  let li = $('#editor li:contains(first item)')[0];
  assert.ok(!!li, 'precond');

  Helpers.dom.moveCursorTo(editor$k, li.childNodes[0], 'fir'.length);
  Helpers.dom.triggerEnter(editor$k);

  assert.hasNoElement('#editor li:contains(first item)', 'first item is split');
  assert.hasElement('#editor li:contains(fir)', 'has split "fir" li');
  assert.hasElement('#editor li:contains(st item)', 'has split "st item" li');
  assert.hasElement('#editor li:contains(second item)', 'has unchanged last li');
  assert.equal($('#editor li').length, 3, 'has 3 lis');

  // hitting enter can create the right DOM but put the AT out of sync with the
  // renderTree, so we must hit enter once more to fully test this

  li = $('#editor li:contains(fir)')[0];
  assert.ok(!!li, 'precond - has "fir"');
  Helpers.dom.moveCursorTo(editor$k, li.childNodes[0], 'fi'.length);
  Helpers.dom.triggerEnter(editor$k);

  assert.hasNoElement('#editor li:contains(fir)');
  assert.hasElement('#editor li:contains(fi)', 'has split "fi" li');
  assert.hasElement('#editor li:contains(r)', 'has split "r" li');
  assert.equal($('#editor li').length, 4, 'has 4 lis');
});

test$U('can hit enter at end of list item to add new item', (assert) => {
  let done = assert.async();
  createEditorWithListMobiledoc();

  const li = $('#editor li:contains(first item)')[0];
  assert.ok(!!li, 'precond');

  Helpers.dom.moveCursorTo(editor$k, li.childNodes[0], 'first item'.length);
  Helpers.dom.triggerEnter(editor$k);

  assert.equal($('#editor li').length, 3, 'adds a new li');
  let newLi = $('#editor li:eq(1)');
  assert.equal(newLi.text(), '', 'new li has no text');

  Helpers.dom.insertText(editor$k, 'X');
  Helpers.wait(() => {
    assert.hasElement('#editor li:contains(X)', 'text goes in right spot');

    const liCount = $('#editor li').length;
    Helpers.dom.triggerEnter(editor$k);
    Helpers.dom.triggerEnter(editor$k);

    assert.equal($('#editor li').length, liCount+2, 'adds two new empty list items');
    done();
  });
});

test$U('hitting enter to add list item, deleting to remove it, adding new list item, exiting list and typing', (assert) => {
  createEditorWithListMobiledoc();

  let li = $('#editor li:contains(first item)')[0];
  assert.ok(!!li, 'precond');

  Helpers.dom.moveCursorTo(editor$k, li.childNodes[0], 'first item'.length);
  Helpers.dom.triggerEnter(editor$k);

  assert.equal($('#editor li').length, 3, 'adds a new li');

  Helpers.dom.triggerDelete(editor$k);

  assert.equal($('#editor li').length, 2, 'removes middle, empty li after delete');
  assert.equal($('#editor p').length, 1, 'adds a new paragraph section where delete happened');

  li = $('#editor li:contains(first item)')[0];
  Helpers.dom.moveCursorTo(editor$k, li.childNodes[0], 'first item'.length);
  Helpers.dom.triggerEnter(editor$k);

  assert.equal($('#editor li').length, 3, 'adds a new li after enter again');

  Helpers.dom.triggerEnter(editor$k);

  assert.equal($('#editor li').length, 2,
               'removes newly added li after enter on last list item');
  assert.equal($('#editor p').length, 2, 'adds a second p section');

  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor p:eq(0):contains(X)', 'inserts text in right spot');
});

test$U('hitting enter at empty last list item exists list', (assert) => {
  createEditorWithListMobiledoc();

  assert.equal($('#editor p').length, 0, 'precond - no ps');

  const li = $('#editor li:contains(second item)')[0];
  assert.ok(!!li, 'precond');

  Helpers.dom.moveCursorTo(editor$k, li.childNodes[0], 'second item'.length);
  Helpers.dom.triggerEnter(editor$k);

  assert.equal($('#editor li').length, 3, 'precond - adds a third li');

  Helpers.dom.triggerEnter(editor$k);

  assert.equal($('#editor li').length, 2, 'removes empty li');
  assert.equal($('#editor p').length, 1, 'adds 1 new p');
  assert.equal($('#editor p').text(), '', 'p has no text');
  assert.hasNoElement('#editor ul p', 'does not nest p under ul');

  Helpers.dom.insertText(editor$k, 'X');
  assert.hasElement('#editor p:contains(X)', 'text goes in right spot');
});

// https://github.com/bustle/mobiledoc-kit/issues/117
test$U('deleting at start of non-empty section after list item joins it with list item', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, markupSection, marker, listSection, listItem} = builder;
    return post([
      listSection('ul', [listItem([marker('abc')])]),
      markupSection('p', [marker('def')])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  const p = $('#editor p:contains(def)')[0];
  Helpers.dom.moveCursorTo(editor$k, p.childNodes[0], 0);
  Helpers.dom.triggerDelete(editor$k);

  assert.hasNoElement('#editor p');
  assert.hasElement('#editor li:contains(abcdef)');
});

// https://github.com/bustle/mobiledoc-kit/issues/117
test$U('deleting at start of empty section after list item joins it with list item', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, markupSection, marker, listSection, listItem} = builder;
    return post([
      listSection('ul', [listItem([marker('abc')])]),
      markupSection('p')
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  assert.hasElement('#editor p br', 'precond - br');
  const node = $('#editor p br')[0];
  Helpers.dom.moveCursorTo(editor$k, node, 0);
  Helpers.dom.triggerDelete(editor$k);

  assert.hasNoElement('#editor p', 'removes p');

  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(abcX)', 'inserts text at right spot');
});

test$U('forward-delete in empty list item with nothing after it does nothing', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem} = builder;
    return post([
      listSection('ul', [listItem()])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  assert.hasElement('#editor li br', 'precond - br');
  const node = $('#editor li br')[0];
  Helpers.dom.moveCursorTo(editor$k, node, 0);
  Helpers.dom.triggerForwardDelete(editor$k);

  assert.hasElement('#editor li', 'li remains');

  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(X)', 'inserts text at right spot');
});

test$U('forward-delete in empty li with li after it joins with li', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem, marker} = builder;
    return post([
      listSection('ul', [listItem(), listItem([marker('abc')])])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  assert.equal($('#editor li').length, 2, 'precond - 2 lis');
  assert.hasElement('#editor li br', 'precond - br');
  const node = $('#editor li br')[0];
  Helpers.dom.moveCursorTo(editor$k, node, 0);
  Helpers.dom.triggerForwardDelete(editor$k);

  assert.equal($('#editor li').length, 1, '1 li remains');
  assert.hasElement('#editor li:contains(abc)', 'correct li remains');

  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(Xabc)', 'inserts text at right spot');
});

test$U('forward-delete in empty li with markup section after it joins markup section', (assert) => {
   const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem, markupSection, marker} = builder;
    return post([
      listSection('ul', [listItem()]),
      markupSection('p', [marker('abc')])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  assert.hasElement('#editor li br', 'precond - br');
  const node = $('#editor li br')[0];
  Helpers.dom.moveCursorTo(editor$k, node, 0);
  Helpers.dom.triggerForwardDelete(editor$k);

  assert.hasElement('#editor li:contains(abc)', 'joins markup section');
  assert.hasNoElement('#editor p', 'p is removed');

  Helpers.dom.insertText(editor$k, 'X');

  assert.hasElement('#editor li:contains(Xabc)', 'inserts text at right spot');
});

test$U('forward-delete end of li with nothing after', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem, marker} = builder;
    return post([
      listSection('ul', [listItem([marker('abc')])])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  const node = $('#editor li')[0].childNodes[0];
  Helpers.dom.moveCursorTo(editor$k, node, 'abc'.length);
  Helpers.dom.triggerForwardDelete(editor$k);

  assert.hasElement('#editor li:contains(abc)', 'li remains');
  Helpers.dom.insertText(editor$k, 'X');
  assert.hasElement('#editor li:contains(abcX)', 'inserts text at right spot');
});

test$U('forward-delete end of li with li after', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem, marker} = builder;
    return post([
      listSection('ul', [
        listItem([marker('abc')]),
        listItem([marker('def')])
      ])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  assert.equal($('#editor li').length, 2, 'precond - 2 lis');
  const node = $('#editor li')[0].childNodes[0];
  Helpers.dom.moveCursorTo(editor$k, node, 'abc'.length);
  Helpers.dom.triggerForwardDelete(editor$k);

  assert.hasElement('#editor li:contains(abcdef)', 'li is joined');
  assert.equal($('#editor li').length, 1, 'only 1 li');
  Helpers.dom.insertText(editor$k, 'X');
  assert.hasElement('#editor li:contains(abcXdef)', 'inserts text at right spot');
});

test$U('forward-delete end of li with markup section after', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem, marker, markupSection} = builder;
    return post([
      listSection('ul', [listItem([marker('abc')])]),
      markupSection('p', [marker('def')])
    ]);
  });
  createEditorWithMobiledoc(mobiledoc);

  const node = $('#editor li')[0].childNodes[0];
  Helpers.dom.moveCursorTo(editor$k, node, 'abc'.length);
  Helpers.dom.triggerForwardDelete(editor$k);

  assert.hasElement('#editor li:contains(abcdef)', 'li is joined');
  assert.equal($('#editor li').length, 1, 'only 1 li');
  assert.hasNoElement('#editor p', 'p is removed');
  Helpers.dom.insertText(editor$k, 'X');
  assert.hasElement('#editor li:contains(abcXdef)', 'inserts text at right spot');
});

// see https://github.com/bustle/mobiledoc-kit/issues/130
test$U('selecting empty list items does not cause error', (assert) => {
  const done = assert.async();
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, listSection, listItem, marker} = builder;
    return post([
      listSection('ul', [
        listItem([marker('abc')]),
        listItem(),
        listItem([marker('def')])
      ])
    ]);
  });

  createEditorWithMobiledoc(mobiledoc);

  assert.equal($('#editor li').length, 3, 'precond - 3 lis');
  Helpers.dom.moveCursorTo(editor$k, $('#editor li:eq(1)')[0], 0,
                           $('#editor li:eq(2)')[0], 0);
  Helpers.dom.triggerEvent(editor$k.element, 'click');
  Helpers.wait(() => {
    assert.ok(true, 'no error');

    Helpers.dom.insertText(editor$k, 'X');
    assert.hasElement('#editor li:contains(Xdef)', 'insert text');
    assert.equal($('#editor li').length, 2, 'inserting text deletes selected li');
    done();
  });
});

// see https://github.com/bustle/mobiledoc-kit/issues/128
test$U('selecting list item and deleting leaves following section intact', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(builder => {
    const {post, markupSection, listSection, listItem, marker} = builder;
    return post([
      listSection('ul', [
        listItem([marker('abc')]), listItem()
      ]),
      markupSection('p', [marker('123')])
    ]);
  });

  createEditorWithMobiledoc(mobiledoc);

  // precond
  assert.hasElement('#editor p:contains(123)');
  assert.hasElement('#editor li:contains(abc)');

  const liTextNode  = $('#editor li:eq(0)')[0].childNodes[0];
  const emptyLiNode = $('#editor li:eq(1)')[0];
  assert.equal(liTextNode.textContent, 'abc'); // precond
  Helpers.dom.moveCursorTo(editor$k, liTextNode, 0, emptyLiNode, 0);
  Helpers.dom.triggerDelete(editor$k);

  assert.hasElement('#editor p', 'does not delete p');
  Helpers.dom.insertText(editor$k, 'X');
  assert.hasNoElement('#editor li:contains(abc)', 'li text is removed');
  assert.hasElement('#editor li:contains(X)', 'text is inserted');
});

test$U('list sections may contain attributes', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, listSection, listItem, marker}) => {
    return post([
      listSection('ul', [
        listItem([marker('abc')]), listItem()
      ], {'data-md-text-align': 'center'})
    ]);
  });

  editor$k = new Editor({mobiledoc});
  editor$k.render(editorElement$l);

  assert.hasElement('#editor ul[data-md-text-align="center"]');
});

const { module: module$V, test: test$V } = Helpers;

let editor$l, editorElement$m;

module$V('Acceptance: Editor - PostEditor', {
  beforeEach() {
    editorElement$m = $('#editor')[0];
  },
  afterEach() {
    if (editor$l) { editor$l.destroy(); }
  }
});

test$V('#insertSectionAtEnd inserts the section at the end', (assert) => {
  let newSection;
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    newSection = markupSection('p', [marker('123')]);
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  //precond
  assert.hasElement('#editor p:contains(abc)');
  assert.hasNoElement('#editor p:contains(123)');

  editor$l.run(postEditor => postEditor.insertSectionAtEnd(newSection));
  assert.hasElement('#editor p:eq(1):contains(123)', 'new section added at end');
});

test$V('#insertSection inserts after the cursor active section', (assert) => {
  let newSection;
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    newSection = markupSection('p', [marker('123')]);
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('def')])
    ]);
  });
  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  //precond
  assert.hasElement('#editor p:eq(0):contains(abc)');
  assert.hasElement('#editor p:eq(1):contains(def)');
  assert.hasNoElement('#editor p:contains(123)');

  Helpers.dom.selectText(editor$l ,'b', editorElement$m);

  editor$l.run(postEditor => postEditor.insertSection(newSection));
  assert.hasElement('#editor p:eq(0):contains(abc)', 'still has 1st section');
  assert.hasElement('#editor p:eq(1):contains(123)',
                    'new section added after active section');
  assert.hasElement('#editor p:eq(2):contains(def)', '2nd section -> 3rd spot');
});

test$V('#insertSection inserts at end when no active cursor section', (assert) => {
  let newSection;
  editor$l = Helpers.mobiledoc.renderInto(editorElement$m, ({post, markupSection, marker}) => {
    newSection = markupSection('p', [marker('123')]);
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('def')])
    ]);
  }, {autofocus: false});

  //precond
  assert.ok(!editor$l.hasCursor(), 'editor has no cursor');
  assert.ok(editor$l.range.isBlank, 'editor has no cursor');
  assert.hasElement('#editor p:eq(0):contains(abc)');
  assert.hasElement('#editor p:eq(1):contains(def)');
  assert.hasNoElement('#editor p:contains(123)');

  Helpers.dom.clearSelection();
  editor$l.run(postEditor => postEditor.insertSection(newSection));
  assert.hasElement('#editor p:eq(0):contains(abc)', 'still has 1st section');
  assert.hasElement('#editor p:eq(2):contains(123)', 'new section added at end');
  assert.hasElement('#editor p:eq(1):contains(def)', '2nd section -> same spot');
});

test$V('#insertSection can insert card, render it in display mode', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  let displayedCard;
  let cards = [{
    name: 'sample-card',
    type: 'dom',
    render() { displayedCard = true; },
    edit() { }
  }];

  editor$l = new Editor({mobiledoc, cards});
  editor$l.render(editorElement$m);

  editor$l.run(postEditor => {
    let cardSection = postEditor.builder.createCardSection('sample-card');
    postEditor.insertSection(cardSection);
  });

  assert.ok(displayedCard, 'rendered card in display mode');
});

test$V('#insertSection inserts card, can render it in edit mode using #editCard', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });

  let displayedCard, editedCard;
  let cards = [{
    name: 'sample-card',
    type: 'dom',
    render() { displayedCard = true; },
    edit() { editedCard = true; }
  }];

  editor$l = new Editor({mobiledoc, cards});
  editor$l.render(editorElement$m);

  editor$l.run(postEditor => {
    let cardSection = postEditor.builder.createCardSection('sample-card');
    postEditor.insertSection(cardSection);
    editor$l.editCard(cardSection);
  });

  assert.ok(editedCard, 'rendered card in edit mode');
  assert.ok(!displayedCard, 'did not render in display mode');
});

test$V('after inserting a section, can use editor#editCard to switch it to edit mode', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) => {
    return post([cardSection('sample-card')]);
  });

  let displayedCard, editedCard;
  let cards = [{
    name: 'sample-card',
    type: 'dom',
    render() { displayedCard = true; },
    edit() { editedCard = true; }
  }];

  editor$l = new Editor({mobiledoc, cards});
  editor$l.render(editorElement$m);
  assert.ok(displayedCard, 'called display#setup');
  assert.ok(!editedCard, 'did not call edit#setup yet');

  displayedCard = false;
  const card = editor$l.post.sections.head;
  editor$l.editCard(card);

  assert.ok(editedCard, 'called edit#setup');
  assert.ok(!displayedCard, 'did not call display#setup again');
});

test$V('can call editor#displayCard to switch card into display mode', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, cardSection}) => {
    return post([cardSection('sample-card')]);
  });

  let displayedCard, editedCard;
  let cards = [{
    name: 'sample-card',
    type: 'dom',
    render() { displayedCard = true; },
    edit() { editedCard = true; }
  }];

  editor$l = new Editor({mobiledoc, cards});
  editor$l.render(editorElement$m);

  assert.ok(displayedCard, 'precond - called display#setup');
  assert.ok(!editedCard, 'precond - did not call edit#setup yet');

  displayedCard = false;
  const card = editor$l.post.sections.head;
  editor$l.editCard(card);

  assert.ok(!displayedCard, 'card not in display mode');
  assert.ok(editedCard, 'card in edit mode');

  editedCard = false;

  editor$l.displayCard(card);

  assert.ok(displayedCard, 'card back in display mode');
  assert.ok(!editedCard, 'card not in edit mode');
});

test$V('#toggleMarkup adds markup by tag name', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc'), marker('def')])
    ]);
  });
  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  //precond
  assert.hasNoElement('#editor strong');

  Helpers.dom.selectText(editor$l ,'bc', editorElement$m, 'd', editorElement$m);
  editor$l.run(postEditor => postEditor.toggleMarkup('strong'));
  assert.hasElement('#editor strong:contains(bcd)');
});

test$V('#toggleMarkup removes markup by tag name', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, markup}) => {
    const strong = markup('strong');
    return post([
      markupSection('p', [marker('a'), marker('bcde', [strong]), marker('f')])
    ]);
  });
  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  //precond
  assert.hasElement('#editor strong:contains(bcde)');

  Helpers.dom.selectText(editor$l ,'bc', editorElement$m, 'd', editorElement$m);
  editor$l.run(postEditor => postEditor.toggleMarkup('strong'));
  assert.hasNoElement('#editor strong:contains(bcd)', 'markup removed from selection');
  assert.hasElement('#editor strong:contains(e)', 'unselected text still bold');
});

test$V('#toggleMarkup does nothing with an empty selection', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('a')])
    ]);
  });
  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  editor$l.run(postEditor => postEditor.toggleMarkup('strong'));

  assert.hasNoElement('#editor strong', 'strong not added, nothing selected');
});

test$V('postEditor reads editor range, sets it with #setRange', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  let { post } = editor$l;

  Helpers.dom.selectText(editor$l ,'bc', editorElement$m);
  let range = editor$l.range;
  let expectedRange = Range.create(post.sections.head, 'a'.length,
                                   post.sections.head, 'abc'.length);
  assert.ok(range.isEqual(expectedRange), 'precond - editor.range is correct');

  let newRange;
  editor$l.run(postEditor => {
    newRange = Range.create(post.sections.head, 0, post.sections.head, 1);
    postEditor.setRange(newRange);
  });

  assert.ok(editor$l.range.isEqual(newRange), 'newRange is rendered after run');
});

test$V('markup sections may contain attributes', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('123')], false, {'data-md-text-align': 'center'})
    ]);
  });

  editor$l = new Editor({mobiledoc});
  editor$l.render(editorElement$m);

  assert.hasElement('#editor p[data-md-text-align="center"]');
});

const { test: test$W, module: module$W } = Helpers;

const simpleAtom$1 = {
  name: 'simple-atom',
  type: 'dom',
  render({value}) {
    let element = document.createElement('span');
    element.setAttribute('id', 'simple-atom');
    element.appendChild(document.createTextNode(value));
    return element;
  }
};

let editor$m, editorElement$n;
let editorOptions$2 = { atoms: [simpleAtom$1] };

module$W('Acceptance: Editor: Reparsing', {
  beforeEach() {
    editorElement$n = $('#editor')[0];
  },
  afterEach() {
    if (editor$m) { editor$m.destroy(); }
  }
});

test$W('changing text node content causes reparse of section', (assert) => {
  let done = assert.async();
  let expected;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('def')])]);

    return post([markupSection('p', [marker('abc')])]);
  });

  let section = editor$m.post.sections.head;
  let node = section.markers.head.renderNode.element;

  assert.equal(node.textContent, 'abc', 'precond - correct text node');
  assert.equal(section.text, 'abc', 'precond - correct section');

  node.textContent = 'def';

  Helpers.wait(() => {
    assert.equal(section.text, 'def', 'section reparsed correctly');
    assert.postIsSimilar(editor$m.post, expected);
    done();
  });
});

test$W('removing text node causes reparse of section', (assert) => {
  let done = assert.async();
  let expected;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('def')])]);

    return post([markupSection('p', [marker('abc'), marker('def')])]);
  });

  let section = editor$m.post.sections.head;
  let node = section.markers.head.renderNode.element;

  assert.equal(node.textContent, 'abc', 'precond - correct text node');
  assert.equal(section.text, 'abcdef', 'precond - correct section');

  node.parentNode.removeChild(node);

  Helpers.wait(() => {
    assert.equal(section.text, 'def', 'section reparsed correctly');
    assert.postIsSimilar(editor$m.post, expected);
    done();
  });
});

test$W('removing section node causes reparse of post', (assert) => {
  let done = assert.async();
  let expected;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('123')])]);

    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);
  });

  let node = editor$m.post.sections.head.renderNode.element;
  assert.equal(node.innerHTML, 'abc', 'precond - correct node');

  node.parentNode.removeChild(node);

  Helpers.wait(() => {
    assert.postIsSimilar(editor$m.post, expected);
    done();
  });
});

test$W('inserting styled span in section causes section reparse', (assert) => {
  let done = assert.async();
  let expected;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('abc'), marker('def')])]);

    return post([
      markupSection('p', [marker('abc')])
    ]);
  });

  let node = editor$m.post.sections.head.renderNode.element;
  assert.equal(node.innerHTML, 'abc', 'precond - correct node');

  let span = document.createElement('span');
  span.setAttribute('style','font-size: 24px; font-color: blue');
  span.appendChild(document.createTextNode('def'));
  node.appendChild(span);

  Helpers.wait(() => {
    assert.postIsSimilar(editor$m.post, expected);
    done();
  });
});

test$W('inserting new top-level node causes reparse of post', (assert) => {
  let done = assert.async();
  let expected;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected = post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);

    return post([markupSection('p', [marker('abc')])]);
  });

  let span = document.createElement('span');
  span.appendChild(document.createTextNode('123'));
  editorElement$n.appendChild(span);

  Helpers.wait(() => {
    assert.postIsSimilar(editor$m.post, expected);
    done();
  });
});

test$W('inserting node into blank post causes reparse', (assert) => {
  let done = assert.async();
  let expected;

  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected = post([markupSection('p', [marker('123')])]);
    return post();
  });

  let span = document.createElement('span');
  span.appendChild(document.createTextNode('123'));
  editorElement$n.appendChild(span);

  Helpers.wait(() => {
    assert.postIsSimilar(editor$m.post, expected);
    done();
  });
});

test$W('after reparsing post, mutations still handled properly', (assert) => {
  let done = assert.async();
  let expected1, expected2;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker}) => {
    expected1 = post([
      markupSection('p', [marker('abc')]),
      markupSection('p', [marker('123')])
    ]);

    expected2 = post([
      markupSection('p', [marker('def')]),
      markupSection('p', [marker('123')])
    ]);

    return post([markupSection('p', [marker('abc')])]);
  });

  let span = document.createElement('span');
  span.appendChild(document.createTextNode('123'));
  editorElement$n.appendChild(span);

  Helpers.wait(() => {
    assert.postIsSimilar(editor$m.post, expected1);

    let node = editorElement$n.firstChild.firstChild;
    assert.equal(node.textContent, 'abc', 'precond - correct node');

    node.textContent = 'def';

    Helpers.wait(() => {
      assert.postIsSimilar(editor$m.post, expected2);

      done();
    });
  });
});

test$W('inserting text into text node on left/right of atom is reparsed correctly', (assert) => {
  let done = assert.async();
  let expected1, expected2;
  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, markupSection, marker, atom}) => {
    expected1 = post([
      markupSection('p', [atom('simple-atom', 'first'), marker('Z')]),
    ]);

    expected2 = post([
      markupSection('p', [marker('A'), atom('simple-atom', 'first'), marker('Z')]),
    ]);

    return post([markupSection('p', [atom('simple-atom','first')])]);
  }, editorOptions$2);

  let atom = editor$m.post.sections.head.markers.head;
  let rightCursorNode = atom.renderNode.tailTextNode;

  assert.ok(rightCursorNode && rightCursorNode.textContent === ZWNJ,
            'precond - correct right cursor node');

  rightCursorNode.textContent = 'Z';
  Helpers.wait(() => {
    assert.postIsSimilar(editor$m.post, expected1);
    assert.renderTreeIsEqual(editor$m._renderTree, expected1);

    let leftCursorNode = atom.renderNode.headTextNode;
    assert.ok(leftCursorNode && leftCursorNode.textContent === ZWNJ,
              'precond - correct left cursor node');
    leftCursorNode.textContent = 'A';

    Helpers.wait(() => {
      assert.postIsSimilar(editor$m.post, expected2);
      assert.renderTreeIsEqual(editor$m._renderTree, expected2);

      done();
    });
  });
});

test$W('mutation inside card element does not cause reparse', (assert) => {
  let done = assert.async();
  let parseCount = 0;
  let myCard = {
    name: 'my-card',
    type: 'dom',
    render() {
      return document.createTextNode('howdy');
    }
  };

  editor$m = Helpers.mobiledoc.renderInto(editorElement$n, ({post, cardSection}) => {
    return post([
      cardSection('my-card', {})
    ]);
  }, {
    cards: [myCard]
  });

  editor$m.didUpdatePost(() => {
    parseCount++;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$n, 'howdy');
  textNode.textContent = 'adios';

  // Allow the mutation observer to fire then...
  Helpers.wait(function() {
    assert.equal(0, parseCount);
    done();
  });
});

const { test: test$X, module: module$X } = Helpers;

let editor$n, editorElement$o;
const mobileDocWith1Section = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, "only section"]
      ]]
    ]
  ]
};
const mobileDocWith2Sections = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, "first section"]
      ]],
      [1, "P", [
        [[], 0, "second section"]
      ]]
    ]
  ]
};
const mobileDocWith3Sections = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, "first section"]
      ]],
      [1, "P", [
        [[], 0, "second section"]
      ]],
      [1, "P", [
        [[], 0, "third section"]
      ]]
    ]
  ]
};

const mobileDocWith2Markers = {
  version: MOBILEDOC_VERSION,
  sections: [
    [['b']],
    [
      [1, "P", [
        [[0], 1, "bold"],
        [[], 0, "plain"]
      ]]
    ]
  ]
};

const mobileDocWith1Character = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, "c"]
      ]]
    ]
  ]
};

const mobileDocWithNoCharacter = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, ""]
      ]]
    ]
  ]
};

module$X('Acceptance: Editor sections', {
  beforeEach() {
    editorElement$o = $('#editor')[0];
  },

  afterEach() {
    if (editor$n) {
      editor$n.destroy();
      editor$n = null;
    }
  }
});

test$X('typing enter inserts new section', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith1Section});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');

  Helpers.dom.moveCursorTo(editor$n, editorElement$o.childNodes[0].childNodes[0], 5);
  Helpers.dom.triggerEnter(editor$n);

  assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');
  assert.hasElement(`#editor p:contains(only)`, 'has correct first pargraph text');
  assert.hasElement('#editor p:contains(section)', 'has correct second paragraph text');
});

test$X('typing enter inserts new section from blank section', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWithNoCharacter});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');

  Helpers.dom.moveCursorTo(editor$n, editorElement$o.childNodes[0].childNodes[0], 0);
  Helpers.dom.triggerEnter(editor$n);

  assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');
});

test$X('hitting enter in first section splits it correctly', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 2, 'precond - has 2 paragraphs');

  Helpers.dom.moveCursorTo(editor$n, editorElement$o.childNodes[0].childNodes[0], 3);
  Helpers.dom.triggerEnter(editor$n);

  assert.equal($('#editor p').length, 3, 'has 3 paragraphs after typing return');

  assert.equal($('#editor p:eq(0)').text(), 'fir', 'first para has correct text');
  assert.equal($('#editor p:eq(1)').text(), 'st section', 'second para has correct text');
  assert.equal($('#editor p:eq(2)').text(), 'second section', 'third para still has correct text');

  assert.deepEqual(Helpers.dom.getCursorPosition(),
                   {node: editorElement$o.childNodes[1].childNodes[0],
                    offset: 0});
});

test$X('hitting enter at start of a section creates empty section where cursor was', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith1Section});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 1, 'has 1 paragraph to start');

  Helpers.dom.moveCursorTo(editor$n, editorElement$o.childNodes[0].childNodes[0], 0);
  Helpers.dom.triggerEnter(editor$n);

  assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');

  let firstP = $('#editor p:eq(0)');
  assert.equal(firstP.text(), '', 'first para has no text');
  assert.hasElement('#editor p:eq(1):contains(only section)', 'has correct second paragraph text');

  assert.deepEqual(Helpers.dom.getCursorPosition(),
                   {node: editorElement$o.childNodes[1].childNodes[0],
                    offset: 0});
});

test$X('hitting enter at end of a section creates new empty section', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith1Section});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 1, 'has 1 section to start');

  Helpers.dom.moveCursorTo(editor$n, editorElement$o.childNodes[0].childNodes[0], 'only section'.length);
  Helpers.dom.triggerEnter(editor$n);

  assert.equal($('#editor p').length, 2, 'has 2 sections after typing return');
  assert.hasElement('#editor p:eq(0):contains(only section)', 'has same first section text');
  assert.hasElement('#editor p:eq(1):contains()', 'second section has no text');

  Helpers.dom.insertText(editor$n, 'X');

  assert.hasElement('#editor p:eq(1):contains(X)', 'text is inserted in the new section');
});

test$X('hitting enter in a section creates a new basic section', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) =>
    post([
      markupSection('h2', [marker('abc')])
    ])
  );
  editor$n = new Editor({mobiledoc});
  editor$n.render(editorElement$o);
  assert.hasElement('#editor h2:contains(abc)', 'precond - h2 is there');
  assert.hasNoElement('#editor p', 'precond - no p tag');

  Helpers.dom.moveCursorTo(editor$n, $('#editor h2')[0].childNodes[0], 'abc'.length);
  Helpers.dom.triggerEnter(editor$n);
  Helpers.dom.insertText(editor$n, 'X');

  assert.hasElement('#editor h2:contains(abc)', 'h2 still there');
  assert.hasElement('#editor p:contains(X)', 'p tag instead of h2 generated');
});

test$X('deleting across 2 sections does nothing if editing is disabled', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);
  editor$n.disableEditing();
  assert.equal($('#editor p').length, 2, 'precond - has 2 sections to start');

  const p0 = $('#editor p:eq(0)')[0],
        p1 = $('#editor p:eq(1)')[0];

  Helpers.dom.selectText(editor$n ,'tion', p0, 'sec', p1);
  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p').length, 2, 'still has 2 sections');
});

test$X('deleting across 2 sections merges them', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 2, 'precond - has 2 sections to start');

  const p0 = $('#editor p:eq(0)')[0],
        p1 = $('#editor p:eq(1)')[0];

  Helpers.dom.selectText(editor$n ,'tion', p0, 'sec', p1);
  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p').length, 1, 'has only 1 paragraph after deletion');
  assert.hasElement('#editor p:contains(first second section)',
                    'remaining paragraph has correct text');
});

test$X('deleting across 1 section removes it, joins the 2 boundary sections', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith3Sections});
  editor$n.render(editorElement$o);
  assert.equal($('#editor p').length, 3, 'precond - has 3 paragraphs to start');

  const p0 = $('#editor p:eq(0)')[0],
        p1 = $('#editor p:eq(1)')[0],
        p2 = $('#editor p:eq(2)')[0];
  assert.ok(p0 && p1 && p2, 'precond - paragraphs exist');

  Helpers.dom.selectText(editor$n ,'section', p0, 'third ', p2);
  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p').length, 1, 'has only 1 paragraph after deletion');
  assert.hasElement('#editor p:contains(first section)',
                    'remaining paragraph has correct text');
});

test$X('failing to delete will not trigger deleting hooks', (assert) => {
  assert.expect(0);
  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.willDelete(() => {
    assert.ok(false, 'willDelete should not be triggered');
  });
  editor$n.didDelete(() => {
    assert.ok(false, 'didDelete should not be triggered');
  });

  editor$n.render(editorElement$o);
  editor$n.disableEditing();
  Helpers.dom.triggerDelete(editor$n);
});

test$X('deleting chracter triggers deleting hooks', (assert) => {
  assert.expect(9);
  let lifeCycles = [];

  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.willDelete((range, direction, unit) => {
    assert.ok(range, 'range is not empty');
    assert.equal(direction, -1, 'direction defaults to -1');
    assert.equal(unit, 'char', 'unit defaults to char');
    assert.ok(true, 'willDelete is triggered');
    lifeCycles.push('willDelete');
  });
  editor$n.didDelete((range, direction, unit) => {
    assert.ok(range, 'range is not empty');
    assert.equal(direction, -1, 'direction defaults to -1');
    assert.equal(unit, 'char', 'unit defaults to char');
    assert.ok(true, 'didDelete is triggered');
    lifeCycles.push('didDelete');
  });
  editor$n.render(editorElement$o);

  Helpers.dom.triggerDelete(editor$n);
  assert.deepEqual(lifeCycles, ['willDelete', 'didDelete'], 'hooks are triggered in order');
});

test$X('keystroke of delete removes that character', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith3Sections});
  editor$n.render(editorElement$o);
  const getFirstTextNode = () => {
    return editor$n.element.
             firstChild. // section
             firstChild; // marker
  };
  const textNode = getFirstTextNode();
  Helpers.dom.moveCursorTo(editor$n, textNode, 1);

  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p:eq(0)').html(), 'irst section',
               'deletes first character');

  const newTextNode = getFirstTextNode();
  assert.deepEqual(Helpers.dom.getCursorPosition(),
                   {node: newTextNode, offset: 0},
                   'cursor is at start of new text node');
});

test$X('keystroke of delete removes emoji character', (assert) => {
  let monkey = 'monkey';
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker(monkey)])]);
  });
  editor$n = new Editor({mobiledoc});
  editor$n.render(editorElement$o);
  let textNode = editorElement$o.firstChild. // section
                               firstChild; // marker
  assert.equal(textNode.textContent, monkey, 'precond - correct text');

  Helpers.dom.moveCursorTo(editor$n, textNode, monkey.length);
  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p:eq(0)').text(), 'monkey', 'deletes the emoji');
});

test$X('keystroke of forward delete removes emoji character', (assert) => {
  let monkey = 'monkey';
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker(monkey)])]);
  });
  editor$n = new Editor({mobiledoc});
  editor$n.render(editorElement$o);
  let textNode = editorElement$o.firstChild. // section
                               firstChild; // marker
  assert.equal(textNode.textContent, monkey, 'precond - correct text');

  Helpers.dom.moveCursorTo(editor$n, textNode, 'monkey'.length);
  Helpers.dom.triggerForwardDelete(editor$n);

  assert.equal($('#editor p:eq(0)').text(), 'monkey', 'deletes the emoji');
});

test$X('keystroke of delete when cursor is at beginning of marker removes character from previous marker', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith2Markers});
  editor$n.render(editorElement$o);
  const textNode = editor$n.element.
                    firstChild.    // section
                    childNodes[1]; // plain marker

  assert.ok(!!textNode, 'gets text node');
  Helpers.dom.moveCursorTo(editor$n, textNode, 0);

  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p:eq(0)').html(), '<b>bol</b>plain',
               'deletes last character of previous marker');

  const boldNode = editor$n.element.firstChild. // section
                                  firstChild; // bold marker
  const boldTextNode = boldNode.firstChild;

  assert.deepEqual(Helpers.dom.getCursorPosition(),
                  {node: boldTextNode, offset: 3},
                  'cursor moves to end of previous text node');
});

test$X('keystroke of delete when cursor is after only char in only marker of section removes character', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith1Character});
  editor$n.render(editorElement$o);
  const getTextNode = () => editor$n.element.
                                  firstChild. // section
                                  firstChild; // c marker

  let textNode = getTextNode();
  assert.ok(!!textNode, 'gets text node');
  Helpers.dom.moveCursorTo(editor$n, textNode, 1);

  Helpers.dom.triggerDelete(editor$n);

  assert.hasElement('#editor p:eq(0):contains()', 'first p is empty');

  Helpers.dom.insertText(editor$n, 'X');
  assert.hasElement('#editor p:eq(0):contains(X)', 'text is added back to section');
});

test$X('keystroke of character in empty section adds character, moves cursor', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWithNoCharacter});
  editor$n.render(editorElement$o);

  assert.hasElement('#editor p br', 'precond - br tag rendered for empty section');
  let pNode = $('#editor p')[0];

  // Firefox requires that the cursor be placed explicitly for this test to pass
  Helpers.dom.moveCursorTo(editor$n, pNode, 0);

  const letter = 'M';
  Helpers.dom.insertText(editor$n, letter);

  assert.hasElement(`#editor p:contains(${letter})`, 'adds char');

  const otherLetter = 'X';
  Helpers.dom.insertText(editor$n, otherLetter);

  assert.hasElement(`#editor p:contains(${letter}${otherLetter})`, 'adds char in correct spot');
});

test$X('keystroke of delete at start of section joins with previous section', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);

  let secondSectionTextNode = editor$n.element.childNodes[1].firstChild;

  assert.equal(secondSectionTextNode.textContent, 'second section',
               'precond - section section text node');

  Helpers.dom.moveCursorTo(editor$n, secondSectionTextNode, 0);
  //editor.range = null;
  Helpers.dom.triggerDelete(editor$n);

  assert.equal(editor$n.element.childNodes.length, 1, 'only 1 section remaining');

  let secondSectionNode = editor$n.element.firstChild;
  secondSectionTextNode = secondSectionNode.firstChild;
  assert.equal(secondSectionNode.textContent,
               'first sectionsecond section',
               'joins two sections');

  Helpers.dom.insertText(editor$n, 'X');

  assert.hasElement('#editor p:contains(first sectionXsecond section)',
                    'inserts text at correct spot');
});


test$X('keystroke of delete at start of first section does nothing', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);

  let firstSectionTextNode = editor$n.element.childNodes[0].firstChild;

  assert.equal(firstSectionTextNode.textContent, 'first section',
               'finds first section text node');

  Helpers.dom.moveCursorTo(editor$n, firstSectionTextNode, 0);

  Helpers.dom.triggerDelete(editor$n);

  assert.equal(editor$n.element.childNodes.length, 2, 'still 2 sections');
  firstSectionTextNode = editor$n.element.childNodes[0].firstChild;
  assert.equal(firstSectionTextNode.textContent,
               'first section',
               'first section still has same text content');

  assert.deepEqual(Helpers.dom.getCursorPosition(),
                  {node: firstSectionTextNode,
                   offset: 0},
                  'cursor stays at start of first section');
});

test$X('when selection incorrectly contains P end tag, editor reports correct selection', (assert) => {
  const done = assert.async();

  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);

  let secondSectionTextNode = editor$n.element.childNodes[1].firstChild;
  let firstSectionPNode = editor$n.element.childNodes[0];

  Helpers.dom.moveCursorTo(editor$n, firstSectionPNode, 0,
                           secondSectionTextNode, 0);
  Helpers.dom.triggerEvent(document, 'mouseup');

  Helpers.wait(() => {
    assert.ok(true, 'No error should occur');

    let {
      headSection, tailSection, headMarker, tailMarker,
      headSectionOffset, tailSectionOffset, headMarkerOffset, tailMarkerOffset
    } = editor$n.range;

    assert.ok(headSection === editor$n.post.sections.objectAt(0),
              'returns first section head');
    assert.ok(tailSection === editor$n.post.sections.objectAt(1),
              'returns second section tail');
    assert.ok(headMarker === editor$n.post.sections.objectAt(0).markers.head,
              'returns first section marker head');
    assert.ok(tailMarker === editor$n.post.sections.objectAt(1).markers.head,
              'returns second section marker tail');
    assert.equal(headMarkerOffset, 0, 'headMarkerOffset correct');
    assert.equal(tailMarkerOffset, 0, 'tailMarkerOffset correct');
    assert.equal(headSectionOffset, 0, 'headSectionOffset correct');
    assert.equal(tailSectionOffset, 0, 'tailSectionOffset correct');

    done();
  });
});

test$X('when selection incorrectly contains P start tag, editor reports correct selection', (assert) => {
  const done = assert.async();

  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);

  let firstSectionTextNode = editor$n.element.childNodes[0].firstChild;
  let secondSectionPNode = editor$n.element.childNodes[1];

  Helpers.dom.moveCursorTo(editor$n, firstSectionTextNode, 0,
                           secondSectionPNode, 0);
  Helpers.dom.triggerEvent(document, 'mouseup');

  Helpers.wait(() => {
    assert.ok(true, 'No error should occur');

    let {
      headSection, tailSection, headMarker, tailMarker,
      headSectionOffset, tailSectionOffset, headMarkerOffset, tailMarkerOffset
    } = editor$n.range;

    assert.equal(headSection, editor$n.post.sections.objectAt(0),
                 'returns first section head');
    assert.equal(tailSection, editor$n.post.sections.objectAt(1),
                 'returns second section tail');
    assert.equal(headMarker, editor$n.post.sections.objectAt(0).markers.head,
                 'returns first section marker head');
    assert.equal(tailMarker, editor$n.post.sections.objectAt(1).markers.head,
                 'returns second section marker tail');
    assert.equal(headMarkerOffset, 0, 'headMarkerOffset correct');
    assert.equal(tailMarkerOffset, 0, 'tailMarkerOffset correct');
    assert.equal(headSectionOffset, 0, 'headSectionOffset correct');
    assert.equal(tailSectionOffset, 0, 'tailSectionOffset correct');

    done();
  });
});

test$X('deleting when after deletion there is a trailing space positions cursor at end of selection', (assert) => {
  const done = assert.async();

  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);

  let firstSectionTextNode = editor$n.element.childNodes[0].firstChild;
  Helpers.dom.moveCursorTo(editor$n, firstSectionTextNode, 'first section'.length);

  let count = 'ection'.length;
  while (count--) {
    Helpers.dom.triggerDelete(editor$n);
  }

  assert.equal($('#editor p:eq(0)').text(), 'first s', 'precond - correct section text after initial deletions');

  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p:eq(0)').text(), `first${NO_BREAK_SPACE}`, 'precond - correct text after deleting last char before space');

  let text = 'e';
  Helpers.dom.insertText(editor$n, text);

  Helpers.wait(() => {
    assert.equal(editor$n.post.sections.head.text, `first ${text}`, 'character is placed after space');

    done();
  });
});

test$X('deleting when after deletion there is a leading space positions cursor at start of selection', (assert) => {
  const done = assert.async();

  editor$n = new Editor({mobiledoc: mobileDocWith2Sections});
  editor$n.render(editorElement$o);

  Helpers.dom.selectText(editor$n ,'second', editorElement$o);
  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p:eq(1)').text(), `${NO_BREAK_SPACE}section`, 'correct text after deletion');
  let text = 'e';
  Helpers.dom.insertText(editor$n, text);

  Helpers.wait(() => {
    assert.equal(editor$n.post.sections.tail.text, `${text} section`, 'correct text after insertion');
    done();
  });
});

test$X('inserting multiple spaces renders them with nbsps', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(({post, markupSection}) => {
    return post([markupSection()]);
  });
  editor$n = new Editor({mobiledoc});
  editor$n.render(editorElement$o);

  // Tests on FF fail if the editor doesn't have a cursor, we must
  // render it explicitly
  editor$n.selectRange(new Range(editor$n.post.tailPosition()));

  assert.ok(editor$n.hasCursor(), 'precond - has cursor');

  let sp = ' ', nbsp = NO_BREAK_SPACE;
  Helpers.dom.insertText(editor$n, sp + sp + sp);
  assert.equal($('#editor p:eq(0)').text(),
               nbsp + nbsp + nbsp,
               'correct nbsps in text');
});

test$X('deleting when the previous section is also blank', (assert) => {
  editor$n = new Editor({mobiledoc: mobileDocWithNoCharacter});
  editor$n.render(editorElement$o);

  Helpers.dom.moveCursorTo(editor$n, editorElement$o.childNodes[0].childNodes[0], 0);
  Helpers.dom.triggerEnter(editor$n);

  assert.equal($('#editor p').length, 2, 'has 2 paragraphs after typing return');

  Helpers.dom.triggerDelete(editor$n);

  assert.equal($('#editor p').length, 1, 'has 1 paragraphs after typing delete');
});

test$X('deleting from head of section when previous section is non-markerable', (assert) => {
  let card = {
    name: 'some-card',
    type: 'dom',
    render() {}
  };

  let expected;
  editor$n = Helpers.mobiledoc.renderInto(editorElement$o, ({post, markupSection, marker, cardSection}) => {
    expected = post([
      cardSection('some-card'),
      markupSection('p', [marker('abc')])
    ]);
    return post([
      cardSection('some-card'),
      markupSection('p', [marker('abc')])
    ]);
  }, {cards:[card]});

  let node = Helpers.dom.findTextNode(editorElement$o, 'abc');
  Helpers.dom.moveCursorTo(editor$n, node, 0);
  Helpers.dom.triggerDelete(editor$n);

  assert.positionIsEqual(editor$n.range.head, editor$n.post.sections.head.tailPosition(),
                         'moves cursor to end of card section');
  assert.postIsSimilar(editor$n.post, expected, 'post is not changed');
});

test$X('delete with option (Mac) or control (Win)  key deletes full word', (assert) => {
  assert.expect(1);
  if (!Browser.isMac() && !Browser.isWin()) {
    assert.ok(true, 'SKIP on non-mac non-win');
    return;
  }

  let done = assert.async();

  let { post } = Helpers.postAbstract.buildFromText("abc def");
  let { post: expected } = Helpers.postAbstract.buildFromText("abc ");
  editor$n = Helpers.mobiledoc.renderPostInto(editorElement$o, post);

  editor$n.selectRange(new Range(editor$n.post.tailPosition()));

  let altKey, ctrlKey;
  if (Browser.isMac()) {
    /* Mac key codes for navigation by word */
    altKey = true;
    ctrlKey = false;
  } else {
    /* PC key codes for navigation by word */
    altKey = false;
    ctrlKey = true;
  }

  Helpers.wait(() => {
    Helpers.dom.triggerDelete(editor$n, DIRECTION.BACKWARD, {altKey, ctrlKey});

    Helpers.wait(() => {
      assert.postIsSimilar(editor$n.post, expected);
      done();
    });
  });
});

const { test: test$Y, module: module$Y } = Helpers;

let editor$o, editorElement$p;

const mobileDocWithSection = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, "one trick pony"]
      ]]
    ]
  ]
};

const mobileDocWith2Sections$1 = {
  version: MOBILEDOC_VERSION,
  sections: [
    [],
    [
      [1, "P", [
        [[], 0, "first section"]
      ]],
      [1, "P", [
        [[], 0, "second section"]
      ]]
    ]
  ]
};

module$Y('Acceptance: Editor Selections', {
  beforeEach() {
    editorElement$p = $('#editor')[0];
  },

  afterEach() {
    if (editor$o) { editor$o.destroy(); }
  }
});

test$Y('selecting across sections is possible', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  let firstSection = $('p:contains(first section)')[0];
  let secondSection = $('p:contains(second section)')[0];

  Helpers.dom.selectText(editor$o ,'section', firstSection,
                         'second', secondSection);

  Helpers.dom.triggerEvent(document, 'mouseup');
  assert.equal(editor$o.activeSections.length, 2, 'selects 2 sections');
});

test$Y('when editing is disabled, the selection detection code is disabled', (assert) => {
  let done = assert.async();
  $('#qunit-fixture').append('<p>outside section 1</p>');
  $('#qunit-fixture').append('<p>outside section 2</p>');

  editor$o = new Editor({mobiledoc: mobileDocWithSection});
  editor$o.render(editorElement$p);
  editor$o.disableEditing();

  const outside1 = $('p:contains(outside section 1)')[0];
  const outside2 = $('p:contains(outside section 2)')[0];

  Helpers.wait(() => {
    Helpers.dom.selectText(editor$o ,'outside', outside1, 'section 2', outside2);

    Helpers.wait(() => {
      assert.equal(editor$o.activeSections.length, 0, 'no selection inside the editor');
      const selectedText = Helpers.dom.getSelectedText();
      assert.ok(selectedText.indexOf('outside section 1') !== -1 &&
                selectedText.indexOf('outside section 2') !== -1, 'selects the text');

      done();
    });
  });
});

test$Y('selecting an entire section and deleting removes it', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'second section', editorElement$p);
  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('#editor p:contains(first section)');
  assert.hasNoElement('#editor p:contains(second section)', 'deletes contents of second section');
  assert.equal($('#editor p').length, 2, 'still has 2 sections');

  Helpers.dom.insertText(editor$o, 'X');

  assert.hasElement('#editor p:eq(1):contains(X)', 'inserts text in correct spot');
});

test$Y('selecting text in a section and deleting deletes it', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'cond sec', editorElement$p);
  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('#editor p:contains(first section)', 'first section unchanged');
  assert.hasNoElement('#editor p:contains(second section)', 'second section is no longer there');
  assert.hasElement('#editor p:contains(setion)', 'second section has correct text');

  Helpers.dom.insertText(editor$o, 'Z');
  assert.hasElement('#editor p:contains(seZtion)', 'text inserted correctly');
});

test$Y('selecting text across sections and deleting joins sections', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  const firstSection = $('#editor p')[0],
        secondSection = $('#editor p')[1];

  Helpers.dom.selectText(editor$o ,'t section', firstSection,
                         'second s', secondSection);
  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('p:contains(firsection)');
  assert.hasNoElement('p:contains(first section)');
  assert.hasNoElement('p:contains(second section)');
  assert.equal($('#editor p').length, 1, 'only 1 section after deleting to join');
});

test$Y('selecting text across markers and deleting joins markers', (assert) => {

  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'rst sect', editorElement$p);
  editor$o.run(postEditor => postEditor.toggleMarkup('strong'));

  let firstTextNode = editorElement$p
                         .childNodes[0] // p
                         .childNodes[1] // b
                         .childNodes[0]; // textNode containing "rst sect"
  let secondTextNode = editorElement$p
                           .childNodes[0] // p
                           .childNodes[2]; // textNode containing "ion"

  assert.equal(firstTextNode.textContent, 'rst sect', 'correct first text node');
  assert.equal(secondTextNode.textContent, 'ion', 'correct second text node');
  Helpers.dom.selectText(editor$o ,'t sect', firstTextNode,
                         'ion',    secondTextNode);
  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('p:contains(firs)', 'deletes across markers');
  assert.hasElement('strong:contains(rs)', 'maintains bold text');

  firstTextNode = editorElement$p
                    .childNodes[0] // p
                    .childNodes[1] // b
                    .childNodes[0]; // textNode now containing "rs"

  assert.deepEqual(Helpers.dom.getCursorPosition(),
                   {node: firstTextNode, offset: 2});
});

test$Y('select text and apply markup multiple times', (assert) => {
  const done = assert.async();

  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'t sect', editorElement$p);
  Helpers.dom.triggerEvent(document, 'mouseup');

  editor$o.run(postEditor => postEditor.toggleMarkup('strong'));

  Helpers.wait(() => {
    Helpers.dom.selectText(editor$o ,'fir', editorElement$p);
    editor$o.run(postEditor => postEditor.toggleMarkup('strong'));
    clearSelection();
    Helpers.dom.triggerEvent(document, 'mouseup');

    Helpers.wait(() => {
      editor$o.run(postEditor => postEditor.toggleMarkup('strong'));

      assert.hasElement('p:contains(first section)', 'correct first section');
      assert.hasElement('strong:contains(fir)', 'strong "fir"');
      assert.hasElement('strong:contains(t sect)', 'strong "t sect"');

      done();
    });
  });
});

test$Y('selecting text across markers deletes intermediary markers', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [
        marker('abc'),
        marker('123', [markup('strong')]),
        marker('def')
      ])
    ]);
  });
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);


  const textNode1 = editorElement$p.childNodes[0].childNodes[0],
        textNode2 = editorElement$p.childNodes[0].childNodes[2];

  assert.equal(textNode1.textContent, 'abc', 'precond - text node 1');
  assert.equal(textNode2.textContent, 'def', 'precond - text node 2');
  Helpers.dom.selectText(editor$o ,'b', textNode1,
                         'e', textNode2);

  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('p:contains(af)', 'has remaining first section');

  Helpers.dom.insertText(editor$o, 'X');
  assert.hasElement('p:contains(aXf)', 'inserts text at correct place');
});

test$Y('deleting text across markers preserves node after', (assert) => {
  let mobiledoc = Helpers.mobiledoc.build(
    ({post, markupSection, marker, markup}) => {
    return post([
      markupSection('p', [
        marker('abc'),
        marker('123', [markup('strong')]),
        marker('def')
      ])
    ]);
  });
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);


  const textNode1 = editorElement$p.childNodes[0].childNodes[0],
        textNode2 = editorElement$p.childNodes[0].childNodes[1];
  assert.equal(textNode1.textContent, 'abc', 'precond -text node 1');
  assert.equal(textNode2.textContent, '123', 'precond -text node 2');

  Helpers.dom.selectText(editor$o ,'b', editorElement$p,
                         '2', editorElement$p);

  Helpers.dom.triggerDelete(editor$o);

  assert.equal(
    editorElement$p.childNodes[0].textContent, 'a3def',
    'has remaining first section'
  );
  Helpers.dom.insertText(editor$o, 'X');
  assert.equal(
    editorElement$p.childNodes[0].textContent, 'aX3def',
    'inserts text at correct spot');
});

test$Y('selecting text across sections and hitting enter deletes and moves cursor to last selected section', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  let firstSection = $('#editor p:eq(0)')[0],
      secondSection = $('#editor p:eq(1)')[0];

  Helpers.dom.selectText(editor$o ,' section', firstSection,
                         'second ', secondSection);

  Helpers.dom.triggerEnter(editor$o);

  assert.equal($('#editor p').length, 2, 'still 2 sections');
  assert.equal($('#editor p:eq(0)').text(), 'first', 'correct text in 1st section');
  assert.equal($('#editor p:eq(1)').text(), 'section', 'correct text in 2nd section');

  let secondSectionTextNode = editor$o.element.childNodes[1].childNodes[0];
  assert.deepEqual(Helpers.dom.getCursorPosition(),
                  {node: secondSectionTextNode, offset: 0},
                  'cursor is at start of second section');
});

test$Y('keystroke of printable character while text is selected deletes the text', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'first section', editorElement$p);

  editor$o.run(postEditor => {
    editor$o.activeSections.forEach(section => {
      postEditor.changeSectionTagName(section, 'h2');
    });
  });

  assert.ok($('#editor h2:contains(first section)').length,
            'first section is a heading');

  const firstSectionTextNode = editorElement$p.childNodes[0].childNodes[0];
  const secondSectionTextNode = editorElement$p.childNodes[1].childNodes[0];
  Helpers.dom.selectText(editor$o ,'section', firstSectionTextNode,
                        'secon', secondSectionTextNode);

  Helpers.dom.insertText(editor$o, 'X');

  assert.ok($(`#editor h2:contains(first Xd section)`).length,
            'updates the section');
});

test$Y('selecting text bounded by space and typing replaces it', (assert) => {
  let done = assert.async();
  editor$o = new Editor({mobiledoc: mobileDocWithSection});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'trick', editorElement$p);
  Helpers.dom.insertText(editor$o, 'X');
  Helpers.wait(() => {
    assert.equal(editor$o.post.sections.head.text, 'one X pony',
                 'new text present');

    Helpers.dom.insertText(editor$o, 'Y');
    Helpers.wait(() => {
      assert.equal(editor$o.post.sections.head.text, 'one XY pony',
                   'further new text present');
      done();
    });
  });
});

test$Y('selecting all text across sections and hitting enter deletes and moves cursor to empty section', (assert) => {
  editor$o = new Editor({mobiledoc: mobileDocWith2Sections$1});
  editor$o.render(editorElement$p);

  let firstSection = $('#editor p:eq(0)')[0],
      secondSection = $('#editor p:eq(1)')[0];

  Helpers.dom.selectText(editor$o ,'first section', firstSection,
                         'second section', secondSection);

  Helpers.dom.triggerEnter(editor$o);

  assert.equal($('#editor p').length, 1, 'single section');
  assert.equal($('#editor p:eq(0)').text(), '', 'blank text');

  // Firefox reports that the cursor is on the "<br>", but Safari and Chrome do not.
  // Grab the selection here, then set it to the expected value, and compare again
  // the window's selection
  let selection = window.getSelection();
  let cursorElement = $('#editor p br')[0];
  assert.ok(cursorElement, 'has cursor element');
  Helpers.dom.selectRange(cursorElement, 0, cursorElement, 0);
  let newSelection = window.getSelection();
  assert.equal(selection.anchorNode, newSelection.anchorNode, 'correct anchorNode');
  assert.equal(selection.focusNode, newSelection.focusNode, 'correct focusNode');
  assert.equal(selection.anchorOffset, newSelection.anchorOffset, 'correct anchorOffset');
  assert.equal(selection.focusOffset, newSelection.focusOffset, 'correct focusOffset');
});

test$Y('selecting text across markup and list sections', (assert) => {
  const build = Helpers.mobiledoc.build;
  const mobiledoc = build(({post, markupSection, listSection, listItem, marker}) =>
    post([
      markupSection('p', [marker('abc')]),
      listSection('ul', [
        listItem([marker('123')]),
        listItem([marker('456')])
      ])
    ])
  );
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'bc', editorElement$p, '12', editorElement$p);

  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('#editor p:contains(a3)',
                    'combines partially-selected list item onto markup section');

  assert.hasNoElement('#editor p:contains(bc)', 'deletes selected text "bc"');
  assert.hasNoElement('#editor p:contains(12)', 'deletes selected text "12"');

  assert.hasElement('#editor li:contains(6)', 'leaves remaining text in list item');
});

test$Y('selecting text that covers a list section', (assert) => {
  const build = Helpers.mobiledoc.build;
  const mobiledoc = build(({post, markupSection, listSection, listItem, marker}) =>
    post([
      markupSection('p', [marker('abc')]),
      listSection('ul', [
        listItem([marker('123')]),
        listItem([marker('456')])
      ]),
      markupSection('p', [marker('def')])
    ])
  );
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'bc', editorElement$p, 'de', editorElement$p);
  Helpers.dom.triggerEvent(document, 'mouseup');

  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('#editor p:contains(af)',
                    'combines sides of selection');

  assert.hasNoElement('#editor li:contains(123)', 'deletes li 1');
  assert.hasNoElement('#editor li:contains(456)', 'deletes li 2');
  assert.hasNoElement('#editor ul', 'removes ul');
});

test$Y('selecting text that starts in a list item and ends in a markup section', (assert) => {
  const build = Helpers.mobiledoc.build;
  const mobiledoc = build(({post, markupSection, listSection, listItem, marker}) =>
    post([
      listSection('ul', [
        listItem([marker('123')]),
        listItem([marker('456')])
      ]),
      markupSection('p', [marker('def')])
    ])
  );
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'23', editorElement$p, 'de', editorElement$p);
  Helpers.dom.triggerEvent(document, 'mouseup');
  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('#editor li:contains(1f)',
                    'combines sides of selection');

  assert.hasNoElement('#editor li:contains(123)', 'deletes li 1');
  assert.hasNoElement('#editor li:contains(456)', 'deletes li 2');
  assert.hasNoElement('#editor p:contains(def)', 'deletes p content');
  assert.hasNoElement('#editor p', 'removes p entirely');
});

test$Y('selecting text that includes a card section and deleting deletes card section', (assert) => {
  const build = Helpers.mobiledoc.build;
  const mobiledoc = build(({post, markupSection, cardSection, marker}) =>
    post([
      markupSection('p', [marker('abc')]),
      cardSection('simple-card'),
      markupSection('p', [marker('def')])
    ])
  );
  const cards = [{
    name: 'simple-card',
    type: 'dom',
    render() {
      return $('<span id="card-el"></span>')[0];
    }
  }];
  editor$o = new Editor({mobiledoc, cards});
  editor$o.render(editorElement$p);

  assert.hasElement('#card-el', 'precond - card el is rendered');

  Helpers.dom.selectText(editor$o ,'bc', editorElement$p, 'de', editorElement$p);
  Helpers.dom.triggerEvent(document, 'mouseup');

  Helpers.dom.triggerDelete(editor$o);

  assert.hasElement('#editor p:contains(af)', 'combines sides of selection');

  assert.hasNoElement('#editor span#card-el', 'card el is removed');
  assert.hasNoElement('#editor p:contains(abc)', 'previous section 1 is removed');
  assert.hasNoElement('#editor p:contains(def)', 'previous section 2 is removed');
});

test$Y('selecting text that touches bold text should not be considered bold', (assert) => {

  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([markupSection('p', [marker('abc')])]);
  });
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  Helpers.dom.selectText(editor$o ,'b', editorElement$p);
  Helpers.dom.triggerEvent(document, 'mouseup');

  editor$o.run(postEditor => postEditor.toggleMarkup('strong'));

  assert.hasElement('#editor strong:contains(b)', 'precond - bold text');

  Helpers.dom.selectText(editor$o ,'c', editorElement$p);
  Helpers.dom.triggerEvent(document, 'mouseup');

  let bold = editor$o.builder.createMarkup('strong');
  assert.ok(editor$o.activeMarkups.indexOf(bold) === -1, 'strong is not in selection');
});

// https://github.com/bustle/mobiledoc-kit/issues/121
test$Y('selecting text that includes a 1-character marker and unbolding it', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, markup}) => {
    const b = markup('strong');
    return post([markupSection('p', [
      marker('a'),
      marker('b',[b]),
      marker('c')
    ])]);
  });
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  assert.hasElement('#editor strong:contains(b)', 'precond - bold');

  Helpers.dom.selectText(editor$o ,'b', editorElement$p, 'c', editorElement$p);

  let bold = editor$o.builder.createMarkup('strong');
  assert.ok(editor$o.activeMarkups.indexOf(bold) !== -1, 'strong is in selection');

  editor$o.run(postEditor => postEditor.toggleMarkup('strong'));

  assert.hasNoElement('#editor strong', 'bold text is unboldened');
});

// see https://github.com/bustle/mobiledoc-kit/issues/128
test$Y('selecting text that includes an empty section and applying markup to it', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker}) => {
    return post([
      markupSection('p', [marker('abc')]),
      markupSection('p')
    ]);
  });
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  // precond
  assert.hasElement('#editor p:contains(abc)');
  assert.ok($('#editor p:eq(1)').text() === '', 'no text in second p');
  const t1 = $('#editor p:eq(0)')[0].childNodes[0];
  assert.equal(t1.textContent, 'abc', 'correct text node');
  const p2 = $('#editor p:eq(1)')[0];

  Helpers.dom.moveCursorTo(editor$o, t1, 0, p2, 0);

  editor$o.run(postEditor => postEditor.toggleMarkup('strong'));

  assert.hasElement('#editor p strong:contains(abc)', 'bold is applied to text');
});

test$Y('placing cursor inside a strong section should cause activeMarkups to contain "strong"', (assert) => {
  const mobiledoc = Helpers.mobiledoc.build(({post, markupSection, marker, markup}) => {
    const b = markup('strong');
    return post([markupSection('p', [
      marker('before'),
      marker('loud',[b]),
      marker('after')
    ])]);
  });
  editor$o = new Editor({mobiledoc});
  editor$o.render(editorElement$p);

  Helpers.dom.moveCursorTo(editor$o, $('#editor strong')[0].firstChild, 1);

  let bold = editor$o.builder.createMarkup('strong');
  assert.ok(editor$o.activeMarkups.indexOf(bold) !== -1, 'strong is in selection');

  Helpers.dom.moveCursorTo(editor$o, $('#editor')[0].childNodes[0], 1);
  delete editor$o._activeMarkups;

  assert.ok(editor$o.activeMarkups.indexOf(bold) === -1, 'strong is not in selection');
});

const { module: module$Z, test: test$Z } = Helpers;

const undoBlockTimeout = 2000;

let editor$p, editorElement$q, oldDateNow;

function undo(editor) {
  Helpers.dom.triggerKeyCommand(editor, 'Z', [MODIFIERS.META]);
}

function redo(editor) {
  Helpers.dom.triggerKeyCommand(editor, 'Z', [MODIFIERS.META, MODIFIERS.SHIFT]);
}

module$Z('Acceptance: Editor: Undo/Redo', {
  beforeEach() {
    editorElement$q = $('#editor')[0];
    oldDateNow = Date.now;
  },
  afterEach() {
    Date.now = oldDateNow;
    if (editor$p) {
      editor$p.destroy();
      editor$p = null;
    }
  }
});

test$Z('undo/redo the insertion of a character', (assert) => {
  let done = assert.async();
  let expectedBeforeUndo, expectedAfterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    expectedBeforeUndo = post([markupSection('p', [marker('abcD')])]);
    expectedAfterUndo = post([markupSection('p', [marker('abc')])]);
    return expectedAfterUndo;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abc');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abc'.length);

  Helpers.dom.insertText(editor$p, 'D');

  Helpers.wait(()  => {
    assert.postIsSimilar(editor$p.post, expectedBeforeUndo); // precond
    undo(editor$p);
    assert.postIsSimilar(editor$p.post, expectedAfterUndo);
    assert.renderTreeIsEqual(editor$p._renderTree, expectedAfterUndo);

    let position = editor$p.range.head;
    assert.positionIsEqual(position, editor$p.post.sections.head.tailPosition());

    redo(editor$p);

    assert.postIsSimilar(editor$p.post, expectedBeforeUndo);
    assert.renderTreeIsEqual(editor$p._renderTree, expectedBeforeUndo);

    position = editor$p.range.head;
    assert.positionIsEqual(position, editor$p.post.sections.head.tailPosition());

    done();
  });
});

// Test to ensure that we don't push empty snapshots on the undo stack
// when typing characters
test$Z('undo/redo the insertion of multiple characters', (assert) => {
  let done = assert.async();
  let beforeUndo, afterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    beforeUndo = post([markupSection('p', [marker('abcDE')])]);
    afterUndo = post([markupSection('p', [marker('abc')])]);
    return afterUndo;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abc');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abc'.length);

  Helpers.dom.insertText(editor$p, 'D');

  Helpers.wait(()  => {
    Helpers.dom.insertText(editor$p, 'E');

    Helpers.wait(()  => {
      assert.postIsSimilar(
        editor$p.post, beforeUndo,
        'precond - post was updated with new characters'
      );

      undo(editor$p);
      assert.postIsSimilar(
        editor$p.post, afterUndo,
        'ensure undo grouped to include both characters'
      );

      redo(editor$p);
      assert.postIsSimilar(
        editor$p.post, beforeUndo,
        'ensure redo grouped to include both characters'
      );
      done();
    });
  });
});


// Test to ensure that undo events group after a timeout
test$Z('make sure undo/redo events group when adding text', (assert) => {
  let done = assert.async();
  let beforeUndo, afterUndo1, afterUndo2;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    beforeUndo = post([markupSection('p', [marker('123456789')])]);
    afterUndo1 = post([markupSection('p', [marker('123456')])]);
    afterUndo2 = post([markupSection('p', [marker('123')])]);
    return afterUndo2;
  }, {undoBlockTimeout});

  let textNode = Helpers.dom.findTextNode(editorElement$q, '123');
  Helpers.dom.moveCursorTo(editor$p, textNode, '123'.length);

  Helpers.dom.insertText(editor$p, '4');

  Helpers.wait(()  => {
    Helpers.dom.insertText(editor$p, '5');
    Helpers.wait(()  => {
      Helpers.dom.insertText(editor$p, '6');
      Helpers.wait(()  => {
        Date.now = function() {
          return oldDateNow.call(Date) + undoBlockTimeout + 1;
        };
        Helpers.dom.insertText(editor$p, '7');
        Helpers.wait(()  => {
          Helpers.dom.insertText(editor$p, '8');
          Helpers.wait(()  => {
            Helpers.dom.insertText(editor$p, '9');
            assert.postIsSimilar(editor$p.post, beforeUndo);

            undo(editor$p);
            assert.postIsSimilar(editor$p.post, afterUndo1);

            undo(editor$p);
            assert.postIsSimilar(editor$p.post, afterUndo2);

            redo(editor$p);
            assert.postIsSimilar(editor$p.post, afterUndo1);
            done();
          });
        });
      });
    });
  });
});


test$Z('make sure undo/redo events group when deleting text', (assert) => {
  let done = assert.async();
  let beforeUndo, afterUndo1, afterUndo2;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    beforeUndo = post([markupSection('p', [marker('123')])]);
    afterUndo1 = post([markupSection('p', [marker('123456')])]);
    afterUndo2 = post([markupSection('p', [marker('123456789')])]);
    return afterUndo2;
  }, {undoBlockTimeout});

  let textNode = Helpers.dom.findTextNode(editorElement$q, '123456789');
  Helpers.dom.moveCursorTo(editor$p, textNode, '123456789'.length);

    Helpers.dom.triggerDelete(editor$p);
    Helpers.dom.triggerDelete(editor$p);
    Helpers.dom.triggerDelete(editor$p);

    Helpers.wait(()  => {
      Date.now = function() {
        return oldDateNow.call(Date) + undoBlockTimeout + 1;
      };

      Helpers.dom.triggerDelete(editor$p);
      Helpers.dom.triggerDelete(editor$p);
      Helpers.dom.triggerDelete(editor$p);

      assert.postIsSimilar(editor$p.post, beforeUndo);

      undo(editor$p);
      assert.postIsSimilar(editor$p.post, afterUndo1);

      undo(editor$p);
      assert.postIsSimilar(editor$p.post, afterUndo2);

      redo(editor$p);
      assert.postIsSimilar(editor$p.post, afterUndo1);
      done();
    });
});


test$Z('adding and deleting characters break the undo group/run', (assert) => {
  let beforeUndo, afterUndo1, afterUndo2;
  let done = assert.async();
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    beforeUndo = post([markupSection('p', [marker('abcXY')])]);
    afterUndo1 = post([markupSection('p', [marker('abc')])]);
    afterUndo2 = post([markupSection('p', [marker('abcDE')])]);
    return afterUndo2;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abcDE');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abcDE'.length);

  Helpers.dom.triggerDelete(editor$p);
  Helpers.dom.triggerDelete(editor$p);

    Helpers.dom.insertText(editor$p, 'X');

    Helpers.wait(()  => {
      Helpers.dom.insertText(editor$p, 'Y');

      Helpers.wait(()  => {
        assert.postIsSimilar(editor$p.post, beforeUndo); // precond

        undo(editor$p);
        assert.postIsSimilar(editor$p.post, afterUndo1);

        undo(editor$p);
        assert.postIsSimilar(editor$p.post, afterUndo2);

        redo(editor$p);
        assert.postIsSimilar(editor$p.post, afterUndo1);

        redo(editor$p);
        assert.postIsSimilar(editor$p.post, beforeUndo);
        done();
      });
    });
});

test$Z('undo the deletion of a character', (assert) => {
  let expectedBeforeUndo, expectedAfterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    expectedBeforeUndo = post([markupSection('p', [marker('abc')])]);
    expectedAfterUndo = post([markupSection('p', [marker('abcD')])]);
    return expectedAfterUndo;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abcD');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abcD'.length);

  Helpers.dom.triggerDelete(editor$p);

  assert.postIsSimilar(editor$p.post, expectedBeforeUndo); // precond

  undo(editor$p);
  assert.postIsSimilar(editor$p.post, expectedAfterUndo);
  assert.renderTreeIsEqual(editor$p._renderTree, expectedAfterUndo);
  let position = editor$p.range.head;
  assert.positionIsEqual(position, editor$p.post.sections.head.tailPosition());

  redo(editor$p);
  assert.postIsSimilar(editor$p.post, expectedBeforeUndo);
  assert.renderTreeIsEqual(editor$p._renderTree, expectedBeforeUndo);
  position = editor$p.range.head;
  assert.positionIsEqual(position, editor$p.post.sections.head.tailPosition());
});

test$Z('undo the deletion of a range', (assert) => {
  let expectedBeforeUndo, expectedAfterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    expectedBeforeUndo = post([markupSection('p', [marker('ad')])]);
    expectedAfterUndo = post([markupSection('p', [marker('abcd')])]);
    return expectedAfterUndo;
  });

  Helpers.dom.selectText(editor$p ,'bc', editorElement$q);
  Helpers.dom.triggerDelete(editor$p);

  assert.postIsSimilar(editor$p.post, expectedBeforeUndo); // precond

  undo(editor$p);
  assert.postIsSimilar(editor$p.post, expectedAfterUndo);
  assert.renderTreeIsEqual(editor$p._renderTree, expectedAfterUndo);
  let { head, tail } = editor$p.range;
  let section = editor$p.post.sections.head;
  assert.positionIsEqual(head, section.toPosition('a'.length));
  assert.positionIsEqual(tail, section.toPosition('abc'.length));

  redo(editor$p);
  assert.postIsSimilar(editor$p.post, expectedBeforeUndo);
  assert.renderTreeIsEqual(editor$p._renderTree, expectedBeforeUndo);
  head = editor$p.range.head;
  tail = editor$p.range.tail;
  section = editor$p.post.sections.head;
  assert.positionIsEqual(head, section.toPosition('a'.length));
  assert.positionIsEqual(tail, section.toPosition('a'.length));
});

test$Z('undo insertion of character to a list item', (assert) => {
  let done = assert.async();
  let expectedBeforeUndo, expectedAfterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, listSection, listItem, marker}) => {
    expectedBeforeUndo = post([
      listSection('ul', [listItem([marker('abcD')])])
    ]);
    expectedAfterUndo = post([
      listSection('ul', [listItem([marker('abc')])])
    ]);
    return expectedAfterUndo;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abc');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abc'.length);
  Helpers.dom.insertText(editor$p, 'D');

  Helpers.wait(() => {
    assert.postIsSimilar(editor$p.post, expectedBeforeUndo); // precond

    undo(editor$p);
    assert.postIsSimilar(editor$p.post, expectedAfterUndo);
    assert.renderTreeIsEqual(editor$p._renderTree, expectedAfterUndo);
    let { head, tail } = editor$p.range;
    let section = editor$p.post.sections.head.items.head;
    assert.positionIsEqual(head, section.toPosition('abc'.length));
    assert.positionIsEqual(tail, section.toPosition('abc'.length));

    redo(editor$p);
    assert.postIsSimilar(editor$p.post, expectedBeforeUndo);
    assert.renderTreeIsEqual(editor$p._renderTree, expectedBeforeUndo);
    head = editor$p.range.head;
    tail = editor$p.range.tail;
    section = editor$p.post.sections.head.items.head;
    assert.positionIsEqual(head, section.toPosition('abcD'.length));
    assert.positionIsEqual(tail, section.toPosition('abcD'.length));

    done();
  });
});

test$Z('undo stack length can be configured (depth 1)', (assert) => {
  let done = assert.async();
  let editorOptions = { undoDepth: 1 };

  let beforeUndo, afterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    beforeUndo = post([markupSection('p', [marker('abcDE')])]);
    afterUndo = post([markupSection('p', [marker('abc')])]);
    return post([markupSection('p', [marker('abc')])]);
  }, editorOptions);

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abc');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abc'.length);
  Helpers.dom.insertText(editor$p, 'D');

  Helpers.wait(() => {
    Helpers.dom.insertText(editor$p, 'E');

    Helpers.wait(() => {
      assert.postIsSimilar(editor$p.post, beforeUndo); // precond

      undo(editor$p);
      assert.postIsSimilar(editor$p.post, afterUndo);
      assert.renderTreeIsEqual(editor$p._renderTree, afterUndo);
      assert.positionIsEqual(editor$p.range.head, editor$p.post.sections.head.tailPosition());

      undo(editor$p);
      assert.postIsSimilar(editor$p.post, afterUndo, 'second undo does not change post');
      assert.renderTreeIsEqual(editor$p._renderTree, afterUndo);
      assert.positionIsEqual(editor$p.range.head, editor$p.post.sections.head.tailPosition());

      done();
    });
  });
});

test$Z('undo stack length can be configured (depth 0)', (assert) => {
  let done = assert.async();
  let editorOptions = { undoDepth: 0 };

  let beforeUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
    beforeUndo = post([markupSection('p', [marker('abcDE')])]);
    return post([markupSection('p', [marker('abc')])]);
  }, editorOptions);

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'abc');
  Helpers.dom.moveCursorTo(editor$p, textNode, 'abc'.length);
  Helpers.dom.insertText(editor$p, 'D');

  Helpers.wait(() => {
    Helpers.dom.insertText(editor$p, 'E');

    Helpers.wait(() => {
      assert.postIsSimilar(editor$p.post, beforeUndo); // precond

      undo(editor$p);
      assert.postIsSimilar(editor$p.post, beforeUndo, 'nothing is undone');
      assert.renderTreeIsEqual(editor$p._renderTree, beforeUndo);
      assert.positionIsEqual(editor$p.range.head, editor$p.post.sections.head.tailPosition());

      done();
    });
  });
});

test$Z('taking and restoring a snapshot with no cursor', (assert) => {
  let beforeUndo, afterUndo;
  editor$p = Helpers.mobiledoc.renderInto(editorElement$q, ({post, markupSection, marker}) => {
     beforeUndo = post([markupSection('p', [marker('abc')])]);
     afterUndo = post([markupSection('p', [])]);
     return afterUndo;
  }, {autofocus: false});

  assert.ok(!editor$p.cursor.hasCursor(), 'precond - no cursor');
  editor$p.run(postEditor => {
    postEditor.insertText(editor$p.post.headPosition(), 'abc');
  });
  assert.postIsSimilar(editor$p.post, beforeUndo, 'precond - text is added');

  undo(editor$p);
  assert.postIsSimilar(editor$p.post, afterUndo, 'text is removed');
});

test$Z('take and undo a snapshot based on drag/dropping of text', (assert) => {
  let done = assert.async();
  let text = 'abc';
  let beforeUndo, afterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker}) => {
     beforeUndo = post([markupSection('p', [marker(text)])]);
     afterUndo = post([markupSection('p', [marker('a')])]);
     return afterUndo;
  });

  let textNode = Helpers.dom.findTextNode(editorElement$q, 'a');
  textNode.textContent = text;

  // Allow the mutation observer to fire, then...
  Helpers.wait(function() {
    assert.postIsSimilar(editor$p.post, beforeUndo, 'precond - text is added');
    undo(editor$p);
    assert.postIsSimilar(editor$p.post, afterUndo, 'text is removed');
    done();
  });
});

test$Z('take and undo a snapshot when adding a card', (assert) => {
  let text = 'abc';
  let myCard = {
    name: 'my-card',
    type: 'dom',
    render() {
      return document.createTextNode('card contents');
    }
  };

  let beforeUndo, afterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker, cardSection}) => {
     beforeUndo = post([
       markupSection('p', [marker(text)]),
       cardSection('my-card', {})
     ]);
     afterUndo = post([markupSection('p', [marker(text)])]);
     return afterUndo;
  }, {
    cards: [myCard]
  });

  editor$p.run(postEditor => {
    let card = editor$p.builder.createCardSection('my-card', {});
    postEditor.insertSectionBefore(editor$p.post.sections, card, null);
  });

  assert.postIsSimilar(editor$p.post, beforeUndo, 'precond - card is added');
  undo(editor$p);
  assert.postIsSimilar(editor$p.post, afterUndo, 'card is removed');
});

test$Z('take and undo a snapshot when removing an atom', (assert) => {
  let text = 'abc';
  let myAtom = {
    name: 'my-atom',
    type: 'dom',
    render() {
      return document.createTextNode('atom contents');
    }
  };

  let beforeUndo, afterUndo;
  editor$p = Helpers.mobiledoc.renderIntoAndFocusTail(editorElement$q, ({post, markupSection, marker, atom}) => {
    beforeUndo = post([
      markupSection('p', [
        marker(text)
      ])
    ]);
    afterUndo = post([
      markupSection('p', [
        marker(text),
        atom('my-atom', 'content', {})
      ]),
    ]);
    return afterUndo;
  }, {
    atoms: [myAtom]
  });

  editor$p.run(postEditor => {
    postEditor.removeMarker(editor$p.post.sections.head.markers.tail);
  });

  assert.postIsSimilar(editor$p.post, beforeUndo, 'precond - atom is removed');
  undo(editor$p);
  assert.postIsSimilar(editor$p.post, afterUndo, 'atom is restored');
});

window.$ = jquery;
//# sourceMappingURL=tests.js.map
